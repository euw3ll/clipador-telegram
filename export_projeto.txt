üìÑ configuracoes.py
---
from core.ambiente import (
    TWITCH_CLIENT_ID,
    TWITCH_CLIENT_SECRET,
    TELEGRAM_BOT_TOKEN,
    TELEGRAM_CHAT_ID,
)


#IDs dos usu√°rios administradores do bot
ADMIN_TELEGRAM_IDS = [1527996001] # Adicione o ID do novo admin aqui


"""CONFIGURA√á√ïES DO CANAL GRATUITO"""
# üí¨ CANAL DO TELEGRAM
CANAL_GRATUITO_ID = TELEGRAM_CHAT_ID # ID num√©rico do canal gratuito
LINK_CANAL_GRATUITO = "https://t.me/clipadorfree" # IMPORTANTE: Substitua pelo link de convite do seu canal gratuito

# ‚öôÔ∏è PAR√ÇMETROS DE MONITORAMENTO
QUANTIDADE_STREAMERS_TOP_BR = 5      # Quantos streamers do topo do Brasil monitorar.
STREAMERS_ADICIONAIS_GRATUITO = [] # Lista de streamers para monitorar ADICIONALMENTE aos tops. Deixe [] se n√£o quiser.
INTERVALO_ANALISE_MINUTOS_GRATUITO = 10 # Janela de tempo para buscar clipes (em minutos).

# üîÑ SWITCHES DE FUNCIONALIDADE
ENABLE_NGROK = False
MODO_MONITORAMENTO_GRATUITO = "MANUAL" # Op√ß√µes para o canal gratuito: 'AUTOMATICO' (sensibilidade baseada em viewers) ou 'MANUAL' (usa as constantes de `canal_gratuito/core/monitor.py`)
TIPO_LOG = "PADRAO"  # "PADRAO" ou "DESENVOLVEDOR"
ATUALIZAR_DESCRICAO = True
ENVIAR_CLIPES = True
USAR_VERIFICACAO_AO_VIVO = True

# ‚è∞ INTERVALOS DE MENSAGENS (em segundos)
INTERVALO_ATUALIZAR_DESCRICAO = 300
INTERVALO_MENSAGEM_PROMOCIONAL = 800
INTERVALO_MENSAGEM_HEADER = 5400
INTERVALO_ATUALIZACAO_STREAMERS = 5400

"""CONFIGURA√á√ïES DO CHAT PRIVADO"""
MODO_MANUTENCAO = False
GATEWAY_PAGAMENTO = "KIRVANO"  # 'MERCADOPAGO' ou 'KIRVANO'
SUPPORT_USERNAME = "euw3ll" # Usu√°rio para o bot√£o de suporte

# --- NOVO: Configura√ß√µes do Teste Gratuito ---
TESTE_GRATUITO_ATIVO = True # True para ativar, False para desativar o bot√£o
TESTE_GRATUITO_DURACAO_DIAS = 3 # Dura√ß√£o do per√≠odo de teste em dias

# Links de pagamento da Kirvano
KIRVANO_LINKS = {
    "Teste Gratuito": "https://pay.kirvano.com/5f583d6e-2343-4842-9419-0f944bb090c3", # Link para o produto de R$0,00
    "Mensal Solo": "https://pay.kirvano.com/3f315c85-0164-4b55-81f2-6ffa661b670c",
    "Mensal Plus": "https://pay.kirvano.com/6283e70f-f385-4355-8cff-e02275935cde",
    "Anual Pro": "https://pay.kirvano.com/09287018-c006-4c0e-87c7-08a6e4464e79",
    "Slot Extra": "https://pay.kirvano.com/6f6d41a4-f4a9-459a-892f-b881b34b602e"
}

# Pre√ßos dos planos e produtos
PLANOS_PRECOS = {
    "Teste Gratuito": 0.00,
    "Mensal Solo": 19.90,
    "Mensal Plus": 39.90,
    "Anual Pro": 199.00,
    "Slot Extra": 9.90
}
---
üìÑ start.py
---
from configuracoes import TIPO_LOG, ENABLE_NGROK
from core.bootstrap import validar_variaveis_ambiente
from core.database import inicializar_banco # <-- 1. Importar a nova fun√ß√£o
import os
import subprocess
import time
import requests

os.environ["PYTHONWARNINGS"] = "ignore"

import warnings
warnings.filterwarnings("ignore")

from threading import Thread
from core.launcher import iniciar_clipador
from canal_gratuito.core.telegram import atualizar_descricao_telegram_offline

def iniciar_webhook():
    if ENABLE_NGROK:
        print("üåê Iniciando servidor do Webhook Kirvano com ngrok...")
    else:
        print("üåê Iniciando servidor do Webhook Kirvano (ngrok desativado)...")
    subprocess.Popen(["python3", "start_webhook.py"])

try:
    # Valida as vari√°veis de ambiente primeiro
    validar_variaveis_ambiente()
    print("‚úÖ Ambiente validado com sucesso.\n")

    # Prepara o banco de dados ANTES de iniciar qualquer outra funcionalidade
    print("üîß Preparando o banco de dados PostgreSQL...")
    inicializar_banco() # <-- 2. Chamar a fun√ß√£o de inicializa√ß√£o
    print("‚úÖ Banco de dados pronto.\n")


    Thread(target=iniciar_webhook).start()

    print("üöÄ Iniciando Clipador!")
    iniciar_clipador(validar_variaveis=False)
except KeyboardInterrupt:
    print("\nüõë Clipador encerrado.")
    atualizar_descricao_telegram_offline()
---
üìÑ start_webhook.py
---
from core.gateway.webhook_kirvano import iniciar_webhook

if __name__ == "__main__":
    iniciar_webhook()
---
üìÑ core/bootstrap.py
---
from core.ambiente import (
    TWITCH_CLIENT_ID,
    TWITCH_CLIENT_SECRET,
    TELEGRAM_BOT_TOKEN,
    TELEGRAM_CHAT_ID
)
from core.database import criar_tabelas  # ‚¨ÖÔ∏è IMPORTANTE

def validar_variaveis_ambiente():
    if not TWITCH_CLIENT_ID or not TWITCH_CLIENT_SECRET:
        raise EnvironmentError("‚ùå Vari√°veis da Twitch n√£o configuradas corretamente.")
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        raise EnvironmentError("‚ùå Vari√°veis do Telegram n√£o configuradas corretamente.")

def iniciar_ambiente():
    print("üîÅ Validando vari√°veis de ambiente...")
    validar_variaveis_ambiente()
    criar_tabelas()  # ‚¨ÖÔ∏è CRIA AS TABELAS NO BANCO
    print("‚úÖ Ambiente validado com sucesso.")

---
üìÑ core/pagamento.py
---
from configuracoes import GATEWAY_PAGAMENTO

if GATEWAY_PAGAMENTO == "KIRVANO":
    # A Kirvano n√£o possui API de cria√ß√£o ou consulta de pagamento
    # As cobran√ßas s√£o feitas por links fixos e validadas via Webhook
    def criar_pagamento_pix(*args, **kwargs):
        raise NotImplementedError("‚ùå O gateway 'KIRVANO' n√£o permite gerar Pix via API.")

    def criar_pagamento_cartao(*args, **kwargs):
        raise NotImplementedError("‚ùå O gateway 'KIRVANO' n√£o permite gerar Cart√£o via API.")

    def consultar_pagamento(*args, **kwargs):
        raise NotImplementedError("‚ùå O gateway 'KIRVANO' n√£o permite consultar status de pagamento via API.")

elif GATEWAY_PAGAMENTO == "MERCADOPAGO":
    from core.gateway.mercadopago import (
        criar_pagamento_pix,
        criar_pagamento_cartao,
        consultar_pagamento
    )

else:
    raise ValueError(f"‚ùå Gateway de pagamento '{GATEWAY_PAGAMENTO}' n√£o √© suportado. Verifique o valor em configuracoes.py.")

---
üìÑ core/image_utils.py
---
import os
from PIL import Image, ImageDraw, ImageFont
import requests
from io import BytesIO
import logging

logger = logging.getLogger(__name__)

async def gerar_imagem_canal_personalizada(telegram_id: int, context) -> str:
    """
    Gera uma imagem de perfil personalizada para o canal do Telegram.
    Coloca a foto de perfil do usu√°rio no canto inferior direito de uma imagem base.
    """
    base_image_path = os.path.join("images", "logo_canal.jpg")
    output_dir = "memoria/canais_imagens"
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, f"canal_{telegram_id}.jpg")

    try:
        # Carregar imagem base
        if not os.path.exists(base_image_path):
            logger.warning(f"Imagem base n√£o encontrada em {base_image_path}. Criando uma imagem padr√£o.")
            base_img = Image.new('RGB', (500, 500), color = (73, 109, 137))
            d = ImageDraw.Draw(base_img)
            fnt = ImageFont.load_default()
            d.text((10,10), "Clipador", font=fnt, fill=(255,255,255))
        else:
            base_img = Image.open(base_image_path).convert("RGBA")

        # Obter foto de perfil do usu√°rio
        user_profile_photos = await context.bot.get_user_profile_photos(user_id=telegram_id, limit=1)
        if user_profile_photos.photos and user_profile_photos.photos[0]:
            photo_file_id = user_profile_photos.photos[0][-1].file_id # Pega a maior vers√£o da foto
            photo_file = await context.bot.get_file(photo_file_id)
            response = requests.get(photo_file.file_path)
            user_img = Image.open(BytesIO(response.content)).convert("RGBA")

            # Redimensionar e colar a imagem do usu√°rio (MAIOR)
            base_width, base_height = base_img.size
            target_size = int(min(base_width, base_height) * 0.6) # Aumentado de 0.4 para 0.6 para preencher mais
            user_img = user_img.resize((target_size, target_size), Image.LANCZOS)

            # Criar uma m√°scara circular
            mask = Image.new('L', (target_size, target_size), 0)
            draw = ImageDraw.Draw(mask)
            draw.ellipse((0, 0, target_size, target_size), fill=255)
            
            # Posi√ß√£o no canto inferior direito, com uma pequena margem proporcional
            margin = int(target_size * 0.02) # 2% da nova dimens√£o como margem
            position_x = base_width - target_size - margin
            position_y = base_height - target_size - margin

            base_img.paste(user_img, (position_x, position_y), mask)
        else:
            logger.info(f"Usu√°rio {telegram_id} n√£o possui foto de perfil. Gerando avatar com inicial.")
            
            # 1. Obter nome do usu√°rio para a inicial
            user = await context.bot.get_chat(telegram_id)
            initial = user.first_name[0].upper() if user.first_name else '?'

            # 2. Definir tamanho e criar a imagem do avatar
            base_width, base_height = base_img.size
            target_size = int(min(base_width, base_height) * 0.6)
            
            # 3. Escolher uma cor de fundo baseada no ID do usu√°rio para consist√™ncia
            colors = [
                (255, 105, 97), (255, 182, 193), (255, 204, 153), (204, 255, 153),
                (173, 216, 230), (204, 153, 255), (255, 153, 204), (153, 255, 204)
            ]
            bg_color = colors[telegram_id % len(colors)]

            # 4. Desenhar o avatar
            avatar_img = Image.new('RGBA', (target_size, target_size), (255, 255, 255, 0))
            draw = ImageDraw.Draw(avatar_img)
            draw.ellipse((0, 0, target_size, target_size), fill=bg_color)

            # 5. Adicionar a inicial no centro
            try:
                font_size = int(target_size * 0.6)
                # Usa uma fonte local para garantir consist√™ncia entre ambientes.
                # O arquivo .ttf deve estar na pasta 'assets/fonts/'.
                font_path = os.path.join("assets", "fonts", "DejaVuSans.ttf")
                font = ImageFont.truetype(font_path, font_size)
            except IOError:
                logger.warning(f"Fonte em '{font_path}' n√£o encontrada. Usando fonte padr√£o. Certifique-se de que o arquivo de fonte existe.")
                font = ImageFont.load_default()

            bbox = draw.textbbox((0, 0), initial, font=font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]
            text_x = (target_size - text_width) / 2
            text_y = (target_size - text_height) / 2 - bbox[1]
            draw.text((text_x, text_y), initial, font=font, fill=(255, 255, 255))

            # 6. Colar o avatar gerado na imagem base
            base_img.paste(avatar_img, (base_width - target_size - int(target_size * 0.02), base_height - target_size - int(target_size * 0.02)), avatar_img)

        # Salvar imagem final
        # Converte para RGB antes de salvar como JPEG para evitar problemas com o canal alfa
        if base_img.mode == 'RGBA':
            base_img = base_img.convert('RGB')
        
        base_img.save(output_path, "JPEG")
        return output_path

    except Exception as e:
        logger.error(f"Erro ao gerar imagem de canal personalizada para {telegram_id}: {e}")
        # Retorna a imagem padr√£o se houver erro
        return base_image_path
---
üìÑ core/handlers_seguranca.py
---
import logging
import os
from telegram import Update
from telegram.ext import ContextTypes
from telegram.constants import ChatMemberStatus
from telegram.error import TelegramError, BadRequest
from telegram.helpers import escape_markdown

from core.database import buscar_configuracao_canal, limpar_caminho_imagem_perfil, buscar_dono_do_canal

logger = logging.getLogger(__name__)

async def verificar_novo_membro(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handler para verificar novos membros em canais de clientes.
    Remove qualquer usu√°rio que n√£o seja o dono do canal.
    """
    if not update.chat_member:
        return

    chat_id = update.chat_member.chat.id
    novo_membro = update.chat_member.new_chat_member

    # Ignora se n√£o for um novo membro entrando (ex: promo√ß√£o a admin, etc.)
    if novo_membro.status not in [ChatMemberStatus.MEMBER, ChatMemberStatus.OWNER]:
        return

    id_usuario_novo = novo_membro.user.id

    try:
        id_dono_canal = buscar_dono_do_canal(chat_id)

        # Se o canal n√£o for um canal de cliente registrado, n√£o faz nada.
        if id_dono_canal is None:
            return

        # Se o novo membro n√£o for o dono do canal, remove-o.
        if id_usuario_novo != id_dono_canal:
            logger.info(f"Usu√°rio intruso (ID: {id_usuario_novo}) tentou entrar no canal {chat_id} do dono {id_dono_canal}. Removendo...")
            await context.bot.ban_chat_member(chat_id=chat_id, user_id=id_usuario_novo)
            await context.bot.unban_chat_member(chat_id=chat_id, user_id=id_usuario_novo) # Desbane para permitir futuras tentativas com link v√°lido
            logger.info(f"Usu√°rio {id_usuario_novo} removido e desbanido do canal {chat_id}.")
        
        # Se o novo membro for o dono, customiza o canal.
        elif id_usuario_novo == id_dono_canal:
            logger.info(f"Dono do canal (ID: {id_dono_canal}) entrou no canal {chat_id}. Iniciando customiza√ß√£o...")
            
            config = buscar_configuracao_canal(id_dono_canal)
            if not config:
                logger.warning(f"N√£o foi poss√≠vel encontrar a configura√ß√£o para o dono {id_dono_canal} ao customizar o canal {chat_id}.")
                return

            # A customiza√ß√£o s√≥ roda uma vez, verificando se o caminho da imagem existe no DB.
            caminho_imagem_perfil = config.get('caminho_imagem_perfil')
            if not caminho_imagem_perfil:
                logger.info(f"Customiza√ß√£o para o canal {chat_id} j√° foi realizada ou n√£o √© necess√°ria. Pulando.")
                return

            nome_exibicao = novo_membro.user.username or novo_membro.user.first_name
            # Escapa o nome para evitar erros de formata√ß√£o no Markdown
            nome_exibicao_escaped = escape_markdown(nome_exibicao)

            try:
                # 1. Customizar T√≠tulo e Foto
                await context.bot.set_chat_title(chat_id=chat_id, title=f"Clipador üé• {nome_exibicao}")
                if caminho_imagem_perfil and os.path.exists(caminho_imagem_perfil):
                    with open(caminho_imagem_perfil, 'rb') as photo_file:
                        await context.bot.set_chat_photo(chat_id=chat_id, photo=photo_file)
                
                # 2. Enviar Mensagem de Boas-Vindas
                streamers = [s.strip() for s in config.get('streamers_monitorados', '').split(',') if s.strip()]
                num_streamers = len(streamers)
                slots_ativos = config.get('slots_ativos', 1)
                modo = config.get('modo_monitoramento', 'N/A')
                streamers_str = "\n".join([f"‚Ä¢ `{escape_markdown(s)}`" for s in streamers]) if streamers else "Nenhum streamer configurado."

                welcome_message_parts = [
                    f"üéâ Bem-vindo(a) ao seu canal Clipador, @{nome_exibicao_escaped}!\n",
                    "Sua configura√ß√£o inicial est√° pronta para come√ßar a clipar os melhores momentos. üöÄ\n",
                    "*" + ("-" * 25) + "*",
                    "üìã *Resumo da sua Configura√ß√£o:*",
                    f"üì∫ *Streamers Monitorados ({num_streamers}/{slots_ativos}):*",
                    streamers_str,
                    f"üß† *Modo de Monitoramento:* `{escape_markdown(modo)}`",
                    "*" + ("-" * 25) + "*\n"
                ]
                await context.bot.send_message(chat_id=chat_id, text="\n".join(welcome_message_parts), parse_mode="Markdown")

                # 3. Limpeza
                if caminho_imagem_perfil and os.path.exists(caminho_imagem_perfil):
                    os.remove(caminho_imagem_perfil)
                limpar_caminho_imagem_perfil(id_dono_canal)
                logger.info(f"Customiza√ß√£o do canal {chat_id} para o dono {id_dono_canal} conclu√≠da com sucesso.")

            except BadRequest as e:
                logger.error(f"Erro de BadRequest (provavelmente Markdown) ao customizar o canal {chat_id}: {e}")
            except TelegramError as e: # Captura outras exce√ß√µes do Telegram
                logger.error(f"Erro de Telegram ao customizar o canal {chat_id}: {e}")
            except Exception as e:
                logger.error(f"Erro inesperado ao customizar o canal {chat_id}: {e}", exc_info=True)

    except Exception as e:
        logger.error(f"Erro ao verificar novo membro no canal {chat_id}: {e}", exc_info=True)
---
üìÑ core/ambiente.py
---
from dotenv import load_dotenv
import os

load_dotenv()

# TWITCH
TWITCH_CLIENT_ID = os.getenv("TWITCH_CLIENT_ID", "").strip()
TWITCH_CLIENT_SECRET = os.getenv("TWITCH_CLIENT_SECRET", "").strip()

# TELEGRAM
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").strip()

# Credenciais do PostgreSQL ---
POSTGRES_DB = os.getenv("POSTGRES_DB", "").strip()
POSTGRES_USER = os.getenv("POSTGRES_USER", "").strip()
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "").strip()
POSTGRES_HOST = os.getenv("POSTGRES_HOST", "localhost").strip()
POSTGRES_PORT = os.getenv("POSTGRES_PORT", "5432").strip()


# MERCADO PAGO
MERCADO_PAGO_PUBLIC_KEY = os.getenv("MERCADO_PAGO_PUBLIC_KEY")
MERCADO_PAGO_ACCESS_TOKEN = os.getenv("MERCADO_PAGO_ACCESS_TOKEN")

# KIRVANO
KIRVANO_TOKEN = os.getenv("KIRVANO_TOKEN", "").strip()
---
üìÑ core/database.py
---
import psycopg2
from psycopg2.extras import DictCursor
import os
import logging
from typing import Optional, List, Dict, Any
from datetime import datetime

# Importa as vari√°veis de ambiente do PostgreSQL
from core.ambiente import (
    POSTGRES_DB,
    POSTGRES_USER,
    POSTGRES_PASSWORD,
    POSTGRES_HOST,
    POSTGRES_PORT,
)

logger = logging.getLogger(__name__)


def conectar():
    """Estabelece conex√£o com o banco de dados PostgreSQL."""
    try:
        conn = psycopg2.connect(
            dbname=POSTGRES_DB,
            user=POSTGRES_USER,
            password=POSTGRES_PASSWORD,
            host=POSTGRES_HOST,
            port=POSTGRES_PORT,
        )
        return conn
    except psycopg2.OperationalError as e:
        logger.error(f"‚ùå Erro fatal ao conectar com o PostgreSQL: {e}")
        raise


def criar_tabelas():
    """Cria todas as tabelas no banco de dados PostgreSQL se elas n√£o existirem."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # Tabela de usu√°rios
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS usuarios (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT UNIQUE NOT NULL,
                    nome TEXT,
                    email TEXT UNIQUE,
                    nivel INTEGER DEFAULT 1,
                    status_pagamento TEXT DEFAULT 'pendente',
                    plano_assinado TEXT DEFAULT NULL,
                    configuracao_finalizada BOOLEAN DEFAULT FALSE,
                    data_expiracao TIMESTAMPTZ,
                    status_canal TEXT DEFAULT 'ativo',
                    aviso_canal_gratuito_enviado BOOLEAN DEFAULT FALSE,
                    ultimo_aviso_expiracao INTEGER DEFAULT NULL,
                    usou_teste_gratuito BOOLEAN DEFAULT FALSE
                )
            """)

            # Tabela de configura√ß√µes de canal
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS configuracoes_canal (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT UNIQUE NOT NULL,
                    id_canal_telegram TEXT,
                    twitch_client_id TEXT,
                    twitch_client_secret TEXT,
                    link_canal_telegram TEXT,
                    streamers_monitorados TEXT,
                    modo_monitoramento TEXT,
                    slots_ativos INTEGER DEFAULT 1,
                    data_criacao TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    streamers_ultima_modificacao TIMESTAMPTZ,
                    manual_min_clips INTEGER,
                    manual_interval_sec INTEGER,
                    manual_min_clips_vod INTEGER,
                    clipador_chefe_username TEXT,
                    modo_parceiro TEXT
                )
            """)

            # Tabela de hist√≥rico de envios
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS historico_envios (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT NOT NULL,
                    clipe_id TEXT,
                    streamer_id TEXT NOT NULL,
                    grupo_inicio TIMESTAMPTZ NOT NULL,
                    grupo_fim TIMESTAMPTZ NOT NULL,
                    enviado_em TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Tabela de status dos streamers
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS status_streamers (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT NOT NULL,
                    streamer_id TEXT NOT NULL,
                    status TEXT NOT NULL,
                    ultima_verificacao TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(telegram_id, streamer_id)
                )
            """)

            # Tabela de compras
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS compras (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT,
                    email TEXT NOT NULL,
                    plano TEXT NOT NULL,
                    metodo_pagamento TEXT,
                    status TEXT DEFAULT 'aprovado',
                    sale_id TEXT,
                    data_criacao TEXT,
                    offer_id TEXT,
                    nome_completo TEXT,
                    telefone TEXT,
                    criado_em TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Tabela de notifica√ß√µes com FOREIGN KEY
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS notificacoes_config (
                    id SERIAL PRIMARY KEY,
                    telegram_id BIGINT UNIQUE NOT NULL,
                    notificar_online BOOLEAN DEFAULT TRUE,
                    CONSTRAINT fk_usuarios
                        FOREIGN KEY(telegram_id) 
                        REFERENCES usuarios(telegram_id)
                        ON DELETE CASCADE
                )
            """)
            conn.commit()
            logger.info("Verifica√ß√£o de tabelas conclu√≠da.")
    except psycopg2.Error as e:
        logger.error(f"Erro ao criar tabelas: {e}")
        conn.rollback()
    finally:
        conn.close()


def migrar_tabelas():
    """Adiciona colunas faltantes a tabelas existentes para evitar erros ap√≥s atualiza√ß√µes."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            def coluna_existe(tabela, coluna):
                cursor.execute("""
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_schema = 'public' AND table_name = %s AND column_name = %s
                """, (tabela, coluna))
                return cursor.fetchone() is not None

            colunas_config = {
                "manual_min_clips": "INTEGER", "manual_interval_sec": "INTEGER",
                "manual_min_clips_vod": "INTEGER", "clipador_chefe_username": "TEXT", "modo_parceiro": "TEXT"
            }
            for nome, tipo in colunas_config.items():
                if not coluna_existe('configuracoes_canal', nome):
                    cursor.execute(f"ALTER TABLE configuracoes_canal ADD COLUMN {nome} {tipo}")
                    logger.info(f"Migra√ß√£o: Coluna '{nome}' adicionada a 'configuracoes_canal'.")

            colunas_usuarios = {
                "aviso_canal_gratuito_enviado": "BOOLEAN DEFAULT FALSE",
                "ultimo_aviso_expiracao": "INTEGER",
                "usou_teste_gratuito": "BOOLEAN DEFAULT FALSE"
            }
            for nome, definicao in colunas_usuarios.items():
                if not coluna_existe('usuarios', nome):
                    cursor.execute(f"ALTER TABLE usuarios ADD COLUMN {nome} {definicao}")
                    logger.info(f"Migra√ß√£o: Coluna '{nome}' adicionada a 'usuarios'.")
            
            conn.commit()
            logger.info("Verifica√ß√£o de migra√ß√£o de colunas conclu√≠da.")
    except psycopg2.Error as e:
        logger.error(f"Erro durante a migra√ß√£o do banco de dados: {e}")
        conn.rollback()
    finally:
        conn.close()

# --- FUN√á√ïES DE GERENCIAMENTO DE USU√ÅRIOS E PLANOS ---

def adicionar_usuario(user_id: int, nome: str, nivel: int = 1):
    """Insere um novo usu√°rio no banco de dados se ele n√£o existir."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # ON CONFLICT √© uma forma mais robusta e eficiente de lidar com inser√ß√µes duplicadas no PostgreSQL
            cursor.execute("""
                INSERT INTO usuarios (telegram_id, nome, nivel) VALUES (%s, %s, %s)
                ON CONFLICT (telegram_id) DO NOTHING
            """, (user_id, nome, nivel))
            conn.commit()
    finally:
        conn.close()


def obter_nivel_usuario(user_id: int) -> int:
    """Obt√©m o n√≠vel de um usu√°rio. Retorna 1 (padr√£o) se n√£o encontrado."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT nivel FROM usuarios WHERE telegram_id = %s", (user_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else 1
    finally:
        conn.close()


def buscar_telegram_por_email(email: str) -> Optional[int]:
    """Busca o telegram_id de um usu√°rio pelo seu e-mail, ignorando mai√∫sculas/min√∫sculas."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT telegram_id FROM usuarios WHERE LOWER(email) = LOWER(%s)", (email.strip(),))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else None
    finally:
        conn.close()


def email_ja_utilizado_por_outro_usuario(email: str, telegram_id: int) -> bool:
    """Verifica se um e-mail j√° est√° em uso por outro usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT 1 FROM usuarios WHERE email = %s AND telegram_id != %s", (email, telegram_id))
            return cursor.fetchone() is not None
    finally:
        conn.close()


def revogar_usuario_por_email(email: str):
    """
    (Fun√ß√£o a ser revisada) Remove o plano de um usu√°rio por e-mail.
    A coluna original 'tipo_plano' foi removida; esta fun√ß√£o agora limpa 'plano_assinado'.
    """
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # A coluna 'tipo_plano' n√£o existe mais. Adaptado para 'plano_assinado'.
            cursor.execute("UPDATE usuarios SET plano_assinado = NULL WHERE email = %s", (email,))
            conn.commit()
    finally:
        conn.close()


def salvar_plano_usuario(user_id: int, plano: str):
    """Salva ou atualiza o plano assinado por um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET plano_assinado = %s WHERE telegram_id = %s", (plano, user_id))
            conn.commit()
    finally:
        conn.close()


def obter_plano_usuario(user_id: int) -> Optional[str]:
    """Obt√©m o plano assinado por um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT plano_assinado FROM usuarios WHERE telegram_id = %s", (user_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else None
    finally:
        conn.close()


def is_usuario_admin(telegram_id: int) -> bool:
    """Verifica se o telegram_id est√° na lista de administradores (n√£o acessa o DB)."""
    from configuracoes import ADMIN_TELEGRAM_IDS
    return telegram_id in ADMIN_TELEGRAM_IDS

# --- FUN√á√ïES DE COMPRAS E ASSINATURAS ---

def registrar_compra(telegram_id: Optional[int], email: str, plano: str, metodo_pagamento: str, status: str, sale_id: str, data_criacao: str, offer_id: str, nome_completo: Optional[str] = None, telefone: Optional[str] = None):
    """Registra uma nova compra no banco de dados."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                INSERT INTO compras (telegram_id, email, plano, metodo_pagamento, status, sale_id, data_criacao, offer_id, nome_completo, telefone)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (telegram_id, email, plano, metodo_pagamento, status, sale_id, data_criacao, offer_id, nome_completo, telefone))
            conn.commit()
    except psycopg2.Error as e:
        logger.error(f"Erro ao registrar compra para o e-mail {email}: {e}")
        conn.rollback()
    finally:
        conn.close()


def vincular_compra_e_ativar_usuario(telegram_id: int, email: str, plano: str, status: str):
    """Vincula uma compra aprovada e ativa o status do usu√°rio em uma √∫nica transa√ß√£o."""
    from datetime import datetime, timedelta
    from configuracoes import TESTE_GRATUITO_DURACAO_DIAS

    if plano == "Teste Gratuito" and usuario_ja_usou_teste(telegram_id):
        raise ValueError("Voc√™ j√° utilizou o per√≠odo de teste gratuito.")

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # 1. Vincula o telegram_id √† compra na tabela 'compras'
            cursor.execute(
                "UPDATE compras SET telegram_id = %s WHERE email = %s AND status = 'APPROVED' AND telegram_id IS NULL",
                (telegram_id, email)
            )

            # 2. Atualiza o e-mail do usu√°rio na tabela 'usuarios'
            cursor.execute("UPDATE usuarios SET email = %s WHERE telegram_id = %s", (email, telegram_id))

            # 3. Calcula a data de expira√ß√£o
            if "Anual" in plano:
                data_expiracao = datetime.now() + timedelta(days=365)
            elif plano == "Teste Gratuito":
                data_expiracao = datetime.now() + timedelta(days=TESTE_GRATUITO_DURACAO_DIAS)
            else:
                data_expiracao = datetime.now() + timedelta(days=31)

            # 4. Atualiza o status completo do usu√°rio
            cursor.execute("""
                UPDATE usuarios SET
                    status_pagamento = %s,
                    plano_assinado = %s,
                    nivel = 2,
                    data_expiracao = %s,
                    status_canal = 'ativo',
                    ultimo_aviso_expiracao = NULL
                WHERE telegram_id = %s
            """, (status, plano, data_expiracao, telegram_id))

            # 5. Marca o teste gratuito como usado, se for o caso
            if plano == "Teste Gratuito":
                cursor.execute("UPDATE usuarios SET usou_teste_gratuito = TRUE WHERE telegram_id = %s", (telegram_id,))

            conn.commit()
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao vincular compra e ativar usu√°rio {telegram_id}: {e}")
        conn.rollback()
        raise e  # Re-lan√ßa a exce√ß√£o para ser tratada pela camada superior
    finally:
        conn.close()


def compra_aprovada(email: str) -> bool:
    """Verifica se existe alguma compra aprovada para o e-mail."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT 1 FROM compras WHERE email = %s AND status = 'aprovado' LIMIT 1", (email,))
            return cursor.fetchone() is not None
    finally:
        conn.close()


def plano_comprado(email: str) -> Optional[str]:
    """Busca o √∫ltimo plano comprado pelo e-mail."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT plano FROM compras WHERE email = %s ORDER BY criado_em DESC LIMIT 1", (email,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else None
    finally:
        conn.close()


def atualizar_status_compra(email: str, novo_status: str):
    """Atualiza o status de uma compra pelo e-mail."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE compras SET status = %s WHERE email = %s", (novo_status, email))
            conn.commit()
    finally:
        conn.close()


def desativar_assinatura_por_email(email: str, novo_status: str = 'expirado') -> Optional[int]:
    """Desativa a assinatura de um usu√°rio e retorna seu telegram_id."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT telegram_id FROM usuarios WHERE LOWER(email) = LOWER(%s) AND nivel = 2", (email,))
            resultado = cursor.fetchone()
            
            if not resultado:
                return None

            telegram_id = resultado[0]
            
            cursor.execute(
                "UPDATE usuarios SET nivel = 4, status_pagamento = %s, status_canal = 'removido' WHERE telegram_id = %s",
                (novo_status, telegram_id)
            )
            
            conn.commit()
            return telegram_id
    finally:
        conn.close()


def atualizar_data_expiracao(email: str, nova_data: datetime):
    """Atualiza a data de expira√ß√£o e reativa o usu√°rio (n√≠vel 2)."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                UPDATE usuarios
                SET data_expiracao = %s, nivel = 2, status_canal = 'ativo', ultimo_aviso_expiracao = NULL
                WHERE LOWER(email) = LOWER(%s)
            """, (nova_data, email))
            conn.commit()
    finally:
        conn.close()

# --- FUN√á√ïES DE L√ìGICA DE ATIVA√á√ÉO E ASSINATURA ---

def vincular_compra_e_ativar_usuario(telegram_id: int, email: str, plano: str, status: str):
    """Vincula uma compra aprovada e ativa o status do usu√°rio em uma √∫nica transa√ß√£o."""
    from datetime import datetime, timedelta
    from configuracoes import TESTE_GRATUITO_DURACAO_DIAS

    if plano == "Teste Gratuito" and usuario_ja_usou_teste(telegram_id):
        raise ValueError("Voc√™ j√° utilizou o per√≠odo de teste gratuito.")

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # 1. Vincula o telegram_id √† compra (se ainda n√£o estiver vinculado)
            cursor.execute(
                "UPDATE compras SET telegram_id = %s WHERE LOWER(email) = LOWER(%s) AND status = 'APPROVED' AND telegram_id IS NULL",
                (telegram_id, email)
            )

            # 2. Atualiza o e-mail do usu√°rio
            cursor.execute("UPDATE usuarios SET email = %s WHERE telegram_id = %s", (email, telegram_id))

            # 3. Calcula a data de expira√ß√£o
            if "Anual" in plano:
                data_expiracao = datetime.now() + timedelta(days=365)
            elif plano == "Teste Gratuito":
                data_expiracao = datetime.now() + timedelta(days=TESTE_GRATUITO_DURACAO_DIAS)
            else:  # Planos mensais
                data_expiracao = datetime.now() + timedelta(days=31)

            # 4. Atualiza o status completo do usu√°rio
            cursor.execute("""
                UPDATE usuarios SET
                    status_pagamento = %s,
                    plano_assinado = %s,
                    nivel = 2,
                    data_expiracao = %s,
                    status_canal = 'ativo',
                    ultimo_aviso_expiracao = NULL
                WHERE telegram_id = %s
            """, (status, plano, data_expiracao, telegram_id))

            # 5. Marca o teste gratuito como usado
            if plano == "Teste Gratuito":
                cursor.execute("UPDATE usuarios SET usou_teste_gratuito = TRUE WHERE telegram_id = %s", (telegram_id,))

            conn.commit()
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro na transa√ß√£o de ativa√ß√£o do usu√°rio {telegram_id}: {e}")
        if conn:
            conn.rollback()
        raise e  # Re-lan√ßa a exce√ß√£o para ser tratada pela camada que a chamou
    finally:
        if conn:
            conn.close()


def desativar_assinatura_por_email(email: str, novo_status: str = 'expirado') -> Optional[int]:
    """Desativa a assinatura de um usu√°rio (n√≠vel 4) e retorna seu telegram_id."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # Busca o telegram_id do usu√°rio ativo
            cursor.execute("SELECT telegram_id FROM usuarios WHERE LOWER(email) = LOWER(%s) AND nivel = 2", (email,))
            resultado = cursor.fetchone()
            
            if not resultado:
                return None

            telegram_id = resultado[0]
            
            # Atualiza o status do usu√°rio para desativado
            cursor.execute(
                "UPDATE usuarios SET nivel = 4, status_pagamento = %s, status_canal = 'removido' WHERE telegram_id = %s",
                (novo_status, telegram_id)
            )
            
            conn.commit()
            return telegram_id
    finally:
        conn.close()


def atualizar_data_expiracao(email: str, nova_data: datetime):
    """Atualiza a data de expira√ß√£o e reativa um usu√°rio (n√≠vel 2)."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                UPDATE usuarios
                SET data_expiracao = %s, nivel = 2, status_canal = 'ativo', ultimo_aviso_expiracao = NULL
                WHERE LOWER(email) = LOWER(%s)
            """, (nova_data, email))
            conn.commit()
    finally:
        conn.close()

# --- FUN√á√ïES DE GERENCIAMENTO DE CONFIGURA√á√ÉO DO CANAL ---

def salvar_configuracao_canal_completa(telegram_id: int, twitch_client_id: str, twitch_client_secret: str, streamers: list, modo: str, clipador_chefe: Optional[str] = None, modo_parceiro: str = 'somente_bot'):
    """Salva a configura√ß√£o completa de um canal, atualizando ou inserindo um novo registro."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            streamers_str = ",".join(streamers)
            plano = obter_plano_usuario(telegram_id)
            slots_iniciais = obter_slots_base_plano(plano)

            # Verifica se j√° existe uma configura√ß√£o para este usu√°rio
            cursor.execute("SELECT id FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            existe = cursor.fetchone()

            if existe:
                # Atualiza a configura√ß√£o existente
                cursor.execute("""
                    UPDATE configuracoes_canal
                    SET twitch_client_id = %s, twitch_client_secret = %s, streamers_monitorados = %s, 
                        modo_monitoramento = %s, slots_ativos = %s, streamers_ultima_modificacao = CURRENT_TIMESTAMP, 
                        clipador_chefe_username = %s, modo_parceiro = %s
                    WHERE telegram_id = %s
                """, (twitch_client_id, twitch_client_secret, streamers_str, modo, slots_iniciais, clipador_chefe, modo_parceiro, telegram_id))
            else:
                # Insere uma nova configura√ß√£o
                cursor.execute("""
                    INSERT INTO configuracoes_canal (
                        telegram_id, twitch_client_id, twitch_client_secret, streamers_monitorados, 
                        modo_monitoramento, slots_ativos, streamers_ultima_modificacao, 
                        clipador_chefe_username, modo_parceiro
                    ) VALUES (%s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP, %s, %s)
                """, (telegram_id, twitch_client_id, twitch_client_secret, streamers_str, modo, slots_iniciais, clipador_chefe, modo_parceiro))
            
            conn.commit()
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao salvar configura√ß√£o completa para {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


def buscar_configuracao_canal(telegram_id: int) -> Optional[Dict[str, Any]]:
    """Busca a configura√ß√£o de canal de um usu√°rio e retorna como um dicion√°rio."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("SELECT * FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return dict(resultado) if resultado else None
    finally:
        conn.close()


def buscar_link_canal(telegram_id: int) -> Optional[str]:
    """Busca o link do canal do Telegram de um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT link_canal_telegram FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else None
    finally:
        conn.close()


def salvar_link_canal(telegram_id: int, id_canal: str, link_canal: str):
    """Salva o ID e o link do canal do Telegram na configura√ß√£o do usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute(
                "UPDATE configuracoes_canal SET id_canal_telegram = %s, link_canal_telegram = %s WHERE telegram_id = %s",
                (id_canal, link_canal, telegram_id)
            )
            conn.commit()
    finally:
        conn.close()


def deletar_configuracao_canal(telegram_id: int):
    """Remove a linha de configura√ß√£o de um usu√°rio da tabela configuracoes_canal."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("DELETE FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            conn.commit()
    finally:
        conn.close()


def obter_slots_base_plano(plano: Optional[str]) -> int:
    """Retorna a quantidade base de slots para um determinado plano (n√£o interage com o DB)."""
    if plano == "Mensal Solo": return 1
    if plano == "Mensal Plus": return 3
    if plano == "Anual Pro": return 4  # 3 do plano + 1 de b√¥nus
    if plano == "PARCEIRO": return 1
    if plano == "Teste Gratuito": return 1
    if plano == "SUPER": return 999
    return 1  # Padr√£o para planos n√£o reconhecidos ou nulos


def adicionar_slot_extra(telegram_id: int, quantidade: int = 1):
    """Adiciona um ou mais slots extras para o usu√°rio, incrementando o contador."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute(
                "UPDATE configuracoes_canal SET slots_ativos = slots_ativos + %s WHERE telegram_id = %s",
                (quantidade, telegram_id)
            )
            conn.commit()
        logger.info(f"{quantidade} slot(s) extra(s) adicionado(s) para o usu√°rio {telegram_id}.")
    finally:
        conn.close()


def remover_slots_extras(telegram_id: int):
    """Reseta os slots de um usu√°rio para o valor base do seu plano."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            plano = obter_plano_usuario(telegram_id)
            slots_base = obter_slots_base_plano(plano)

            cursor.execute("UPDATE configuracoes_canal SET slots_ativos = %s WHERE telegram_id = %s", (slots_base, telegram_id))
            
            if cursor.rowcount == 0:
                raise ValueError(f"Usu√°rio {telegram_id} n√£o possui um canal configurado para remover slots.")

            conn.commit()
            logger.info(f"Slots extras removidos para o usu√°rio {telegram_id}. Slots resetados para {slots_base}.")
    finally:
        conn.close()


def atualizar_configuracao_manual(telegram_id: int, min_clips: int = None, interval_sec: int = None, min_clips_vod: int = None):
    """Atualiza os par√¢metros de configura√ß√£o manual de um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            updates = []
            params = []

            if min_clips is not None:
                updates.append("manual_min_clips = %s")
                params.append(min_clips)
            if interval_sec is not None:
                updates.append("manual_interval_sec = %s")
                params.append(interval_sec)
            if min_clips_vod is not None:
                updates.append("manual_min_clips_vod = %s")
                params.append(min_clips_vod)

            if not updates:
                return

            params.append(telegram_id)
            query = f"UPDATE configuracoes_canal SET {', '.join(updates)} WHERE telegram_id = %s"
            
            cursor.execute(query, tuple(params))
            conn.commit()
            logger.info(f"Configura√ß√£o manual atualizada para o usu√°rio {telegram_id}.")
    finally:
        conn.close()


def atualizar_modo_monitoramento(telegram_id: int, novo_modo: str):
    """Atualiza apenas o modo de monitoramento de um canal."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE configuracoes_canal SET modo_monitoramento = %s WHERE telegram_id = %s", (novo_modo, telegram_id))
            conn.commit()
    finally:
        conn.close()


def atualizar_streamers_monitorados(telegram_id: int, nova_lista_streamers: list[str]):
    """Atualiza a lista de streamers monitorados."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            streamers_str = ",".join(nova_lista_streamers)
            cursor.execute(
                "UPDATE configuracoes_canal SET streamers_monitorados = %s WHERE telegram_id = %s",
                (streamers_str, telegram_id)
            )
            conn.commit()
    finally:
        conn.close()


def resetar_cooldown_streamers(telegram_id: int):
    """Reseta o cooldown para altera√ß√£o de streamers, permitindo modifica√ß√µes."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE configuracoes_canal SET streamers_ultima_modificacao = NULL WHERE telegram_id = %s", (telegram_id,))
            
            if cursor.rowcount == 0:
                raise ValueError(f"Usu√°rio {telegram_id} n√£o possui um canal configurado.")

            conn.commit()
            logger.info(f"Cooldown de altera√ß√£o de streamers resetado para o usu√°rio {telegram_id}.")
    finally:
        conn.close()

# --- FUN√á√ïES DE PROGRESSO DE CONFIGURA√á√ÉO E ESTADO ---

def marcar_configuracao_completa(telegram_id: int, status: bool):
    """Marca o status de configura√ß√£o finalizada para um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET configuracao_finalizada = %s WHERE telegram_id = %s", (status, telegram_id))
            conn.commit()
    finally:
        conn.close()


def is_configuracao_completa(telegram_id: int) -> bool:
    """Verifica se a configura√ß√£o do usu√°rio est√° marcada como completa."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT configuracao_finalizada FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else False
    finally:
        conn.close()


def assinatura_em_configuracao(telegram_id: int) -> bool:
    """Verifica se um assinante ativo ainda tem campos de configura√ß√£o pendentes."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("""
                SELECT u.nivel, c.twitch_client_id, c.streamers_monitorados, c.modo_monitoramento
                FROM usuarios u
                LEFT JOIN configuracoes_canal c ON u.telegram_id = c.telegram_id
                WHERE u.telegram_id = %s AND u.nivel = 2
            """, (telegram_id,))
            resultado = cursor.fetchone()

            if not resultado:
                return False

            campos_pendentes = not resultado['twitch_client_id'] or not resultado['streamers_monitorados'] or not resultado['modo_monitoramento']
            return campos_pendentes
    finally:
        conn.close()


def salvar_progresso_configuracao(telegram_id: int, etapa: str, dados_parciais: dict = None):
    """Salva dados parciais da configura√ß√£o do canal, atualizando ou inserindo conforme necess√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            existing_config = buscar_configuracao_canal(telegram_id)
            dados_parciais = dados_parciais or {}

            if existing_config:
                # Monta a query de UPDATE
                update_fields = []
                update_values = []
                if "twitch_client_id" in dados_parciais:
                    update_fields.append("twitch_client_id = %s")
                    update_values.append(dados_parciais["twitch_client_id"])
                if "twitch_client_secret" in dados_parciais:
                    update_fields.append("twitch_client_secret = %s")
                    update_values.append(dados_parciais["twitch_client_secret"])
                if "streamers" in dados_parciais:
                    streamers_str = ",".join(dados_parciais["streamers"])
                    update_fields.append("streamers_monitorados = %s")
                    update_values.append(streamers_str)
                    if etapa == "streamers":
                        update_fields.append("streamers_ultima_modificacao = CURRENT_TIMESTAMP")
                if "modo" in dados_parciais:
                    update_fields.append("modo_monitoramento = %s")
                    update_values.append(dados_parciais["modo"])

                if update_fields:
                    query = f"UPDATE configuracoes_canal SET {', '.join(update_fields)} WHERE telegram_id = %s"
                    update_values.append(telegram_id)
                    cursor.execute(query, tuple(update_values))
            else:
                # Monta a query de INSERT
                fields = ["telegram_id"]
                values_placeholders = ["%s"]
                values = [telegram_id]

                if "twitch_client_id" in dados_parciais:
                    fields.append("twitch_client_id")
                    values_placeholders.append("%s")
                    values.append(dados_parciais["twitch_client_id"])
                if "twitch_client_secret" in dados_parciais:
                    fields.append("twitch_client_secret")
                    values_placeholders.append("%s")
                    values.append(dados_parciais["twitch_client_secret"])
                if "streamers" in dados_parciais:
                    fields.append("streamers_monitorados")
                    values_placeholders.append("%s")
                    values.append(",".join(dados_parciais["streamers"]))
                    fields.append("streamers_ultima_modificacao")
                    values_placeholders.append("CURRENT_TIMESTAMP") # Adicionado diretamente na query
                if "modo" in dados_parciais:
                    fields.append("modo_monitoramento")
                    values_placeholders.append("%s")
                    values.append(dados_parciais["modo"])
                
                query = f"INSERT INTO configuracoes_canal ({', '.join(fields)}) VALUES ({', '.join(values_placeholders)})"
                cursor.execute(query, tuple(values))

            conn.commit()
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao salvar progresso de configura√ß√£o para {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


def buscar_progresso_configuracao(telegram_id: int) -> Optional[Dict[str, Any]]:
    """Busca o progresso da configura√ß√£o de um canal."""
    config = buscar_configuracao_canal(telegram_id)
    if not config:
        return None

    progresso = {}
    if config.get("modo_monitoramento"):
        progresso["modo_monitoramento"] = config["modo_monitoramento"]
    if config.get("streamers_monitorados"):
        progresso["streamers_monitorados"] = config["streamers_monitorados"]
    return progresso if progresso else None


def limpar_progresso_configuracao(telegram_id: int):
    """Limpa os dados de configura√ß√£o de um canal, mantendo o registro."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                UPDATE configuracoes_canal
                SET twitch_client_id = NULL, twitch_client_secret = NULL, 
                    streamers_monitorados = NULL, modo_monitoramento = NULL
                WHERE telegram_id = %s
            """, (telegram_id,))
            conn.commit()
    finally:
        conn.close()

# --- FUN√á√ïES DE TESTE E ADMIN (CRUD DE USU√ÅRIO) ---

async def revogar_acesso_teste_expirado(telegram_id: int):
    """
    Revoga o acesso de um usu√°rio de teste expirado, deletando o canal do Telegram,
    a configura√ß√£o do canal no DB e atualizando o status do usu√°rio.
    """
    from core.telethon_criar_canal import deletar_canal_telegram
    logger.info(f"Iniciando revoga√ß√£o de acesso de teste para o usu√°rio {telegram_id}.")
    
    config = buscar_configuracao_canal(telegram_id)
    if config and config.get('id_canal_telegram'):
        try:
            id_canal = int(config['id_canal_telegram'])
            await deletar_canal_telegram(id_canal)
            logger.info(f"Canal do Telegram {id_canal} (teste expirado) para o usu√°rio {telegram_id} deletado.")
        except Exception as e:
            logger.error(f"Erro ao deletar canal de teste expirado {config.get('id_canal_telegram')} para {telegram_id}: {e}", exc_info=True)

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("DELETE FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("""
                UPDATE usuarios SET 
                    plano_assinado = NULL, 
                    nivel = 4, 
                    status_pagamento = 'trial_expired',
                    configuracao_finalizada = FALSE, 
                    data_expiracao = NULL, 
                    status_canal = 'removido' 
                WHERE telegram_id = %s
            """, (telegram_id,))
            conn.commit()
            logger.info(f"Configura√ß√£o e status do usu√°rio de teste {telegram_id} resetados no banco de dados.")
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro de DB ao revogar acesso de teste para {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


async def resetar_estado_usuario_para_teste(telegram_id: int):
    """
    APAGA COMPLETAMENTE um usu√°rio e todos os seus dados associados,
    incluindo o canal do Telegram, para fins de teste.
    """
    from core.telethon_criar_canal import deletar_canal_telegram
    config = buscar_configuracao_canal(telegram_id)
    if config and config.get('id_canal_telegram'):
        try:
            await deletar_canal_telegram(int(config['id_canal_telegram']))
            logger.info(f"Canal do Telegram para o usu√°rio {telegram_id} deletado.")
        except Exception as e:
            logger.error(f"Erro ao deletar canal do Telegram para {telegram_id}: {e}", exc_info=True)

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # A ordem de exclus√£o √© importante para respeitar as chaves estrangeiras
            cursor.execute("DELETE FROM historico_envios WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM compras WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM status_streamers WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM notificacoes_config WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            conn.commit()
            logger.info(f"Todos os dados do usu√°rio {telegram_id} foram removidos do banco de dados.")
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao deletar dados do usu√°rio {telegram_id} do banco de dados: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


def conceder_plano_usuario(telegram_id: int, plano: str, dias: int):
    """Concede um plano a um usu√°rio, ativando-o e definindo a data de expira√ß√£o."""
    from datetime import datetime, timedelta
    
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            plano_antigo = obter_plano_usuario(telegram_id)
            data_expiracao = datetime.now() + timedelta(days=dias)

            cursor.execute("""
                UPDATE usuarios SET
                    plano_assinado = %s, nivel = 2, data_expiracao = %s, ultimo_aviso_expiracao = NULL,
                    status_pagamento = 'approved_admin', status_canal = 'ativo'
                WHERE telegram_id = %s
            """, (plano, data_expiracao, telegram_id))

            slots_base_novo = obter_slots_base_plano(plano)
            config = buscar_configuracao_canal(telegram_id)
            
            if config:
                slots_atuais = config.get('slots_ativos', 1)
                slots_base_antigo = obter_slots_base_plano(plano_antigo)
                slots_extras_comprados = max(0, slots_atuais - slots_base_antigo)
                novos_slots_totais = slots_base_novo + slots_extras_comprados
                cursor.execute(
                    "UPDATE configuracoes_canal SET slots_ativos = %s WHERE telegram_id = %s",
                    (novos_slots_totais, telegram_id)
                )

            conn.commit()
            logger.info(f"Plano '{plano}' concedido ao usu√°rio {telegram_id} por {dias} dias via admin.")
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao conceder plano para {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()

# --- FUN√á√ïES DE GERENCIAMENTO DE STATUS (AVISOS, TESTES, STREAMERS) ---

def marcar_aviso_enviado(telegram_id: int):
    """Marca que o aviso do canal gratuito foi enviado para o usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET aviso_canal_gratuito_enviado = TRUE WHERE telegram_id = %s", (telegram_id,))
            conn.commit()
    finally:
        conn.close()


def verificar_aviso_enviado(telegram_id: int) -> bool:
    """Verifica se o aviso do canal gratuito j√° foi enviado para o usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT aviso_canal_gratuito_enviado FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else False
    finally:
        conn.close()


def usuario_ja_usou_teste(telegram_id: int) -> bool:
    """Verifica se um usu√°rio j√° ativou o teste gratuito."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT usou_teste_gratuito FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else False
    finally:
        conn.close()


def resetar_flag_teste_gratuito(telegram_id: int):
    """Reseta a flag 'usou_teste_gratuito' para FALSE."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET usou_teste_gratuito = FALSE WHERE telegram_id = %s", (telegram_id,))
            conn.commit()
            
            if cursor.rowcount == 0:
                raise ValueError(f"Usu√°rio com ID {telegram_id} n√£o encontrado.")
    finally:
        conn.close()
    logger.info(f"Flag de teste gratuito resetada para o usu√°rio {telegram_id}.")


def obter_status_streamer(telegram_id: int, streamer_id: str) -> Optional[str]:
    """Obt√©m o √∫ltimo status conhecido de um streamer ('online' ou 'offline')."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT status FROM status_streamers WHERE telegram_id = %s AND streamer_id = %s", (telegram_id, streamer_id))
            resultado = cursor.fetchone()
            return resultado[0] if resultado else None
    finally:
        conn.close()


def atualizar_status_streamer(telegram_id: int, streamer_id: str, novo_status: str):
    """Atualiza ou insere o status de um streamer usando ON CONFLICT para efici√™ncia."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                INSERT INTO status_streamers (telegram_id, streamer_id, status, ultima_verificacao)
                VALUES (%s, %s, %s, CURRENT_TIMESTAMP)
                ON CONFLICT (telegram_id, streamer_id) DO UPDATE SET
                    status = EXCLUDED.status,
                    ultima_verificacao = CURRENT_TIMESTAMP
            """, (telegram_id, streamer_id, novo_status))
            conn.commit()
    finally:
        conn.close()

# --- FUN√á√ïES DE HIST√ìRICO DE ENVIOS ---

def registrar_grupo_enviado(telegram_id: int, streamer_id: str, grupo_inicio: datetime, grupo_fim: datetime):
    """Registra que um grupo de clipes foi enviado para um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                INSERT INTO historico_envios (telegram_id, streamer_id, grupo_inicio, grupo_fim)
                VALUES (%s, %s, %s, %s)
            """, (telegram_id, streamer_id, grupo_inicio, grupo_fim))
            conn.commit()
    finally:
        conn.close()


def verificar_grupo_ja_enviado(telegram_id: int, streamer_id: str, grupo_inicio: datetime, grupo_fim: datetime) -> bool:
    """Verifica se um grupo de clipes com sobreposi√ß√£o de tempo j√° foi enviado."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # A l√≥gica de sobreposi√ß√£o (StartA <= EndB) and (EndA >= StartB) √© mantida.
            cursor.execute("""
                SELECT 1 FROM historico_envios
                WHERE telegram_id = %s AND streamer_id = %s AND grupo_inicio <= %s AND grupo_fim >= %s
                LIMIT 1
            """, (telegram_id, streamer_id, grupo_fim, grupo_inicio))
            return cursor.fetchone() is not None
    finally:
        conn.close()


def registrar_clipe_chefe_enviado(telegram_id: int, clipe_id: str):
    """Registra que um clipe individual do chefe foi enviado."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("""
                INSERT INTO historico_envios (telegram_id, clipe_id, streamer_id, grupo_inicio, grupo_fim)
                VALUES (%s, %s, 'clipador_chefe', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            """, (telegram_id, clipe_id))
            conn.commit()
    finally:
        conn.close()


def verificar_clipe_chefe_ja_enviado(telegram_id: int, clipe_id: str) -> bool:
    """Verifica se um clipe espec√≠fico do chefe j√° foi enviado."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT 1 FROM historico_envios WHERE telegram_id = %s AND clipe_id = %s LIMIT 1", (telegram_id, clipe_id))
            return cursor.fetchone() is not None
    finally:
        conn.close()

# --- FUN√á√ïES DE NOTIFICA√á√ïES E ESTAT√çSTICAS ---

def obter_ou_criar_config_notificacao(telegram_id: int) -> Dict[str, Any]:
    """
    Busca a configura√ß√£o de notifica√ß√£o de um usu√°rio.
    Se n√£o existir, cria uma com valores padr√£o e a retorna.
    """
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            # Tenta inserir com os valores padr√£o, se o telegram_id j√° existir, n√£o faz nada.
            cursor.execute("""
                INSERT INTO notificacoes_config (telegram_id, notificar_online)
                VALUES (%s, TRUE)
                ON CONFLICT (telegram_id) DO NOTHING
            """, (telegram_id,))
            
            # Busca a configura√ß√£o (que agora garantidamente existe)
            cursor.execute("SELECT * FROM notificacoes_config WHERE telegram_id = %s", (telegram_id,))
            config = cursor.fetchone()
            conn.commit()
            return dict(config)
    finally:
        conn.close()


def atualizar_config_notificacao(telegram_id: int, notificar_online: bool = None):
    """Atualiza as configura√ß√µes de notifica√ß√£o de um usu√°rio."""
    if notificar_online is None:
        return

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # Garante que a configura√ß√£o exista antes de atualizar
            obter_ou_criar_config_notificacao(telegram_id)
            
            cursor.execute(
                "UPDATE notificacoes_config SET notificar_online = %s WHERE telegram_id = %s",
                (notificar_online, telegram_id)
            )
            conn.commit()
            logger.info(f"Configura√ß√£o de notifica√ß√£o atualizada para o usu√°rio {telegram_id}.")
    finally:
        conn.close()


def obter_estatisticas_gerais() -> Dict[str, int]:
    """Busca estat√≠sticas gerais do bot."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT COUNT(*) FROM usuarios")
            total_usuarios = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE nivel = 2")
            assinantes_ativos = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM configuracoes_canal WHERE id_canal_telegram IS NOT NULL")
            canais_monitorados = cursor.fetchone()[0]

            return {
                "total_usuarios": total_usuarios,
                "assinantes_ativos": assinantes_ativos,
                "canais_monitorados": canais_monitorados
            }
    finally:
        conn.close()


def buscar_usuarios_para_notificar_expiracao() -> List[Dict[str, Any]]:
    """
    Busca usu√°rios cujas assinaturas est√£o pr√≥ximas de expirar e que precisam ser notificados.
    """
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            # A l√≥gica √© convertida para usar as fun√ß√µes de data e hora do PostgreSQL.
            # (data_expiracao - NOW()) resulta em um intervalo, que pode ser convertido para dias.
            cursor.execute("""
                SELECT 
                    telegram_id, 
                    EXTRACT(DAY FROM (data_expiracao - NOW())) AS dias_restantes
                FROM usuarios
                WHERE 
                    nivel = 2 AND data_expiracao IS NOT NULL
                    AND (
                        (EXTRACT(DAY FROM (data_expiracao - NOW())) <= 7 AND (ultimo_aviso_expiracao IS NULL OR ultimo_aviso_expiracao > 7)) OR
                        (EXTRACT(DAY FROM (data_expiracao - NOW())) <= 3 AND (ultimo_aviso_expiracao IS NULL OR ultimo_aviso_expiracao > 3)) OR
                        (EXTRACT(DAY FROM (data_expiracao - NOW())) <= 1 AND (ultimo_aviso_expiracao IS NULL OR ultimo_aviso_expiracao > 1)) OR
                        (EXTRACT(DAY FROM (data_expiracao - NOW())) <= 0 AND (ultimo_aviso_expiracao IS NULL OR ultimo_aviso_expiracao > 0))
                    )
            """)
            return [dict(row) for row in cursor.fetchall()]
    finally:
        conn.close()


def atualizar_ultimo_aviso_expiracao(telegram_id: int, dias_aviso: int):
    """Atualiza o campo ultimo_aviso_expiracao para um usu√°rio."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET ultimo_aviso_expiracao = %s WHERE telegram_id = %s", (dias_aviso, telegram_id))
            conn.commit()
            logger.info(f"Aviso de expira√ß√£o de {dias_aviso} dias atualizado para o usu√°rio {telegram_id}.")
    finally:
        conn.close()

# --- FUN√á√ïES UTILIT√ÅRIAS E DE BUSCA ---

def buscar_usuarios_ativos_configurados() -> List[Dict[str, Any]]:
    """
    Busca todos os usu√°rios que s√£o assinantes ativos (n√≠vel 2) e que
    finalizaram a configura√ß√£o do canal. Retorna uma lista de dicion√°rios.
    """
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("""
                SELECT c.* FROM configuracoes_canal c
                JOIN usuarios u ON c.telegram_id = u.telegram_id
                WHERE u.nivel = 2 AND u.configuracao_finalizada = TRUE
            """)
            return [dict(row) for row in cursor.fetchall()]
    finally:
        conn.close()

def buscar_usuario_por_id(telegram_id: int) -> Optional[Dict[str, Any]]:
    """Busca os dados de um usu√°rio pelo seu telegram_id e retorna como dicion√°rio."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("SELECT * FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            return dict(resultado) if resultado else None
    finally:
        conn.close()


def buscar_usuario_por_email(email: str) -> Optional[Dict[str, Any]]:
    """Busca os dados de um usu√°rio pelo seu email e retorna como dicion√°rio."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("SELECT * FROM usuarios WHERE LOWER(email) = LOWER(%s)", (email.strip(),))
            resultado = cursor.fetchone()
            return dict(resultado) if resultado else None
    finally:
        conn.close()


def buscar_ids_assinantes_ativos() -> List[int]:
    """Busca os IDs de todos os usu√°rios que s√£o assinantes ativos (n√≠vel 2)."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT telegram_id FROM usuarios WHERE nivel = 2")
            return [row[0] for row in cursor.fetchall()]
    finally:
        conn.close()

def buscar_pagamento_por_email(email: str) -> Optional[Dict[str, Any]]:
    """Busca o pagamento mais recente por email na tabela compras."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute(
                "SELECT * FROM compras WHERE LOWER(email) = LOWER(%s) ORDER BY criado_em DESC LIMIT 1",
                (email.strip(),)
            )
            resultado = cursor.fetchone()
            return dict(resultado) if resultado else None
    finally:
        conn.close()


def buscar_compra_aprovada_por_email(email: str) -> Optional[Dict[str, Any]]:
    """Busca a compra aprovada mais recente por email na tabela compras."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("""
                SELECT * FROM compras
                WHERE LOWER(email) = LOWER(%s) AND status = 'aprovado'
                ORDER BY criado_em DESC
                LIMIT 1
            """, (email.strip(),))
            resultado = cursor.fetchone()
            return dict(resultado) if resultado else None
    finally:
        conn.close()

def buscar_compras_aprovadas_nao_vinculadas(email: str) -> List[Dict[str, Any]]:
    """Busca todas as compras aprovadas de um e-mail que ainda n√£o foram vinculadas a um telegram_id."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("""
                SELECT * FROM compras
                WHERE LOWER(email) = LOWER(%s) AND status = 'aprovado' AND telegram_id IS NULL
                ORDER BY criado_em DESC
            """, (email.strip(),))
            return [dict(row) for row in cursor.fetchall()]
    finally:
        conn.close()

# --- FUN√á√ïES QUE N√ÉO INTERAGEM COM O BANCO DE DADOS ---

def registrar_log_pagamento(telegram_id, email, plano, status):
    """Registra um log de pagamento em um arquivo de texto."""
    dados = f"[{datetime.now()}] ID: {telegram_id}, Email: {email}, Plano: {plano}, Status: {status}\n"
    try:
        os.makedirs("memoria", exist_ok=True)
        with open("memoria/log_pagamentos.txt", "a", encoding="utf-8") as f:
            f.write(dados)
    except IOError as e:
        logger.error(f"Erro ao escrever no log de pagamentos: {e}")

def registrar_evento_webhook(dados: dict):
    """Registra o corpo de um evento de webhook em um arquivo de texto."""
    log_data = f"[{datetime.now()}] {dados}\n"
    try:
        os.makedirs("memoria", exist_ok=True)
        with open("memoria/log_eventos_webhook.txt", "a", encoding="utf-8") as f:
            f.write(log_data)
    except IOError as e:
        logger.error(f"Erro ao escrever no log de webhooks: {e}")

# --- FUN√á√ïES ADICIONAIS DE GERENCIAMENTO DE USU√ÅRIOS ---

def atualizar_dados_usuario(telegram_id: int, nome: Optional[str] = None, nivel: Optional[int] = None):
    """Atualiza o nome e/ou o n√≠vel de um usu√°rio espec√≠fico."""
    if nome is None and nivel is None:
        return # Nada a fazer

    conn = conectar()
    try:
        with conn.cursor() as cursor:
            updates = []
            params = []

            if nome is not None:
                updates.append("nome = %s")
                params.append(nome)
            
            if nivel is not None:
                updates.append("nivel = %s")
                params.append(nivel)
            
            params.append(telegram_id)
            query = f"UPDATE usuarios SET {', '.join(updates)} WHERE telegram_id = %s"
            
            cursor.execute(query, tuple(params))
            conn.commit()
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro ao atualizar dados para o usu√°rio {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


def remover_usuario_por_id(telegram_id: int):
    """
    Remove um usu√°rio e todos os seus dados associados (compras, configura√ß√µes, etc.)
    em uma √∫nica transa√ß√£o.
    """
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            # A ordem de exclus√£o √© importante para respeitar as chaves estrangeiras
            logger.warning(f"Iniciando remo√ß√£o completa do usu√°rio {telegram_id}.")
            cursor.execute("DELETE FROM historico_envios WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM compras WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM status_streamers WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM configuracoes_canal WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM notificacoes_config WHERE telegram_id = %s", (telegram_id,))
            cursor.execute("DELETE FROM usuarios WHERE telegram_id = %s", (telegram_id,)) # Por √∫ltimo
            conn.commit()
            logger.info(f"Usu√°rio {telegram_id} removido com sucesso de todas as tabelas.")
    except (Exception, psycopg2.Error) as e:
        logger.error(f"Erro na transa√ß√£o de remo√ß√£o do usu√°rio {telegram_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()


def listar_todos_usuarios() -> List[Dict[str, Any]]:
    """Lista todos os usu√°rios e seus principais dados para fins de administra√ß√£o."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("SELECT id, telegram_id, nome, email, nivel, plano_assinado FROM usuarios ORDER BY id")
            return [dict(row) for row in cursor.fetchall()]
    finally:
        conn.close()

# --- FUN√á√ïES DE COMPATIBILIDADE RESTAURADAS ---

def atualizar_telegram_id_simples(telegram_id_antigo: int, telegram_id_novo: int):
    """Atualiza o telegram_id usando o valor antigo como refer√™ncia."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("UPDATE usuarios SET telegram_id = %s WHERE telegram_id = %s", (telegram_id_novo, telegram_id_antigo))
            conn.commit()
    finally:
        conn.close()

def sale_id_ja_registrado(sale_id: str) -> bool:
    """Fun√ß√£o para verificar se sale_id j√° foi registrado."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT 1 FROM compras WHERE sale_id = %s LIMIT 1", (sale_id,))
            return cursor.fetchone() is not None
    finally:
        conn.close()

# Alias para manter a compatibilidade com o c√≥digo antigo que usa este nome
compra_ja_registrada = sale_id_ja_registrado     

def vincular_email_usuario(telegram_id: int, email: str) -> bool:
    """Vincula um e-mail a um usu√°rio, garantindo que o e-mail n√£o esteja em uso por outro."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT 1 FROM usuarios WHERE email = %s AND telegram_id != %s", (email, telegram_id))
            if cursor.fetchone():
                return False  # E-mail j√° est√° em uso

            cursor.execute("UPDATE usuarios SET email = %s WHERE telegram_id = %s", (email, telegram_id))
            conn.commit()
            return True
    finally:
        conn.close()


def verificar_configuracao_canal(telegram_id: int) -> bool:
    """Verifica se o canal do usu√°rio est√° configurado e com assinatura ativa."""
    conn = conectar()
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT plano_assinado, status_pagamento FROM usuarios WHERE telegram_id = %s", (telegram_id,))
            resultado = cursor.fetchone()
            if not resultado:
                return False
            plano, status = resultado
            # A l√≥gica original era 'aprovado', mas o status pode ser 'approved_admin', etc.
            # O mais seguro √© verificar se o plano n√£o √© nulo e o status n√£o √© 'pendente' ou 'expirado'.
            return bool(plano and status not in ['pendente', 'expirado', 'trial_expired'])
    finally:
        conn.close()


def buscar_compras_aprovadas_nao_vinculadas(email: str) -> list:
    """Busca todas as compras aprovadas de um e-mail que ainda n√£o foram vinculadas a um telegram_id."""
    conn = conectar()
    try:
        with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
            cursor.execute("""
                SELECT * FROM compras
                WHERE LOWER(email) = LOWER(%s) AND status = 'aprovado' AND telegram_id IS NULL
                ORDER BY criado_em DESC
            """, (email.strip(),))
            # Converte para uma lista de dicion√°rios padr√£o para compatibilidade
            return [dict(row) for row in cursor.fetchall()]
    finally:
        conn.close()

# --- FUN√á√ÉO DE INICIALIZA√á√ÉO ---

def inicializar_banco():
    """
    Fun√ß√£o central para ser chamada na inicializa√ß√£o do sistema.
    Cria as tabelas se n√£o existirem e aplica migra√ß√µes de colunas.
    """
    logger.info("üîß Inicializando e verificando a estrutura do banco de dados PostgreSQL...")
    criar_tabelas()
    migrar_tabelas()
    logger.info("‚úÖ Banco de dados pronto para uso.")

# IMPORTANTE: Remova as chamadas diretas como criar_tabelas() e migrar_tabelas()
# do final do arquivo. A √∫nica fun√ß√£o que deve ser chamada externamente √© 'inicializar_banco()',
# preferencialmente no arquivo principal de inicializa√ß√£o do seu bot.
---
üìÑ core/monitor_clientes.py
---
import asyncio
import time
from typing import TYPE_CHECKING
from datetime import datetime, timezone, timedelta
import logging 
import httpx
from telegram import error as telegram_error

from core.database import (
    buscar_usuarios_ativos_configurados,
    registrar_grupo_enviado,
    verificar_grupo_ja_enviado,
    registrar_clipe_chefe_enviado,
    verificar_clipe_chefe_ja_enviado,
    obter_status_streamer,
    atualizar_status_streamer,
    obter_ou_criar_config_notificacao,
    buscar_usuarios_para_notificar_expiracao,
    atualizar_ultimo_aviso_expiracao,
    desativar_assinatura_por_email,
    buscar_usuario_por_id,
)
from canal_gratuito.core.twitch import TwitchAPI # Reutilizando a TwitchAPI
from canal_gratuito.core.monitor import ( # Reutilizando fun√ß√µes e o dicion√°rio de modos
    agrupar_clipes_por_proximidade,
    get_time_minutes_ago,
    eh_clipe_ao_vivo_real,
    MODOS_MONITORAMENTO,
    minimo_clipes_por_viewers, # Importa a fun√ß√£o din√¢mica
)
from core.limpeza import executar_limpeza_completa

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from telegram.ext import Application
    from telegram import InlineKeyboardButton, InlineKeyboardMarkup

async def verificar_expiracoes_assinaturas(application: "Application"):
    """Verifica assinaturas pr√≥ximas da expira√ß√£o e envia lembretes."""
    logger.info("‚è≥ Verificando expira√ß√£o de assinaturas...")
    from telegram import InlineKeyboardButton, InlineKeyboardMarkup # Importa√ß√£o local
    usuarios_a_notificar = buscar_usuarios_para_notificar_expiracao()
    
    botao_renovar = InlineKeyboardButton("üí∏ Renovar Assinatura", callback_data="menu_2")
    keyboard = InlineKeyboardMarkup([[botao_renovar]])

    for usuario in usuarios_a_notificar:
        telegram_id = usuario['telegram_id']
        dias_restantes = usuario['dias_restantes']

        # NOVO: Buscar dados completos do usu√°rio para saber o plano
        user_data = buscar_usuario_por_id(telegram_id)
        if not user_data:
            logger.warning(f"Usu√°rio {telegram_id} para notifica√ß√£o de expira√ß√£o n√£o encontrado no DB. Pulando.")
            continue
        
        plano = user_data.get('plano_assinado')
        is_trial = plano == "Teste Gratuito"

        mensagem = ""
        dias_aviso = -1 # Valor sentinela

        # L√≥gica de mensagens para Teste Gratuito
        if is_trial:
            if dias_restantes <= 0:
                dias_aviso = 0
                mensagem = (
                    "üî¥ *Seu per√≠odo de teste gratuito terminou!* üî¥\n\n"
                    "Seu canal e suas configura√ß√µes foram removidos. Para continuar usando o Clipador e criar um novo canal, "
                    "assine um de nossos planos."
                )
            elif dias_restantes == 1:
                dias_aviso = 1
                mensagem = (
                    "‚ö†Ô∏è *Seu teste gratuito termina em menos de 24 horas!* ‚ö†Ô∏è\n\n"
                    "N√£o perca seu acesso! Assine agora para manter seu canal e continuar "
                    "recebendo os melhores clipes sem interrup√ß√£o."
                )
            elif dias_restantes <= 3:
                dias_aviso = 3
                mensagem = (
                    "üîî *Seu teste gratuito expira em 3 dias!* üîî\n\n"
                    "Gostou do que viu? Assine um de nossos planos para garantir que seu canal continue ativo "
                    "ap√≥s o per√≠odo de teste."
                )
        # L√≥gica de mensagens para planos pagos (existente)
        else:
            if dias_restantes <= 0:
                dias_aviso = 0
                mensagem = (
                    "üî¥ *Sua assinatura expirou!* üî¥\n\n"
                    "Seu acesso foi desativado. Para voltar a receber os melhores clipes, "
                    "renove sua assinatura agora mesmo."
                )
            elif dias_restantes == 1:
                dias_aviso = 1
                mensagem = (
                    "‚ö†Ô∏è *Aten√ß√£o: Sua assinatura expira em 1 dia!* ‚ö†Ô∏è\n\n"
                    "N√£o perca o acesso ao seu canal de clipes. Renove agora para continuar "
                    "recebendo os melhores momentos das lives sem interrup√ß√£o."
                )
            elif dias_restantes <= 3:
                dias_aviso = 3
                mensagem = (
                    "üîî *Lembrete: Sua assinatura expira em 3 dias!* üîî\n\n"
                    "Garanta que seu canal continue ativo. Renove sua assinatura para n√£o "
                    "perder nenhum clipe viral."
                )
            elif dias_restantes <= 7:
                dias_aviso = 7
                mensagem = (
                    "üëã Ol√°! Sua assinatura do Clipador expira em 7 dias.\n\n"
                    "Para garantir que voc√™ n√£o perca o acesso, voc√™ j√° pode renovar seu plano."
                )
        
        if mensagem and dias_aviso != -1:
            try:
                await application.bot.send_message(chat_id=telegram_id, text=mensagem, parse_mode="Markdown", reply_markup=keyboard)
                logger.info(f"‚úÖ Lembrete de expira√ß√£o ({dias_aviso} dias) enviado para o usu√°rio {telegram_id}.")
                atualizar_ultimo_aviso_expiracao(telegram_id, dias_aviso)

                # Se a assinatura expirou, envia um aviso no grupo e impede novos envios
                if dias_aviso == 0: # Removemos a l√≥gica de desativa√ß√£o e exclus√£o
                    chat_id = user_data.get("id_canal_telegram")
                    if chat_id:
                        await application.bot.send_message(chat_id=chat_id, text=f"üî¥ A assinatura do Clipador expirou. N√£o enviaremos mais clipes por enquanto. Renove para continuar!", parse_mode="Markdown")
                        logger.info(f"üî¥ Assinatura do usu√°rio {telegram_id} expirou. Notifica√ß√£o de expira√ß√£o enviada ao grupo.")
                    else:
                        logger.warning(
                            f"Assinatura do usu√°rio {telegram_id} expirou, mas o chat_id n√£o foi encontrado. N√£o foi poss√≠vel notificar o grupo."
                        )
            except telegram_error.TelegramError as e:
                logger.error(f"‚ùå Falha ao enviar lembrete de expira√ß√£o para {telegram_id}: {e}")

# Intervalo de monitoramento para cada cliente (em segundos)
INTERVALO_MONITORAMENTO_CLIENTE = 60 # A cada 60 segundos, verifica novos clipes
INTERVALO_ANALISE_MINUTOS_CLIENTE = 5 # Janela de tempo para buscar clipes (√∫ltimos 5 minutos)

async def monitorar_cliente(config_cliente: dict, application: "Application"):
    """
    L√≥gica de monitoramento de clipes da Twitch para um √∫nico cliente.
    Usa as credenciais e streamers do config_cliente para buscar e enviar clipes.
    """
    telegram_id = config_cliente['telegram_id']
    twitch_client_id = config_cliente['twitch_client_id']
    twitch_client_secret = config_cliente['twitch_client_secret']
    # streamers_monitorados vem como string separada por v√≠rgulas
    streamers_logins = [s.strip() for s in config_cliente['streamers_monitorados'].split(',') if s.strip()] if config_cliente['streamers_monitorados'] else []
    id_canal_telegram = config_cliente['id_canal_telegram']
    modo_monitoramento = config_cliente['modo_monitoramento']
    modo_parceiro = config_cliente.get('modo_parceiro', 'somente_bot')
    clipador_chefe_username = config_cliente.get('clipador_chefe_username')

    if not streamers_logins or not id_canal_telegram:
        logger.warning(f"ü§ñ [Monitor Cliente] Cliente {telegram_id} sem streamers ou ID de canal. Pulando monitoramento.")
        return
    requests_count = 0

    # Verifica√ß√£o das credenciais do cliente
    logger.info(f"ü§ñ [Monitor Cliente] Verificando credenciais para o usu√°rio {telegram_id}.")
    logger.info(f"   - Client ID: {twitch_client_id}")
    logger.info(f"   - Client Secret: {twitch_client_secret[:4]}...{twitch_client_secret[-4:]}") # Mostra apenas parte do segredo

    # Cada cliente ter√° sua pr√≥pria inst√¢ncia da TwitchAPI
    try:
        twitch = TwitchAPI(twitch_client_id, twitch_client_secret)
    except Exception as e:
        logger.error(f"‚ùå Falha ao inicializar TwitchAPI para o cliente {telegram_id}. As credenciais podem ser inv√°lidas. Erro: {e}")
        # Opcional: Adicionar l√≥gica para notificar o usu√°rio ou marcar o canal com erro no DB.
        return # Pula o monitoramento para este cliente neste ciclo

    logger.info(f"ü§ñ [Monitor Cliente] Iniciando para o usu√°rio {telegram_id} no canal {id_canal_telegram}.")
    logger.info(f"   - Streamers: {streamers_logins}, Modo: {modo_monitoramento}")

    try:
        # Obter IDs dos streamers
        # Valida√ß√£o da TwitchAPI
        logger.info(f"ü§ñ [Monitor Cliente] Buscando informa√ß√µes para {len(streamers_logins)} streamers do usu√°rio {telegram_id}.")
        # Otimiza a busca de informa√ß√µes dos usu√°rios em paralelo
        tasks = [twitch.get_user_info(login) for login in streamers_logins]
        user_infos = await asyncio.gather(*tasks)
        streamers_info = [info for info in user_infos if info] # Filtra os resultados nulos
        requests_count += len(streamers_logins)
        streamers_ids = {s["id"]: s["display_name"] for s in streamers_info}

        if not streamers_info:
            logger.warning(f"ü§ñ [Monitor Cliente] Nenhum streamer v√°lido encontrado para {telegram_id}. Pulando monitoramento.")
            application.bot_data[f'client_{telegram_id}_requests'] = requests_count
            return

        # Corre√ß√£o: buscar clipes retroativos de INTERVALO_ANALISE_MINUTOS_CLIENTE minutos
        tempo_inicio = get_time_minutes_ago(minutes=INTERVALO_ANALISE_MINUTOS_CLIENTE)

        # Busca a configura√ß√£o de notifica√ß√£o do cliente uma vez
        config_notificacao = obter_ou_criar_config_notificacao(telegram_id)
        notificar_online_status = config_notificacao.get('notificar_online', 1) == 1

        for streamer_id, display_name in streamers_ids.items():
            logger.debug(f"üé• [Monitor Cliente {telegram_id}] Buscando clipes de @{display_name}...")

            # --- L√ìGICA DE NOTIFICA√á√ÉO "STREAMER ONLINE" ---
            # Busca o status da stream no in√≠cio do loop para reutiliza√ß√£o
            stream = await twitch.get_stream_info(streamer_id)
            requests_count += 1

            status_atual = 'online' if stream else 'offline'
            status_anterior = obter_status_streamer(telegram_id, streamer_id)

            # Se o status mudou, atualiza no banco de dados
            if status_atual != status_anterior:
                atualizar_status_streamer(telegram_id, streamer_id, status_atual)
                logger.info(f"üîÑ [Status Change] @{display_name} mudou para {status_atual} para o cliente {telegram_id}.")

                # Se o streamer ficou online e as notifica√ß√µes est√£o ativas, envia o aviso
                if status_atual == 'online' and notificar_online_status:
                    try:
                        stream_title = stream.get('title', 'Sem t√≠tulo')
                        stream_game = stream.get('game_name', 'N√£o especificado')
                        stream_url = f"https://twitch.tv/{display_name}"
                        mensagem_online = (
                            f"üü¢ <b>@{display_name} est√° AO VIVO!</b>\n\n"
                            f"üìù {stream_title}\n"
                            f"üéÆ Jogando: {stream_game}\n\n"
                            f"{stream_url}"
                        )
                        await application.bot.send_message(chat_id=id_canal_telegram, text=mensagem_online, parse_mode="HTML")
                        logger.info(f"‚úÖ [Notifica√ß√£o Online] Enviada para o canal do cliente {telegram_id} sobre @{display_name}.")
                    except telegram_error.TelegramError as e:
                        logger.error(f"‚ùå Erro de Telegram ao enviar notifica√ß√£o online para o canal do cliente {telegram_id}: {e}")

            clipes = await twitch.get_recent_clips(streamer_id, started_at=tempo_inicio)
            requests_count += 1
            logger.debug(f"üîé [Monitor Cliente {telegram_id}] {len(clipes)} clipes encontrados para @{display_name} no per√≠odo.")
            
            # --- L√ìGICA DO CLIPADOR CHEFE ---
            if clipador_chefe_username and modo_parceiro in ['somente_chefe', 'chefe_e_bot']:
                for clipe in clipes:
                    creator_name = clipe.get('creator_name', '')
                    clipe_id = clipe.get('id')
                    
                    if creator_name.lower() == clipador_chefe_username.lower():
                        if not verificar_clipe_chefe_ja_enviado(telegram_id, clipe_id):
                            clipe_url = clipe["url"]
                            created_at_dt = datetime.fromisoformat(clipe["created_at"].replace("Z", "+00:00"))
                            
                            tipo_raw = "CLIPE AO VIVO" if await eh_clipe_ao_vivo_real(clipe, twitch, streamer_id) else "CLIPE DO VOD"
                            tipo_formatado = f"\nüî¥ <b>{tipo_raw}</b>" if tipo_raw == "CLIPE AO VIVO" else f"\n‚è≥ <b>{tipo_raw}</b>"

                            mensagem_chefe = (
                                f"{tipo_formatado}\n"
                                f"üì∫ @{display_name}\n"
                                f"üïí {created_at_dt.strftime('%d/%m/%Y %H:%M:%S')}\n"
                                f"‚úÇÔ∏è <b>Clipado por: @{clipador_chefe_username}</b>\n\n"
                                f"{clipe_url}"
                            )
                            try:
                                await application.bot.send_message(chat_id=id_canal_telegram, text=mensagem_chefe, parse_mode="HTML")
                                registrar_clipe_chefe_enviado(telegram_id, clipe_id)
                                logger.info(f"‚úÖ [Clipador Chefe] Clipe {clipe_id} de @{display_name} enviado para {telegram_id}.")
                            except telegram_error.TelegramError as e:
                                logger.error(f"‚ùå Erro de Telegram ao enviar clipe do chefe para o canal do cliente {telegram_id}: {e}")

            # --- L√ìGICA DE DETEC√á√ÉO AUTOM√ÅTICA ---
            # A l√≥gica de detec√ß√£o autom√°tica s√≥ roda se o modo parceiro permitir.
            if modo_parceiro in ['somente_bot', 'chefe_e_bot']:
                # A vari√°vel 'stream' j√° foi obtida no in√≠cio do loop
                is_vod_session = not stream and clipes

                # Define o crit√©rio de agrupamento (pode ser um n√∫mero ou uma fun√ß√£o)
                criterio_agrupamento = None

                if modo_monitoramento == "MANUAL":
                    intervalo_agrupamento = config_cliente.get('manual_interval_sec', 60)
                    minimo_clipes_ao_vivo = config_cliente.get('manual_min_clips', 3)
                    if is_vod_session:
                        logger.debug(f"üé• [Monitor Cliente {telegram_id}] Streamer @{display_name} offline. Usando crit√©rio de VOD (Manual).")
                        criterio_agrupamento = config_cliente.get('manual_min_clips_vod') or minimo_clipes_ao_vivo
                    else:
                        criterio_agrupamento = minimo_clipes_ao_vivo
                    logger.debug(f"üé• [Monitor Cliente {telegram_id}] Crit√©rio para @{display_name}: {criterio_agrupamento} clipes em {intervalo_agrupamento}s.")
                
                elif modo_monitoramento == "AUTOMATICO":
                    config_modo = MODOS_MONITORAMENTO.get(modo_monitoramento, MODOS_MONITORAMENTO["MODO_PADRAO"])
                    intervalo_agrupamento = config_modo["intervalo_segundos"]
                    # O crit√©rio √© a pr√≥pria fun√ß√£o, que usa o viewer_count do clipe. Funciona para live e VOD.
                    criterio_agrupamento = minimo_clipes_por_viewers
                    logger.debug(f"üé• [Monitor Cliente {telegram_id}] Crit√©rio para @{display_name}: Din√¢mico (Autom√°tico) em {intervalo_agrupamento}s.")

                else: # L√≥gica para modos predefinidos (Autom√°tico, Padr√£o, etc.)
                    config_modo = MODOS_MONITORAMENTO.get(modo_monitoramento, MODOS_MONITORAMENTO["MODO_PADRAO"])
                    intervalo_agrupamento = config_modo["intervalo_segundos"]
                    criterio_agrupamento = config_modo.get("min_clipes", 3)
                    logger.debug(f"üé• [Monitor Cliente {telegram_id}] Crit√©rio para @{display_name}: {criterio_agrupamento} clipes em {intervalo_agrupamento}s.")

                virais = agrupar_clipes_por_proximidade(clipes, intervalo_agrupamento, criterio_agrupamento)

                for grupo in virais:
                    inicio = grupo["inicio"]
                    fim = datetime.fromisoformat(grupo["fim"].replace("Z", "+00:00"))

                    if verificar_grupo_ja_enviado(telegram_id, streamer_id, inicio, fim):
                        continue

                    quantidade = len(grupo["clipes"])
                    primeiro_clipe = grupo["clipes"][0]
                    clipe_url = primeiro_clipe["url"]

                    tipo_raw = "CLIPE AO VIVO" if await eh_clipe_ao_vivo_real(primeiro_clipe, twitch, streamer_id) else "CLIPE DO VOD"
                    tipo_formatado = f"\nüî¥ <b>{tipo_raw}</b>" if tipo_raw == "CLIPE AO VIVO" else f"\n‚è≥ <b>{tipo_raw}</b>"

                    if quantidade == 1:
                        texto_clipadores = "üî• 1 PESSOA CLIPOU"
                    else:
                        texto_clipadores = f"üî• {quantidade} PESSOAS CLIPARAM"

                    mensagem = (
                        f"{tipo_formatado}\n"
                        f"üì∫ @{display_name}\n"
                        f"üïí {inicio.strftime('%H:%M:%S')} - {fim.strftime('%H:%M:%S')}\n"
                        f"{texto_clipadores}\n\n"
                        f"{clipe_url}"
                    )
                    
                    try:
                        await application.bot.send_message(chat_id=id_canal_telegram, text=mensagem, parse_mode="HTML")
                        registrar_grupo_enviado(telegram_id, streamer_id, inicio, fim)
                    except telegram_error.TimedOut:
                        logger.warning(f"‚è≥ Timeout ao tentar enviar mensagem para o canal do cliente {telegram_id}. A mensagem ser√° reenviada no pr√≥ximo ciclo.")
                    except telegram_error.TelegramError as e:
                        logger.error(f"‚ùå Erro de Telegram ao enviar mensagem para o canal do cliente {telegram_id}: {e}")

        application.bot_data[f'client_{telegram_id}_requests'] = requests_count

    except httpx.HTTPStatusError as e:
        if e.response and e.response.status_code in [401, 403]:
            logger.error(f"‚ùå Credenciais Twitch inv√°lidas para o cliente {telegram_id}. Notificando...")
            mensagem_erro = (
                "‚ö†Ô∏è *Aten√ß√£o: Suas credenciais da Twitch s√£o inv√°lidas ou expiraram!*\n\n"
                "O monitoramento para seu canal est√° pausado. Por favor, v√° at√© o bot "
                f"(@{application.bot.username}) e use o menu de gerenciamento para "
                "reconfigurar suas credenciais da Twitch."
            )
            try:
                await application.bot.send_message(
                    chat_id=id_canal_telegram,
                    text=mensagem_erro,
                    parse_mode="Markdown"
                )
            except Exception as send_error:
                logger.error(f"‚ùå Falha ao enviar notifica√ß√£o de erro de credenciais para o canal {id_canal_telegram}: {send_error}")
        else:
            # Se for outro erro HTTP, apenas loga para ser investigado.
            logger.error(f"‚ùå Erro HTTP no monitoramento do cliente {telegram_id}: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"‚ùå Erro no monitoramento do cliente {telegram_id}: {e}", exc_info=True)


async def iniciar_monitoramento_clientes(application: "Application"):
    """
    Busca todos os clientes ativos e com configura√ß√£o completa e inicia
    uma tarefa de monitoramento para cada um.
    Este loop principal garante que novos clientes sejam adicionados ao monitoramento
    e que clientes inativos sejam removidos.
    """
    logger.info("üì° Iniciando servi√ßo de monitoramento para clientes...")
    
    # Dicion√°rio para manter as tarefas de monitoramento ativas por telegram_id
    tarefas_ativas = {}
    
    # Controles de tempo para rotinas peri√≥dicas
    ultima_limpeza = datetime.now()
    INTERVALO_LIMPEZA_HORAS = 24
    ultima_verificacao_expiracao = datetime.now()
    INTERVALO_VERIFICACAO_EXPIRACAO_HORAS = 4 # A cada 4 horas

    while True:
        # --- Rotina de Verifica√ß√£o de Expira√ß√µes ---
        if datetime.now() - ultima_verificacao_expiracao > timedelta(hours=INTERVALO_VERIFICACAO_EXPIRACAO_HORAS):
            logger.info("Disparando rotina de verifica√ß√£o de expira√ß√µes...")
            try:
                await verificar_expiracoes_assinaturas(application)
            except Exception as e:
                logger.error(f"Erro inesperado na rotina de verifica√ß√£o de expira√ß√µes: {e}", exc_info=True)
            ultima_verificacao_expiracao = datetime.now()

        # --- Rotina de Limpeza Peri√≥dica ---
        if datetime.now() - ultima_limpeza > timedelta(hours=INTERVALO_LIMPEZA_HORAS):
            logger.info("Disparando rotina de limpeza em background...")
            # Executa a fun√ß√£o s√≠ncrona de limpeza em uma thread separada para n√£o bloquear o loop de eventos
            loop = asyncio.get_running_loop()
            await loop.run_in_executor(None, executar_limpeza_completa)
            ultima_limpeza = datetime.now()

        usuarios_ativos = buscar_usuarios_ativos_configurados()
        usuarios_ativos_ids = {u['telegram_id'] for u in usuarios_ativos}
        
        logger.info(f"üîç Encontrados {len(usuarios_ativos)} clientes ativos para monitorar.")
        
        # Iniciar/manter tarefas para usu√°rios ativos
        for usuario in usuarios_ativos:
            user_id = usuario['telegram_id']
            if user_id not in tarefas_ativas or tarefas_ativas[user_id].done():
                # Se a tarefa n√£o existe ou terminou, cria uma nova
                logger.info(f"üîÑ Criando/Reiniciando tarefa de monitoramento para o cliente {user_id}.")
                tarefas_ativas[user_id] = asyncio.create_task(monitorar_cliente(usuario, application))
        
        # Cancelar tarefas de usu√°rios que n√£o est√£o mais ativos/configurados
        for user_id in list(tarefas_ativas.keys()):
            if user_id not in usuarios_ativos_ids:
                logger.info(f"üõë Cancelando tarefa de monitoramento para cliente {user_id} (inativo/removido).")
                tarefas_ativas[user_id].cancel()
                await tarefas_ativas[user_id] # Aguarda o cancelamento
                del tarefas_ativas[user_id]
        
        # Aguarda um pouco antes de verificar novamente
        await asyncio.sleep(INTERVALO_MONITORAMENTO_CLIENTE)
        logger.debug("-- Ciclo de gerenciamento de tarefas de monitoramento conclu√≠do. --")
---
üìÑ core/telethon_criar_canal.py
---
import asyncio
import logging
from telethon import TelegramClient
from telethon.tl.functions.channels import CreateChannelRequest, EditPhotoRequest, InviteToChannelRequest, EditAdminRequest, DeleteChannelRequest, GetFullChannelRequest, EditBannedRequest
from telethon.tl.functions.messages import ExportChatInviteRequest # Import ChatAdminRights
from telethon.tl.types import InputChatUploadedPhoto, ChatBannedRights, User, ChatAdminRights # Import User here
from telethon.errors import ChannelPrivateError, FloodWaitError, UserBotError, UserNotMutualContactError, UserBlockedError, UserPrivacyRestrictedError, PeerFloodError # Import specific errors

# Adiciona a capacidade de carregar o arquivo .env ao executar este script diretamente
from dotenv import load_dotenv
load_dotenv()
import os

logger = logging.getLogger(__name__)


# --- Credenciais da API do Telegram (my.telegram.org) ---
API_ID = os.getenv("TELETHON_API_ID")
API_HASH = os.getenv("TELETHON_API_HASH")
TELEGRAM_BOT_USERNAME = os.getenv("TELEGRAM_BOT_USERNAME") # Novo: Username do bot Telegram
if not API_ID or not API_HASH:
    raise ValueError("As vari√°veis de ambiente TELETHON_API_ID e TELETHON_API_HASH devem ser configuradas.")

# --- Credenciais da Conta de Servi√ßo do Telegram ---
# Recomenda-se usar uma conta dedicada para o bot, n√£o a sua pessoal.
SESSION_NAME = os.getenv("TELETHON_SESSION_NAME", "clipador_session")

# --- Configura√ß√µes do Canal ---

# Caminho da imagem do canal
IMAGEM_PADRAO_PATH = os.path.join("images", "logo_canal.jpg")  # certifique-se que essa imagem exista

async def criar_canal_telegram(nome_exibicao: str, telegram_id: int, caminho_imagem: str = None):
    """
    Cria um canal privado no Telegram, adiciona o usu√°rio e define a foto.
    Utiliza um arquivo de sess√£o para evitar logins interativos repetidos.
    Na primeira execu√ß√£o, pode ser necess√°rio um login interativo para criar o arquivo .session.
    """
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        # Garante que o cliente est√° conectado. Se o arquivo .session existir, ele ser√° usado.
        # Se n√£o, um login interativo ser√° iniciado. √â recomendado gerar o .session localmente uma vez.
        me = await client.get_me()
        logger.info(f"Telethon conectado como: {me.username}")

        # Cria o canal
        logger.info(f"Telethon: Criando canal para {nome_exibicao} (ID: {telegram_id})...")
        canal = await client(CreateChannelRequest(
            title=f"Clipador üé• {nome_exibicao}", # Usa o nome de exibi√ß√£o diretamente
            about=f"‚öôÔ∏è Gerencie seu canal em {TELEGRAM_BOT_USERNAME}\n\nQue a ca√ßa aos clipes comece! üèπ",
            megagroup=False # False para criar um canal de transmiss√£o, n√£o um supergrupo
        ))
        canal_entidade = canal.chats[0]
        logger.info(f"Telethon: Canal '{canal_entidade.title}' (ID: {canal_entidade.id}) criado.")

        # Adiciona uma pequena pausa para garantir que o canal seja totalmente inicializado
        await asyncio.sleep(0.5)

        # 1. Adiciona o bot do Telegram como administrador
        if TELEGRAM_BOT_USERNAME:
            try:
                bot_entity = await client.get_entity(TELEGRAM_BOT_USERNAME)
                if isinstance(bot_entity, User) and bot_entity.bot:
                    # Direitos m√≠nimos para o bot poder postar e gerenciar o canal
                    bot_admin_rights = ChatAdminRights(post_messages=True, edit_messages=True, delete_messages=True, change_info=True, invite_users=True, pin_messages=True)
                    
                    # Tenta promover o bot a administrador diretamente.
                    # Isso deve adicionar o bot ao canal se ele ainda n√£o for membro.
                    logger.info(f"Telethon: Promovendo bot @{TELEGRAM_BOT_USERNAME} a administrador do canal {canal_entidade.id}...")
                    await client(EditAdminRequest(channel=canal_entidade, user_id=bot_entity, admin_rights=bot_admin_rights, rank="ClipadorBot"))
                    logger.info(f"‚úÖ Bot @{TELEGRAM_BOT_USERNAME} promovido a administrador do canal.")
                else:
                    logger.warning(f"‚ö†Ô∏è Aviso: Entidade '{TELEGRAM_BOT_USERNAME}' n√£o √© um bot v√°lido. N√£o foi adicionado como admin.")
            except Exception as e:
                logger.error(f"‚ùå Erro ao adicionar o bot como administrador: {e}", exc_info=True)
                raise # Re-lan√ßa a exce√ß√£o para que o fluxo principal saiba que falhou.
        else:
            logger.warning("‚ö†Ô∏è Aviso: Vari√°vel de ambiente TELEGRAM_BOT_USERNAME n√£o configurada. O bot n√£o ser√° adicionado como administrador do canal.")

        # 2. Define a imagem do canal (personalizada ou padr√£o)
        try:
            caminho_final_imagem = caminho_imagem or IMAGEM_PADRAO_PATH
            if os.path.exists(caminho_final_imagem):
                logger.info(f"Telethon: Definindo imagem de perfil do canal {canal_entidade.id} com '{caminho_final_imagem}'...")
                uploaded_photo = await client.upload_file(caminho_final_imagem)
                await client(EditPhotoRequest(
                    channel=canal_entidade,
                    photo=InputChatUploadedPhoto(uploaded_photo)
                ))
                logger.info(f"‚úÖ Imagem de perfil definida para o canal {canal_entidade.id}.")
            else:
                logger.warning(f"‚ö†Ô∏è Aviso: Imagem n√£o encontrada em {caminho_final_imagem}. Canal criado sem imagem de perfil.")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Aviso: N√£o foi poss√≠vel definir a foto do canal. Erro: {e}", exc_info=True)
            # N√£o interrompe o fluxo, continua mesmo que a foto falhe

        # 3. Adiciona o usu√°rio (cliente) ao canal
        try:
            logger.info(f"Telethon: Adicionando usu√°rio {telegram_id} ao canal {canal_entidade.id}...")
            await client(InviteToChannelRequest(
                channel=canal_entidade,
                users=[telegram_id]
            ))
            logger.info(f"‚úÖ Usu√°rio {telegram_id} adicionado ao canal.")
        except (UserPrivacyRestrictedError, UserNotMutualContactError, ValueError) as e:
            logger.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel adicionar {telegram_id} diretamente ao canal devido √†s suas configura√ß√µes de privacidade: {e}. Um link de convite ser√° usado como alternativa.")
        except Exception as e:
            logger.error(f"‚ùå Erro ao adicionar usu√°rio {telegram_id} ao canal: {e}", exc_info=True)

        # 4. Gera o link de convite (essencial como fallback e para o bot√£o final)
        logger.info(f"Telethon: Gerando link de convite para o canal {canal_entidade.id}...")
        link_convite = await client(ExportChatInviteRequest(peer=canal_entidade))
        logger.info(f"‚úÖ Link de convite gerado: {link_convite.link}")

        # O ID do canal para a API de Bot deve ser o ID base (positivo) prefixado com -100.
        id_canal_bot_api = int(f"-100{canal_entidade.id}")
        logger.info(f"‚úÖ Canal criado: {canal_entidade.title} | ID Base: {canal_entidade.id} | ID para Bot API: {id_canal_bot_api}")
        return id_canal_bot_api, link_convite.link

async def adicionar_usuario_ao_canal(id_canal: int, id_usuario_alvo: int):
    """Adiciona um usu√°rio a um canal espec√≠fico."""
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            logger.info(f"Telethon: Adicionando usu√°rio {id_usuario_alvo} ao canal {id_canal}...")
            await client(InviteToChannelRequest(
                channel=id_canal,
                users=[id_usuario_alvo]
            ))
            logger.info(f"‚úÖ Usu√°rio {id_usuario_alvo} adicionado ao canal {id_canal}.")
            return True, "Usu√°rio adicionado com sucesso."
        except (UserPrivacyRestrictedError, UserNotMutualContactError):
            logger.warning(f"N√£o foi poss√≠vel adicionar {id_usuario_alvo} ao canal {id_canal} devido √†s configura√ß√µes de privacidade do usu√°rio.")
            return False, "N√£o foi poss√≠vel adicionar o usu√°rio devido √†s suas configura√ß√µes de privacidade."
        except Exception as e:
            logger.error(f"Erro inesperado ao adicionar usu√°rio {id_usuario_alvo} ao canal {id_canal}: {e}", exc_info=True)
            return False, f"Erro inesperado: {e}"


async def remover_usuario_do_canal(id_canal: int, id_usuario_alvo: int):
    """Remove (bane/kicka) um usu√°rio de um canal espec√≠fico."""
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            logger.info(f"Telethon: Removendo usu√°rio {id_usuario_alvo} do canal {id_canal}...")
            # Para remover, "banimos" o usu√°rio com o direito de ver mensagens revogado.
            await client(EditBannedRequest(
                channel=id_canal,
                participant=id_usuario_alvo,
                banned_rights=ChatBannedRights(until_date=None, view_messages=True)
            ))
            logger.info(f"‚úÖ Usu√°rio {id_usuario_alvo} removido do canal {id_canal}.")
            return True, "Usu√°rio removido com sucesso."
        except Exception as e:
            logger.error(f"Erro inesperado ao remover usu√°rio {id_usuario_alvo} do canal {id_canal}: {e}", exc_info=True)
            return False, f"Erro inesperado: {e}"

async def deletar_canal_telegram(id_canal: int):
    """Deleta um canal do Telegram usando o Telethon."""
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            logger.info(f"Tentando deletar o canal com ID: {id_canal}")
            await client(DeleteChannelRequest(channel=id_canal))
            logger.info(f"Canal {id_canal} deletado com sucesso.")
            return True
        except ChannelPrivateError:
            logger.warning(f"N√£o foi poss√≠vel deletar o canal {id_canal}: o bot n√£o √© admin ou o canal √© privado.")
            return False
        except FloodWaitError as e:
            logger.error(f"Flood wait error ao tentar deletar canal {id_canal}. Aguardando {e.seconds} segundos.")
            await asyncio.sleep(e.seconds)
            return await deletar_canal_telegram(id_canal) # Tenta novamente
        except Exception as e:
            logger.error(f"Erro inesperado ao deletar o canal {id_canal}: {e}", exc_info=True)
            return False

async def obter_detalhes_canal(id_canal: int):
    """Obt√©m detalhes de um canal, como n√∫mero de participantes."""
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            full_channel = await client(GetFullChannelRequest(channel=id_canal))
            return {
                "participants_count": full_channel.full_chat.participants_count,
                "about": full_channel.full_chat.about
            }
        except (ValueError, TypeError): # Handle cases where channel ID is invalid before request
            logger.error(f"ID do canal inv√°lido fornecido: {id_canal}")
            return None
        except Exception as e:
            logger.error(f"Erro ao obter detalhes do canal {id_canal}: {e}", exc_info=True)
            return None

if __name__ == "__main__":
    import asyncio
    import sys

    if len(sys.argv) < 3:
        print("Uso para teste manual: python core/telethon_criar_canal.py <username_do_usuario> <id_numerico_do_usuario>")
        print("Exemplo: python core/telethon_criar_canal.py meu_usuario 123456789")
        print("\nCertifique-se de que as vari√°veis de ambiente TELETHON_API_ID e TELETHON_API_HASH est√£o definidas.")
        print("Na primeira execu√ß√£o, um login interativo ser√° necess√°rio para criar o arquivo de sess√£o.")
    else:
        asyncio.run(criar_canal_telegram(sys.argv[1], int(sys.argv[2])))
---
üìÑ core/launcher.py
---
import subprocess
import sys
import os
import json

from chat_privado.main import iniciar_chat_privado
from core.bootstrap import iniciar_ambiente

import pytz
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# For√ßar timezone UTC corretamente
def scheduler_utc_patch(self, config=None, **kwargs):
    self._configure({'timezone': pytz.utc})

AsyncIOScheduler.configure = scheduler_utc_patch

ESTADO_PATH = "memoria/estado_bot.json"

def criar_estado_se_nao_existir():
    if not os.path.exists(ESTADO_PATH):
        os.makedirs(os.path.dirname(ESTADO_PATH), exist_ok=True)
        with open(ESTADO_PATH, "w", encoding="utf-8") as f:
            json.dump({
                "ultima_execucao": None,
                "ultimo_envio_promocional": 0,
                "ultimo_envio_header": 0,
                "ultimo_envio_atualizacao_streamers": 0,
                "grupos_enviados": []
            }, f, ensure_ascii=False, indent=2)

def limpar_estado():
    if os.path.exists(ESTADO_PATH):
        os.remove(ESTADO_PATH)
        print("üßº Mem√≥ria anterior apagada.")

def iniciar_clipador(validar_variaveis=True):
    if validar_variaveis:
        iniciar_ambiente()

    if "--limpar-estado" in sys.argv:
        limpar_estado()

    criar_estado_se_nao_existir()

    try:
        # A l√≥gica do canal gratuito e do chat privado agora √© iniciada em um √∫nico processo
        # para evitar inst√¢ncias conflitantes do bot que causam o erro 'telegram.error.Conflict'.
        iniciar_chat_privado()

    except KeyboardInterrupt:
        print("\nüõë Clipador encerrado.")

---
üìÑ core/limpeza.py
---
import os
import logging
import sqlite3
from datetime import datetime, timedelta

from core.database import conectar

logger = logging.getLogger(__name__)

# --- Constantes de Limpeza ---
DIRETORIO_LOGS = "memoria"
TAMANHO_MAX_LOG_MB = 10
TAMANHO_MAX_LOG_BYTES = TAMANHO_MAX_LOG_MB * 1024 * 1024
LINHAS_A_MANTER_LOG = 10000  # Mant√©m as √∫ltimas 10.000 linhas (~1-2MB)

RETENCAO_HISTORICO_DB_HORAS = 24 # Reten√ß√£o de 24 horas no DB


def limpar_logs_antigos():
    """
    Verifica a pasta de logs e trunca arquivos .txt que excedem o tamanho m√°ximo,
    mantendo apenas as linhas mais recentes.
    """
    if not os.path.isdir(DIRETORIO_LOGS):
        logger.info(f"Diret√≥rio de logs '{DIRETORIO_LOGS}' n√£o encontrado. Pulando limpeza de logs.")
        return

    logger.info("Iniciando verifica√ß√£o de arquivos de log...")
    for filename in os.listdir(DIRETORIO_LOGS):
        if filename.endswith(".txt"):
            filepath = os.path.join(DIRETORIO_LOGS, filename)
            try:
                if os.path.getsize(filepath) > TAMANHO_MAX_LOG_BYTES:
                    logger.warning(f"Arquivo de log '{filepath}' excedeu {TAMANHO_MAX_LOG_MB} MB. Truncando...")

                    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                        linhas = f.readlines()

                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.writelines(linhas[-LINHAS_A_MANTER_LOG:])

                    logger.info(f"‚úÖ Arquivo '{filepath}' truncado. {LINHAS_A_MANTER_LOG} linhas recentes foram mantidas.")
            except FileNotFoundError:
                continue
            except Exception as e:
                logger.error(f"Erro ao processar o arquivo de log '{filepath}': {e}", exc_info=True)


def limpar_historico_banco_dados():
    """
    Remove registros da tabela 'historico_envios' com mais de 24 horas.
    """
    conn = None
    try:
        conn = conectar()
        cursor = conn.cursor()
        limite_tempo = datetime.now() - timedelta(hours=RETENCAO_HISTORICO_DB_HORAS)

        logger.info(f"Iniciando limpeza do 'historico_envios' (registros com mais de {RETENCAO_HISTORICO_DB_HORAS} horas)...")

        cursor.execute("DELETE FROM historico_envios WHERE enviado_em < ?", (limite_tempo,))
        removidos = cursor.rowcount
        conn.commit()

        if removidos > 0:
            logger.info(f"‚úÖ Limpeza do banco de dados conclu√≠da. {removidos} registros antigos removidos.")
        else:
            logger.debug("Nenhum registro antigo encontrado em 'historico_envios' para remover.")

    except sqlite3.Error as e:
        logger.error(f"Erro de banco de dados ao limpar hist√≥rico: {e}", exc_info=True)
    finally:
        if conn:
            conn.close()


def executar_limpeza_completa():
    """Executa todas as rotinas de limpeza (logs e banco de dados)."""
    logger.info("--- Iniciando rotina de limpeza peri√≥dica ---")
    limpar_logs_antigos()
    limpar_historico_banco_dados()
    logger.info("--- Rotina de limpeza peri√≥dica finalizada ---")
---
üìÑ core/telethon_gerenciar_canal.py
---
from telethon import TelegramClient
from telethon.tl.functions.channels import DeleteChannelRequest, EditBannedRequest
from telethon.tl.types import ChatBannedRights
from dotenv import load_dotenv
import os

load_dotenv()

API_ID = os.getenv("TELETHON_API_ID")
API_HASH = os.getenv("TELETHON_API_HASH")
SESSION_NAME = os.getenv("TELETHON_SESSION_NAME", "clipador_session")

async def remover_usuario_do_canal(id_canal: int, telegram_id_usuario: int):
    """Remove (bane) um usu√°rio de um canal espec√≠fico."""
    if not all([API_ID, API_HASH, SESSION_NAME]):
        print("‚ùå Credenciais do Telethon n√£o configuradas para gerenciamento.")
        return False

    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            print(f"Removendo usu√°rio {telegram_id_usuario} do canal {id_canal}...")
            # A forma de remover um usu√°rio de um canal de transmiss√£o √© "bani-lo".
            await client(EditBannedRequest(
                channel=id_canal,
                participant=telegram_id_usuario,
                banned_rights=ChatBannedRights(until_date=None, view_messages=True)
            ))
            print(f"‚úÖ Usu√°rio {telegram_id_usuario} removido com sucesso.")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao remover usu√°rio {telegram_id_usuario} do canal {id_canal}: {e}")
            return False

async def excluir_canal_telegram(id_canal: int):
    """Exclui um canal permanentemente."""
    if not all([API_ID, API_HASH, SESSION_NAME]):
        print("‚ùå Credenciais do Telethon n√£o configuradas para gerenciamento.")
        return False
        
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        try:
            print(f"Excluindo canal {id_canal}...")
            await client(DeleteChannelRequest(channel=id_canal))
            print(f"‚úÖ Canal {id_canal} exclu√≠do com sucesso.")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao excluir canal {id_canal}: {e}")
            return False
---
üìÑ core/gateway/mercadopago.py
---
import requests
import uuid
from core.ambiente import MERCADO_PAGO_ACCESS_TOKEN
from configuracoes import TIPO_LOG

MERCADO_PAGO_API = "https://api.mercadopago.com"

HEADERS = {
    "Authorization": f"Bearer {MERCADO_PAGO_ACCESS_TOKEN}",
    "Content-Type": "application/json"
}

def consultar_pagamento(id_pagamento: int) -> str:
    url = f"{MERCADO_PAGO_API}/v1/payments/{id_pagamento}"
    response = requests.get(url, headers=HEADERS)
    data = response.json()
    print("üì¶ CONSULTA PAGAMENTO:", data)
    return data.get("status", "erro")

def criar_pagamento_pix(valor: float, descricao: str):
    idempotency_key = str(uuid.uuid4())

    payload = {
        "transaction_amount": valor,
        "description": descricao,
        "payment_method_id": "pix",
        "payer": {
            "email": f"{uuid.uuid4().hex[:8]}@sandbox.com"
        }
    }

    headers = {
        **HEADERS,
        "X-Idempotency-Key": idempotency_key
    }

    response = requests.post(f"{MERCADO_PAGO_API}/v1/payments", json=payload, headers=headers)
    data = response.json()

    if TIPO_LOG == "DESENVOLVEDOR":
        print("üì¶ RESPOSTA MP (PIX):", data)

    if "point_of_interaction" not in data or "transaction_data" not in data["point_of_interaction"]:
        raise Exception("A resposta do Mercado Pago n√£o cont√©m os dados do Pix (provavelmente falha na sandbox).")

    return {
        "valor": valor,
        "descricao": descricao,
        "qrcode": data["point_of_interaction"]["transaction_data"]["qr_code"],
        "imagem": data["point_of_interaction"]["transaction_data"]["qr_code_base64"],
        "id_pagamento": data["id"]
    }


def criar_pagamento_cartao(valor: float, descricao: str):
    payload = {
        "items": [
            {
                "title": descricao,
                "quantity": 1,
                "currency_id": "BRL",
                "unit_price": valor
            }
        ],
        "payment_methods": {
            "excluded_payment_types": [{"id": "pix"}]
        },
        "back_urls": {
            "success": "https://clipador.com.br/sucesso",
            "failure": "https://clipador.com.br/erro",
            "pending": "https://clipador.com.br/pendente"
        },
        "auto_return": "approved"
    }

    response = requests.post(f"{MERCADO_PAGO_API}/checkout/preferences", json=payload, headers=HEADERS)
    data = response.json()

    if TIPO_LOG == "DESENVOLVEDOR":
        print("üì¶ RESPOSTA MP (CART√ÉO):", data)

    return data["init_point"]

---
üìÑ core/gateway/kirvano.py
---
from core.database import (
    buscar_telegram_por_email,
    is_usuario_admin,
    buscar_compra_aprovada_por_email,
    registrar_log_pagamento # Mantido para logs
)

def verificar_status_compra_para_ativacao(email: str, telegram_id: int) -> tuple:
    """
    Verifica o status de uma compra para fins de ativa√ß√£o do usu√°rio pelo bot.
    N√£o registra a compra, apenas consulta o banco de dados.
    """
    ja_usado = buscar_telegram_por_email(email)
    if ja_usado and ja_usado != telegram_id:
        registrar_log_pagamento(telegram_id, email, plano="desconhecido", status="email_duplicado")
        return "duplicado", None

    compra = buscar_compra_aprovada_por_email(email)
    if not compra:
        registrar_log_pagamento(telegram_id, email, plano="desconhecido", status="email_sem_compra")
        return "not_found", None # Alterado para 'not_found' para ser mais claro

    # Retorna o status da compra e o plano real encontrado no DB
    return compra["status"].lower(), compra["plano"] # Retorna o status e o plano da compra
---
üìÑ core/gateway/webhook_kirvano.py
---
from flask import Flask, request, jsonify
import os
import asyncio
from datetime import datetime, timedelta
import subprocess # Importa o m√≥dulo subprocess

# Adicionar o path do projeto para que os imports funcionem
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from core.database import desativar_assinatura_por_email, buscar_configuracao_canal, atualizar_data_expiracao, registrar_compra, sale_id_ja_registrado
from core.telethon_criar_canal import remover_usuario_do_canal
from core.ambiente import KIRVANO_TOKEN

app = Flask(__name__)

# Fun√ß√£o para iniciar o ngrok (movida para fora do bloco main)
def iniciar_ngrok():
    try:
        # Inicia o ngrok em segundo plano.  Adapte o caminho conforme necess√°rio.
        process = subprocess.Popen(['ngrok', 'http', '5100'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Imprime os logs do ngrok para fins de depura√ß√£o (opcional)
        # for line in process.stdout:
        #     print(line.decode('utf-8').strip())
        # for line in process.stderr:
        #     print(line.decode('utf-8').strip())
        print("ngrok iniciado em background.")
        return process
    except FileNotFoundError:
        print("Erro: ngrok n√£o encontrado. Verifique se est√° instalado e no PATH.")
        return None
    except Exception as e:
        print(f"Erro ao iniciar ngrok: {e}")
        return None

# Fun√ß√£o para rodar corrotinas a partir de um contexto s√≠ncrono (Flask)
def run_async(coro):
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    
    return loop.run_until_complete(coro)

@app.route('/webhook/kirvano', methods=['POST'])
def kirvano_webhook():
    # 1. Validar o token de seguran√ßa
    token_recebido = request.headers.get('X-Kirvano-Token')
    if not KIRVANO_TOKEN or token_recebido != KIRVANO_TOKEN:
        print(f"‚ö†Ô∏è Tentativa de acesso ao webhook com token inv√°lido. Recebido: {token_recebido}")
        return jsonify({"status": "error", "message": "Token inv√°lido"}), 403

    data = request.json
    event_type = data.get('event_type')
    email = data.get('customer', {}).get('email')
    status = data.get('status')

    if not email:
        return jsonify({"status": "error", "message": "E-mail n√£o encontrado no payload"}), 400

    print(f"üîî Webhook recebido: {event_type} para o e-mail {email}")

    # 2. Roteamento de Eventos
    if event_type in ['subscription.canceled', 'subscription.expired', 'purchase.refunded', 'purchase.chargeback', 'subscription.late']:
        handle_subscription_ended(email, status)

    elif event_type == 'subscription.renewed':
        plano = data.get('plan', {}).get('name', '')
        handle_subscription_renewed(email, plano)
    
    elif event_type == 'purchase.approved':
        sale_id = data.get('sale_id')
        if not sale_id:
            print("‚ö†Ô∏è Webhook de compra aprovada sem 'sale_id'. Ignorando.")
            return jsonify({"status": "error", "message": "sale_id n√£o encontrado"}), 400

        if sale_id_ja_registrado(sale_id):
            print(f"INFO: Compra com sale_id {sale_id} j√° registrada. Ignorando webhook duplicado.")
            return jsonify({"status": "success", "message": "duplicado"}), 200

        # Extraindo dados do payload
        produto = data.get('products', [{}])[0]
        plano = produto.get('offer_name', 'Plano Desconhecido')
        metodo_pagamento = data.get('payment', {}).get('method')
        data_criacao = data.get('created_at')
        offer_id = produto.get('offer_id')
        nome_completo = data.get('customer', {}).get('name')
        telefone = data.get('customer', {}).get('phone_number')

        # O telegram_id √© None aqui, pois ser√° vinculado pelo bot depois
        registrar_compra(None, email, plano, metodo_pagamento, status, sale_id, data_criacao, offer_id, nome_completo, telefone)
        print(f"‚úÖ Compra aprovada para {email} (Plano: {plano}) registrada no banco de dados via webhook.")


    else:
        print(f"INFO: Evento n√£o tratado recebido: {event_type}")

    return jsonify({"status": "success"}), 200

def handle_subscription_ended(email, status):
    """Lida com o fim de uma assinatura (cancelada, expirada, etc.)."""
    print(f"Iniciando processo de desativa√ß√£o para {email} (Status: {status})")
    
    telegram_id = desativar_assinatura_por_email(email, novo_status=status)

    if not telegram_id:
        print(f"Usu√°rio com e-mail {email} n√£o encontrado ou j√° inativo.")
        return

    config = buscar_configuracao_canal(telegram_id)
    if config and config.get('id_canal_telegram'):
        id_canal = int(config['id_canal_telegram'])
        run_async(remover_usuario_do_canal(id_canal, telegram_id))
    else:
        print(f"Usu√°rio {telegram_id} n√£o possui canal configurado para remo√ß√£o.")

def handle_subscription_renewed(email, plano):
    """Lida com a renova√ß√£o de uma assinatura, estendendo a data de expira√ß√£o."""
    print(f"Iniciando processo de renova√ß√£o para {email}")
    
    if "Anual" in plano:
        nova_data = datetime.now() + timedelta(days=365)
    else: # Assume mensal
        nova_data = datetime.now() + timedelta(days=31) # 31 para dar uma margem
    
    atualizar_data_expiracao(email, nova_data)
    print(f"Data de expira√ß√£o para {email} atualizada para {nova_data.strftime('%Y-%m-%d')}")

def iniciar_webhook():
    # Verifica a vari√°vel de ambiente antes de iniciar o ngrok
    from configuracoes import ENABLE_NGROK

    if ENABLE_NGROK:
        ngrok_process = iniciar_ngrok()
    else:
        print("ngrok desativado pela vari√°vel de ambiente.")
        ngrok_process = None

    app.run(host='0.0.0.0', port=5100, debug=True, use_reloader=False) # Adicionado debug e reloader para evitar multiplas instancias
    if ngrok_process:
        ngrok_process.terminate()
---
üìÑ chat_privado/usuarios.py
---
from typing import Optional, List, Dict, Any
import core.database as db  # Importa nosso m√≥dulo centralizado de banco de dados

def get_nivel_usuario(telegram_id: int, nome: Optional[str] = None) -> Optional[int]:
    """
    Obt√©m o n√≠vel do usu√°rio. Se n√£o existir e um nome for fornecido,
    registra como um novo usu√°rio e retorna o n√≠vel padr√£o.
    """
    nivel = db.obter_nivel_usuario(telegram_id)
    
    # Se o n√≠vel for 1 (padr√£o) e n√£o houver um usu√°rio real, pode ser um novo usu√°rio.
    # Vamos verificar se o usu√°rio existe de fato.
    usuario_existente = db.buscar_usuario_por_id(telegram_id)

    if usuario_existente:
        return usuario_existente.get('nivel', 1)
    
    if nome:
        # Usu√°rio n√£o existe, vamos registr√°-lo usando a fun√ß√£o centralizada.
        registrar_usuario(telegram_id, nome)
        return 1  # Retorna o n√≠vel padr√£o para novos usu√°rios.
    
    return None # N√£o pode registrar sem nome e o usu√°rio n√£o foi encontrado.


def registrar_usuario(telegram_id: int, nome: str):
    """
    Registra um novo usu√°rio no banco de dados com valores padr√£o,
    utilizando a fun√ß√£o centralizada em core.database.
    """
    db.adicionar_usuario(user_id=telegram_id, nome=nome)


def atualizar_usuario(telegram_id: int, nome: Optional[str] = None, nivel: Optional[int] = None):
    """
    Atualiza o nome e/ou n√≠vel do usu√°rio, utilizando a nova fun√ß√£o de suporte
    em core.database.
    """
    db.atualizar_dados_usuario(telegram_id=telegram_id, nome=nome, nivel=nivel)


def remover_usuario(telegram_id: int):
    """
    Remove um usu√°rio e todos os seus dados associados do banco,
    utilizando a fun√ß√£o centralizada.
    """
    db.remover_usuario_por_id(telegram_id=telegram_id)


def listar_usuarios() -> List[Dict[str, Any]]:
    """
    Lista todos os usu√°rios do sistema para fins de administra√ß√£o,
    utilizando a fun√ß√£o centralizada.
    """
    return db.listar_todos_usuarios()
---
üìÑ chat_privado/handlers.py
---
from telegram.ext import Application, CommandHandler, CallbackQueryHandler

# Importar handlers dos menus
from .menus.menu_callback import (
    responder_menu_1,
    responder_menu_2,
    responder_menu_3,
    responder_menu_4_mensal,
    responder_menu_4_plus,
    responder_menu_4_anual,
)
from .menus.menu_pagamento import (
    pagamento_conversation_handler,
    roteador_pagamento,
    responder_menu_5_mensal,
    responder_menu_5_plus,
    responder_menu_5_anual,
)
from .menus.menu_configurar_canal import configurar_canal_conversa, responder_inicio
from .menus.menu_gerenciamento import (
    gerenciar_streamers_conversa,
    configurar_manual_conversa,
    abrir_menu_gerenciar_canal,
    ver_plano_atual,
    comprar_slot_extra,
    abrir_menu_alterar_modo,
    salvar_novo_modo,
    placeholder_callback,
)
from .menus.menu_notificacoes import (
    abrir_menu_notificacoes,
    toggle_notificacao,
)
from .admin_commands import (
    admin_command,
    reset_user_command,
    create_channel_command,
    delete_channel_command,
    user_info_command,
    set_plan_command,
    add_slot_command,
    set_cooldown_command,
    remove_slots_command,
    manage_channel_members_command,
    set_streamers_command,
    broadcast_command,
    stats_command,
    channel_stats_command,
    message_command,
)

def registrar_handlers(app: Application):
    """Registra todos os command, callback e conversation handlers do chat privado."""

    # 1. Handlers de Conversa (devem vir primeiro para ter prioridade)
    app.add_handler(pagamento_conversation_handler)
    app.add_handler(configurar_canal_conversa())
    app.add_handler(gerenciar_streamers_conversa())
    app.add_handler(configurar_manual_conversa())

    # 2. Comandos
    app.add_handler(CommandHandler("start", responder_inicio))
    app.add_handler(CommandHandler("admin", admin_command))
    app.add_handler(CommandHandler("resetuser", reset_user_command))
    app.add_handler(CommandHandler("createchannel", create_channel_command))
    app.add_handler(CommandHandler("delchannel", delete_channel_command))
    app.add_handler(CommandHandler("userinfo", user_info_command))
    app.add_handler(CommandHandler("setplan", set_plan_command))
    app.add_handler(CommandHandler("addslot", add_slot_command))
    app.add_handler(CommandHandler("removeslots", remove_slots_command))
    app.add_handler(CommandHandler("setcooldown", set_cooldown_command))
    app.add_handler(CommandHandler("channelmembers", manage_channel_members_command))
    app.add_handler(CommandHandler("setstreamers", set_streamers_command))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    app.add_handler(CommandHandler("stats", stats_command))
    app.add_handler(CommandHandler("channelstats", channel_stats_command))
    app.add_handler(CommandHandler("message", message_command))

    # 3. Handlers de CallbackQuery (menus)
    app.add_handler(CallbackQueryHandler(responder_inicio, pattern="^menu_0$"))
    app.add_handler(CallbackQueryHandler(responder_menu_1, pattern="^menu_1$"))
    app.add_handler(CallbackQueryHandler(responder_menu_2, pattern="^menu_2$"))
    app.add_handler(CallbackQueryHandler(responder_menu_3, pattern="^menu_3$"))
    app.add_handler(CallbackQueryHandler(responder_menu_4_mensal, pattern="^menu_4_mensal$"))
    app.add_handler(CallbackQueryHandler(responder_menu_4_plus, pattern="^menu_4_plus$"))
    app.add_handler(CallbackQueryHandler(responder_menu_4_anual, pattern="^menu_4_anual$"))
    app.add_handler(CallbackQueryHandler(responder_menu_5_mensal, pattern="^menu_5_mensal$"))
    app.add_handler(CallbackQueryHandler(responder_menu_5_plus, pattern="^menu_5_plus$"))
    app.add_handler(CallbackQueryHandler(responder_menu_5_anual, pattern="^menu_5_anual$"))
    app.add_handler(CallbackQueryHandler(roteador_pagamento, pattern="^pagar_"))
    app.add_handler(CallbackQueryHandler(abrir_menu_gerenciar_canal, pattern="^abrir_menu_gerenciar_canal$"))
    app.add_handler(CallbackQueryHandler(ver_plano_atual, pattern="^ver_plano_atual$"))
    app.add_handler(CallbackQueryHandler(comprar_slot_extra, pattern="^comprar_slot_extra$"))
    app.add_handler(CallbackQueryHandler(abrir_menu_alterar_modo, pattern="^gerenciar_modo$"))
    app.add_handler(CallbackQueryHandler(salvar_novo_modo, pattern="^novo_modo_"))
    app.add_handler(CallbackQueryHandler(placeholder_callback, pattern="^placeholder_callback$"))

    # Handlers do menu de notifica√ß√µes
    app.add_handler(CallbackQueryHandler(abrir_menu_notificacoes, pattern="^abrir_menu_notificacoes$"))
    app.add_handler(CallbackQueryHandler(toggle_notificacao, pattern="^toggle_notificacao_"))
---
üìÑ chat_privado/admin_commands.py
---
import logging
import asyncio
from telegram import Update, error as telegram_error
from telegram.ext import ContextTypes
from typing import Optional

from core.database import (
    is_usuario_admin,
    resetar_estado_usuario_para_teste,
    buscar_configuracao_canal,
    deletar_configuracao_canal,
    marcar_configuracao_completa,
    buscar_usuario_por_id,
    buscar_usuario_por_email,
    conceder_plano_usuario,
    adicionar_slot_extra,
    remover_slots_extras,
    buscar_ids_assinantes_ativos,
    obter_estatisticas_gerais,
    atualizar_streamers_monitorados,
    resetar_cooldown_streamers,
    obter_plano_usuario,
    revogar_acesso_teste_expirado,
    resetar_flag_teste_gratuito,
)
from core.telethon_criar_canal import (
    deletar_canal_telegram,
    obter_detalhes_canal,
    adicionar_usuario_ao_canal,
    remover_usuario_do_canal
)
from configuracoes import TELEGRAM_CHAT_ID
from datetime import datetime

logger = logging.getLogger(__name__)

def _parse_user_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Optional[int]:
    """Extrai o user_id dos argumentos do comando."""
    if not context.args:
        update.message.reply_text("‚ùå Por favor, forne√ßa o ID do usu√°rio. Ex: /comando 123456789 ou /comando me")
        return None
    
    identifier = context.args[0]
    if identifier.lower() == 'me':
        return update.effective_user.id

    try:
        return int(identifier)
    except (ValueError, IndexError):
        update.message.reply_text("‚ùå ID de usu√°rio inv√°lido.")
        return None

async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de ajuda para administradores."""
    if not is_usuario_admin(update.effective_user.id):
        return
    
    texto = (
        "üõ†Ô∏è *Painel de Administrador*\n\n"
        "üìä *Estat√≠sticas e Comunica√ß√£o*\n"
        "`/stats` - V√™ as estat√≠sticas gerais do bot.\n"
        "`/channelstats <id | me | gratuito>` - V√™ stats de um canal.\n"
        "`/broadcast <mensagem>` - Envia mensagem para todos.\n"
        "`/message <id | me> <mensagem>` - Envia msg privada.\n\n"
        "üë§ *Gerenciamento de Usu√°rios*\n"
        "`/userinfo <id | me | email>` - V√™ resumo do usu√°rio.\n"
        "`/setplan <id | me> <Plano> [dias]` - Define um plano.\n"
        "_(Planos: Teste Gratuito, Mensal Solo, Mensal Plus, Anual Pro, SUPER, PARCEIRO)_\n"
        "`/trial <reset|revoke> <id>` - Gerencia o teste gratuito.\n"
        "`/addslot <id | me> [quantidade]` - Adiciona um ou mais slots extras.\n"
        "`/removeslots <id | me>` - Remove todos os slots extras.\n"
        "`/resetuser <id | me>` - Apaga TODOS os dados do usu√°rio.\n\n"
        "üì∫ *Gerenciamento de Canais*\n"
        "`/setcooldown <id | me>` - Reseta o timer de 1h para alterar streamers.\n"
        "`/setstreamers <id | me> <s1>...` - Altera a lista de streamers.\n"
        "`/createchannel <id | me>` - Verifica se um usu√°rio pode criar um canal.\n"
        "`/delchannel <id | me>` - Apaga o canal de um usu√°rio e reseta a config.\n"
        "`/channelmembers <add|remove> <owner_id|me> <target_id|me>` - Gerencia membros.\n"
    )
    await update.message.reply_text(texto, parse_mode="Markdown")

async def trial_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gerencia o status do teste gratuito de um usu√°rio."""
    if not is_usuario_admin(update.effective_user.id): return

    if len(context.args) != 2:
        await update.message.reply_text("‚ùå Uso: `/trial <reset|revoke> <user_id>`")
        return

    action = context.args[0].lower()
    try:
        user_id = int(context.args[1])
    except ValueError:
        await update.message.reply_text("‚ùå ID de usu√°rio inv√°lido.")
        return

    if action == 'reset':
        try:
            resetar_flag_teste_gratuito(user_id)
            await update.message.reply_text(f"‚úÖ Flag de teste gratuito resetada para o usu√°rio `{user_id}`. Ele poder√° pegar o teste novamente.")
        except ValueError as e:
            await update.message.reply_text(f"‚ùå Erro: {e}")
        except Exception as e:
            logger.error(f"Erro ao resetar flag de teste para {user_id}: {e}", exc_info=True)
            await update.message.reply_text(f"‚ùå Erro inesperado ao resetar flag: {e}")

    elif action == 'revoke':
        plano_atual = obter_plano_usuario(user_id)
        if plano_atual != "Teste Gratuito":
            await update.message.reply_text(f"‚ùå O usu√°rio `{user_id}` n√£o est√° em um plano de teste gratuito.")
            return
        
        await update.message.reply_text(f"‚è≥ Revogando acesso de teste para o usu√°rio `{user_id}`...")
        try:
            await revogar_acesso_teste_expirado(user_id)
            await update.message.reply_text(f"‚úÖ Acesso de teste do usu√°rio `{user_id}` foi revogado com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao revogar teste para {user_id}: {e}", exc_info=True)
            await update.message.reply_text(f"‚ùå Erro inesperado ao revogar o teste: {e}")

    else:
        await update.message.reply_text("‚ùå A√ß√£o inv√°lida. Use `reset` ou `revoke`.")

async def set_cooldown_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reseta o cooldown de 1 hora para altera√ß√£o de streamers de um usu√°rio."""
    if not is_usuario_admin(update.effective_user.id): return

    user_id = _parse_user_id(update, context)
    if not user_id: return

    try:
        resetar_cooldown_streamers(user_id)
        await update.message.reply_text(f"‚úÖ Cooldown para altera√ß√£o de streamers resetado para o usu√°rio `{user_id}`. Ele j√° pode remover streamers novamente.")
    except ValueError as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")
    except Exception as e:
        logger.error(f"Erro ao resetar cooldown para {user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao resetar cooldown: {e}")

async def reset_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reseta completamente um usu√°rio para testes."""
    if not is_usuario_admin(update.effective_user.id):
        return
    
    user_id = _parse_user_id(update, context)
    if not user_id:
        return

    await update.message.reply_text(f"‚ö†Ô∏è ATEN√á√ÉO: Isso apagar√° TODOS os dados do usu√°rio `{user_id}`. Aguarde...")
    try:
        await resetar_estado_usuario_para_teste(user_id)
        await update.message.reply_text(f"‚úÖ Usu√°rio `{user_id}` resetado com sucesso.")
    except Exception as e:
        logger.error(f"Erro ao resetar usu√°rio {user_id}: {e}")
        await update.message.reply_text(f"‚ùå Erro ao resetar usu√°rio: {e}")

async def create_channel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Verifica se um usu√°rio pode criar um canal."""
    if not is_usuario_admin(update.effective_user.id):
        return

    user_id = _parse_user_id(update, context)
    if not user_id:
        return

    # 1. Verificar se o usu√°rio tem plano ativo
    usuario = buscar_usuario_por_id(user_id)
    if not usuario or usuario.get('nivel') != 2:
        await update.message.reply_text(f"‚ùå N√£o √© poss√≠vel criar o canal. O usu√°rio `{user_id}` n√£o √© um assinante ativo.")
        return

    # 2. Verificar se j√° n√£o existe um canal
    config = buscar_configuracao_canal(user_id)
    if config and config.get('id_canal_telegram'):
        await update.message.reply_text(f"‚ùå O usu√°rio `{user_id}` j√° possui um canal configurado.")
        return

    await update.message.reply_text(
        f"‚úÖ Verifica√ß√£o bem-sucedida. O usu√°rio `{user_id}` √© um assinante ativo e n√£o possui um canal.\n\n"
        "Pe√ßa para que ele use o comando /start para iniciar a configura√ß√£o."
    )

async def delete_channel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Apaga o canal de um usu√°rio e reseta seu status de configura√ß√£o."""
    if not is_usuario_admin(update.effective_user.id):
        return

    user_id = _parse_user_id(update, context)
    if not user_id:
        return

    await update.message.reply_text(f"‚è≥ Apagando canal e resetando configura√ß√£o para o usu√°rio `{user_id}`. Aguarde...")

    try:
        config = buscar_configuracao_canal(user_id)
        if config and config.get('id_canal_telegram'):
            id_canal = int(config['id_canal_telegram'])
            await deletar_canal_telegram(id_canal)
            logger.info(f"Canal {id_canal} do usu√°rio {user_id} deletado via admin.")
        
        # Reseta o estado de configura√ß√£o no banco de dados
        deletar_configuracao_canal(user_id)
        marcar_configuracao_completa(user_id, False)

        await update.message.reply_text(f"‚úÖ Canal do usu√°rio `{user_id}` removido e configura√ß√£o resetada. Ele pode usar /start para configurar novamente.")

    except Exception as e:
        logger.error(f"Erro ao deletar canal para o usu√°rio {user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao deletar o canal: {e}")

async def user_info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe um resumo completo dos dados de um usu√°rio."""
    if not is_usuario_admin(update.effective_user.id): return

    if not context.args:
        await update.message.reply_text("‚ùå Uso: `/userinfo <id | email>`")
        return

    identifier = context.args[0]
    usuario = None
    user_id = None

    if identifier.isdigit():
        user_id = int(identifier)
        usuario = buscar_usuario_por_id(user_id)
    else:
        usuario = buscar_usuario_por_email(identifier)
        if usuario:
            user_id = usuario['telegram_id']

    if not usuario:
        await update.message.reply_text(f"‚ùå Usu√°rio com identificador `{identifier}` n√£o encontrado em nosso banco de dados.")
        return

    config = buscar_configuracao_canal(user_id)

    info = [f"‚ÑπÔ∏è *Informa√ß√µes do Usu√°rio: `{user_id}`*"]
    info.append(f"üë§ *Nome:* {usuario.get('nome', 'N/A')}")
    info.append(f"üìß *Email:* `{usuario.get('email', 'N/A')}`")
    info.append(f"üì¶ *Plano:* {usuario.get('plano_assinado', 'Nenhum')}")
    
    data_exp_str = usuario.get('data_expiracao')
    data_exp_fmt = datetime.fromisoformat(data_exp_str).strftime('%d/%m/%Y %H:%M') if data_exp_str else "N/A"
    info.append(f"üóìÔ∏è *Expira em:* {data_exp_fmt}")

    if config:
        id_canal = config.get('id_canal_telegram')
        info.append(f"üì∫ *Canal:* {'Criado (`' + str(id_canal) + '`)' if id_canal else 'N√£o criado'}")
        info.append("\n*--- Configura√ß√£o do Canal ---*")
        info.append(f"üß† *Modo:* `{config.get('modo_monitoramento', 'N/A')}`")
        streamers = [s for s in config.get('streamers_monitorados', '').split(',') if s]
        num_streamers = len(streamers)
        info.append(f"üé∞ *Slots:* {num_streamers}/{config.get('slots_ativos', 'N/A')}")
        info.append(f"üì° *Streamers:* `{' | '.join(streamers) if streamers else 'Nenhum'}`")
        if config.get('modo_monitoramento') == 'MANUAL':
            info.append(f"  - *M√≠n. Clipes:* `{config.get('manual_min_clips', 'N/A')}`")
            info.append(f"  - *Intervalo:* `{config.get('manual_interval_sec', 'N/A')}`s")
    else:
        info.append("üì∫ *Canal:* N√£o criado")

    await update.message.reply_text("\n".join(info), parse_mode="Markdown")

async def set_plan_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Define ou concede um plano de assinatura a um usu√°rio."""
    if not is_usuario_admin(update.effective_user.id): return

    if len(context.args) < 2:
        await update.message.reply_text("‚ùå Uso: `/setplan <user_id> <Nome do Plano> [dias]`\nEx: `/setplan 123 Mensal Solo 30`")
        return
    
    try:
        user_id = int(context.args[0])
        # Verifica se o √∫ltimo argumento √© um n√∫mero (dias)
        if context.args[-1].isdigit() and len(context.args) > 2:
            days = int(context.args[-1])
            plan_name = " ".join(context.args[1:-1])
        else: # Se n√£o, assume dias padr√£o e o resto √© o nome do plano
            days = 31
            plan_name = " ".join(context.args[1:])
        
        if not plan_name:
             await update.message.reply_text("‚ùå Nome do plano n√£o fornecido.")
             return

        # Verifica se o usu√°rio existe
        if not buscar_usuario_por_id(user_id):
            await update.message.reply_text(f"‚ùå Usu√°rio com ID `{user_id}` n√£o encontrado. Pe√ßa para ele dar /start primeiro.")
            return

        conceder_plano_usuario(user_id, plan_name, days)
        await update.message.reply_text(f"‚úÖ Plano *{plan_name}* concedido ao usu√°rio `{user_id}` por *{days} dias*.")

    except ValueError:
        await update.message.reply_text("‚ùå ID de usu√°rio ou n√∫mero de dias inv√°lido.")
    except Exception as e:
        logger.error(f"Erro ao conceder plano para {context.args[0]}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao conceder plano: {e}")

async def add_slot_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Adiciona um ou mais slots extras para um usu√°rio."""
    if not is_usuario_admin(update.effective_user.id): return

    if not context.args:
        await update.message.reply_text("‚ùå Uso: `/addslot <user_id> [quantidade]`")
        return

    try:
        user_id = int(context.args[0])
        quantidade = int(context.args[1]) if len(context.args) > 1 else 1
        if quantidade <= 0:
            await update.message.reply_text("‚ùå A quantidade deve ser um n√∫mero positivo.")
            return
    except (ValueError, IndexError):
        await update.message.reply_text("‚ùå ID de usu√°rio ou quantidade inv√°lida.")
        return

    # Verifica se o usu√°rio tem uma configura√ß√£o de canal, pois os slots s√£o armazenados l√°
    config = buscar_configuracao_canal(user_id)
    if not config:
        await update.message.reply_text(f"‚ùå N√£o √© poss√≠vel adicionar slot. O usu√°rio `{user_id}` n√£o possui um canal configurado.")
        return
    try:
        adicionar_slot_extra(user_id, quantidade)
        await update.message.reply_text(f"‚úÖ {quantidade} slot(s) extra(s) adicionado(s) com sucesso para o usu√°rio `{user_id}`.")
    except Exception as e:
        logger.error(f"Erro ao adicionar slot para {user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao adicionar slot: {e}")

async def remove_slots_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Remove todos os slots extras de um usu√°rio, resetando para o valor base do plano."""
    if not is_usuario_admin(update.effective_user.id): return

    user_id = _parse_user_id(update, context)
    if not user_id: return

    try:
        remover_slots_extras(user_id)
        await update.message.reply_text(f"‚úÖ Todos os slots extras do usu√°rio `{user_id}` foram removidos com sucesso.")
    except ValueError as e: # Captura o erro espec√≠fico da fun√ß√£o do DB
        await update.message.reply_text(f"‚ùå Erro: {e}")
    except Exception as e:
        logger.error(f"Erro ao remover slots extras para {user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao remover slots extras: {e}")

async def manage_channel_members_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Adiciona ou remove um usu√°rio de um canal de cliente."""
    if not is_usuario_admin(update.effective_user.id): return

    if len(context.args) != 3:
        await update.message.reply_text("‚ùå Uso: `/channelmembers <add|remove> <owner_user_id> <target_user_id>`")
        return

    action = context.args[0].lower()
    if action not in ['add', 'remove']:
        await update.message.reply_text("‚ùå A√ß√£o inv√°lida. Use 'add' ou 'remove'.")
        return

    try:
        owner_user_id = int(context.args[1])
        target_user_id = int(context.args[2])
    except ValueError:
        await update.message.reply_text("‚ùå IDs de usu√°rio devem ser n√∫meros.")
        return

    config = buscar_configuracao_canal(owner_user_id)
    if not config or not config.get('id_canal_telegram'):
        await update.message.reply_text(f"‚ùå O usu√°rio propriet√°rio `{owner_user_id}` n√£o possui um canal configurado.")
        return
    
    channel_id = int(config['id_canal_telegram'])
    await update.message.reply_text(f"‚è≥ Processando... A√ß√£o: {action}, Alvo: {target_user_id}, Canal de: {owner_user_id} ({channel_id})")

    try:
        if action == 'add':
            success, message = await adicionar_usuario_ao_canal(channel_id, target_user_id)
        else: # remove
            success, message = await remover_usuario_do_canal(channel_id, target_user_id)
        
        if success:
            await update.message.reply_text(f"‚úÖ Sucesso! {message}")
        else:
            await update.message.reply_text(f"‚ùå Falha! {message}")
    except Exception as e:
        logger.error(f"Erro ao gerenciar membros do canal {channel_id} para o alvo {target_user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Ocorreu um erro inesperado: {e}")

async def set_streamers_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """(Admin) Altera a lista de streamers de um cliente, substituindo a atual."""
    if not is_usuario_admin(update.effective_user.id): return

    if len(context.args) < 2:
        await update.message.reply_text("‚ùå Uso: `/setstreamers <user_id> <streamer1> [streamer2]...`\nIsso substituir√° a lista atual.")
        return

    try:
        user_id = int(context.args[0])
        new_streamers = [s.strip().replace('@', '') for s in context.args[1:]]
    except ValueError:
        await update.message.reply_text("‚ùå ID de usu√°rio inv√°lido.")
        return

    config = buscar_configuracao_canal(user_id)
    if not config:
        await update.message.reply_text(f"‚ùå O usu√°rio `{user_id}` n√£o possui um canal configurado.")
        return

    try:
        atualizar_streamers_monitorados(user_id, new_streamers)
        await update.message.reply_text(f"‚úÖ Lista de streamers do usu√°rio `{user_id}` atualizada para: `{', '.join(new_streamers)}`")
    except Exception as e:
        logger.error(f"Erro ao alterar streamers para {user_id} via admin: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao atualizar streamers: {e}")

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia uma mensagem para todos os assinantes ativos."""
    if not is_usuario_admin(update.effective_user.id): return

    if not context.args:
        await update.message.reply_text("‚ùå Uso: `/broadcast <sua mensagem>`")
        return

    mensagem = " ".join(context.args)
    
    ids_assinantes = buscar_ids_assinantes_ativos()
    if not ids_assinantes:
        await update.message.reply_text("‚ÑπÔ∏è Nenhum assinante ativo encontrado para enviar a mensagem.")
        return

    await update.message.reply_text(f"üì¢ Iniciando envio da mensagem para {len(ids_assinantes)} assinantes...")

    sucessos = 0
    falhas = 0

    for user_id in ids_assinantes:
        try:
            await context.bot.send_message(chat_id=user_id, text=mensagem, parse_mode="Markdown")
            sucessos += 1
            await asyncio.sleep(0.1) # Pausa para n√£o sobrecarregar a API
        except telegram_error.Forbidden:
            logger.warning(f"Falha no broadcast para {user_id}: Bot foi bloqueado pelo usu√°rio.")
            falhas += 1
        except Exception as e:
            logger.error(f"Falha no broadcast para {user_id}: {e}")
            falhas += 1

    await update.message.reply_text(
        f"‚úÖ Broadcast finalizado!\n\n"
        f"- Enviado com sucesso para: {sucessos} usu√°rios.\n"
        f"- Falhas (usu√°rios que bloquearam o bot): {falhas} usu√°rios."
    )

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe estat√≠sticas gerais do bot."""
    if not is_usuario_admin(update.effective_user.id): return

    stats = obter_estatisticas_gerais()

    texto = (
        "üìä *Estat√≠sticas do Clipador*\n\n"
        f"üë• *Total de Usu√°rios:* {stats['total_usuarios']}\n"
        f"‚úÖ *Assinantes Ativos:* {stats['assinantes_ativos']}\n"
        f"üì∫ *Canais Monitorados:* {stats['canais_monitorados']}"
    )

    await update.message.reply_text(texto, parse_mode="Markdown")

async def message_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia uma mensagem privada para um usu√°rio espec√≠fico."""
    if not is_usuario_admin(update.effective_user.id): return

    if len(context.args) < 2:
        await update.message.reply_text("‚ùå Uso: `/message <user_id> <sua mensagem>`")
        return

    try:
        user_id = int(context.args[0])
        mensagem = " ".join(context.args[1:])

        await context.bot.send_message(chat_id=user_id, text=mensagem, parse_mode="Markdown")
        await update.message.reply_text(f"‚úÖ Mensagem enviada com sucesso para o usu√°rio `{user_id}`.")

    except ValueError:
        await update.message.reply_text("‚ùå ID de usu√°rio inv√°lido.")
    except telegram_error.BadRequest as e:
        await update.message.reply_text(f"‚ùå Falha ao enviar: {e}. O usu√°rio pode n√£o ter iniciado o bot.")
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem para {context.args[0]}: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Erro ao enviar mensagem: {e}")

async def channel_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe estat√≠sticas detalhadas de um canal espec√≠fico."""
    if not is_usuario_admin(update.effective_user.id): return

    if not context.args:
        await update.message.reply_text("‚ùå Uso: `/channelstats <user_id>` ou `/channelstats gratuito`")
        return

    identifier = context.args[0]
    info = []

    if identifier.lower() == 'gratuito':
        info.append("üìä *Estat√≠sticas do Canal Gratuito*")
        channel_id = int(TELEGRAM_CHAT_ID)
        
        # Detalhes do canal (membros)
        detalhes = await obter_detalhes_canal(channel_id)
        info.append(f"üë• *Membros:* {detalhes['participants_count'] if detalhes else 'N/A'}")

        # Requisi√ß√µes
        requests = context.bot_data.get('free_channel_requests', 'N/A')
        info.append(f"üìà *Requisi√ß√µes (√∫ltimo ciclo):* {requests}")

        # Streamers
        streamers = context.bot_data.get('free_channel_streamers', [])
        info.append(f"üì° *Streamers Monitorados ({len(streamers)}):*")
        if streamers:
            info.append(f"`{' | '.join(streamers)}`")
        else:
            info.append("Nenhum")

    elif identifier.isdigit():
        user_id = int(identifier)
        config = buscar_configuracao_canal(user_id)
        if not config or not config.get('id_canal_telegram'):
            await update.message.reply_text(f"‚ùå Nenhuma configura√ß√£o de canal encontrada para o usu√°rio `{user_id}`.")
            return

        info.append(f"üìä *Estat√≠sticas do Canal do Usu√°rio `{user_id}`*")
        channel_id = int(config['id_canal_telegram'])

        detalhes = await obter_detalhes_canal(channel_id)
        info.append(f"üë• *Membros:* {detalhes['participants_count'] if detalhes else 'N/A'}")
        requests = context.bot_data.get(f'client_{user_id}_requests', 'N/A')
        info.append(f"üìà *Requisi√ß√µes (√∫ltimo ciclo):* {requests}")
        info.append(f"üß† *Modo:* `{config.get('modo_monitoramento', 'N/A')}`")
        streamers = [s for s in config.get('streamers_monitorados', '').split(',') if s]
        info.append(f"üì° *Streamers Monitorados ({len(streamers)}):* `{' | '.join(streamers) if streamers else 'Nenhum'}`")
        client_id = config.get('twitch_client_id', 'N/A')
        secret = config.get('twitch_client_secret', 'N/A')
        secret_masked = f"{secret[:4]}...{secret[-4:]}" if len(secret) > 8 else secret
        info.append("\n*--- Credenciais Twitch ---*")
        info.append(f"üîë *Client ID:* `{client_id}`")
        info.append(f"üîí *Client Secret:* `{secret_masked}`")

    else:
        await update.message.reply_text("‚ùå Identificador inv√°lido. Use um ID de usu√°rio ou a palavra 'gratuito'.")
        return

    await update.message.reply_text("\n".join(info), parse_mode="Markdown")
---
üìÑ chat_privado/main.py
---
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from telegram.ext import Application
from telegram.request import HTTPXRequest
from core.ambiente import TELEGRAM_BOT_TOKEN
import asyncio
from core.monitor_clientes import iniciar_monitoramento_clientes
from canal_gratuito.main import main as iniciar_monitor_gratuito

async def post_initialization(application: Application):
    """Fun√ß√£o a ser executada ap√≥s a inicializa√ß√£o do bot."""
    print("üì∫ Iniciando monitor do canal gratuito...")
    # Inicia o monitoramento do canal gratuito em background
    asyncio.create_task(iniciar_monitor_gratuito(application))

    # Inicia o monitoramento de clientes em background
    asyncio.create_task(iniciar_monitoramento_clientes(application))

def iniciar_chat_privado():
    # Configura√ß√£o de request para get_updates (long polling)
    # N√£o precisa de um pool grande, mas de um read_timeout alto
    get_updates_request = HTTPXRequest(connect_timeout=10.0, read_timeout=60.0)

    # Configura√ß√£o de request para todas as outras chamadas de API
    # Pool maior para lidar com monitores concorrentes e outras tarefas
    api_request = HTTPXRequest(connect_timeout=10.0, read_timeout=10.0, connection_pool_size=50)

    builder = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .request(api_request)
        .get_updates_request(get_updates_request)
    )

    builder.post_init(post_initialization)
    app = builder.build()

    from chat_privado.handlers import registrar_handlers  # agora centralizado
    registrar_handlers(app)
    print("üí¨ Iniciando bot principal (chat privado e monitores)...")
    app.run_polling()

---
üìÑ chat_privado/menus/menu_notificacoes.py
---
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler

from core.database import obter_ou_criar_config_notificacao, atualizar_config_notificacao

logger = logging.getLogger(__name__)

# Fun√ß√£o auxiliar para construir o menu
async def _construir_menu_notificacoes(telegram_id: int) -> tuple[str, InlineKeyboardMarkup]:
    """Constr√≥i a mensagem e os bot√µes para o menu de notifica√ß√µes."""
    config = obter_ou_criar_config_notificacao(telegram_id)

    status_online = "Ativado ‚úÖ" if config.get('notificar_online') else "Desativado ‚ùå"

    texto = (
        "üîî *Central de Notifica√ß√µes*\n\n"
        "Gerencie aqui os avisos que voc√™ recebe no seu canal.\n\n"
        "üîπ *Streamer Online:* Receba um aviso quando um streamer monitorado iniciar a transmiss√£o."
    )

    botoes = [
        [InlineKeyboardButton(f"Streamer Online: {status_online}", callback_data="toggle_notificacao_online")],
        [InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")] # Volta para o menu de gerenciamento
    ]

    return texto, InlineKeyboardMarkup(botoes)

# Handler principal para abrir o menu
async def abrir_menu_notificacoes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de gerenciamento de notifica√ß√µes."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    texto, keyboard = await _construir_menu_notificacoes(telegram_id)

    await query.edit_message_text(
        text=texto,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

# Handler para ativar/desativar as notifica√ß√µes
async def toggle_notificacao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ativa ou desativa um tipo de notifica√ß√£o."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id
    tipo_notificacao = query.data.replace("toggle_notificacao_", "")

    config_atual = obter_ou_criar_config_notificacao(telegram_id)

    if tipo_notificacao == "online":
        novo_status = not config_atual.get('notificar_online')
        atualizar_config_notificacao(telegram_id, notificar_online=novo_status)
        logger.info(f"Notifica√ß√£o 'online' alterada para {novo_status} para o usu√°rio {telegram_id}.")
    
    # Reconstr√≥i e edita o menu para refletir a mudan√ßa
    texto, keyboard = await _construir_menu_notificacoes(telegram_id)
    await query.edit_message_text(
        text=texto,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )
---
üìÑ chat_privado/menus/menu_canal.py
---
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
from chat_privado.usuarios import get_nivel_usuario, registrar_usuario, atualizar_usuario, remover_usuario, listar_usuarios

# Estados da cria√ß√£o de canal
ESPERANDO_CLIENT_ID, ESPERANDO_CLIENT_SECRET, ESPERANDO_BOT_TOKEN, ESPERANDO_CHAT_ID, ESPERANDO_STREAMER = range(5)

dados_temp = {}

# üîß In√≠cio do funil de cria√ß√£o
async def criar_canal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if get_nivel_usuario(user_id) != 9:
        await update.message.reply_text("üö´ Comando reservado para administradores.")
        return ConversationHandler.END

    await update.message.reply_text("üîß Vamos criar um novo canal!\n\nInforme o TWITCH_CLIENT_ID:")
    dados_temp[user_id] = {}
    return ESPERANDO_CLIENT_ID

async def receber_client_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    dados_temp[user_id]["TWITCH_CLIENT_ID"] = update.message.text
    await update.message.reply_text("‚úÖ Agora informe o TWITCH_CLIENT_SECRET:")
    return ESPERANDO_CLIENT_SECRET

async def receber_client_secret(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    dados_temp[user_id]["TWITCH_CLIENT_SECRET"] = update.message.text
    await update.message.reply_text("ü§ñ Agora informe o TELEGRAM_BOT_TOKEN:")
    return ESPERANDO_BOT_TOKEN

async def receber_bot_token(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    dados_temp[user_id]["TELEGRAM_BOT_TOKEN"] = update.message.text
    await update.message.reply_text("üì¢ Agora informe o TELEGRAM_CHAT_ID:")
    return ESPERANDO_CHAT_ID

async def receber_chat_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    dados_temp[user_id]["TELEGRAM_CHAT_ID"] = update.message.text
    await update.message.reply_text("üéÆ Por fim, qual streamer deseja monitorar?")
    return ESPERANDO_STREAMER

async def receber_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    dados_temp[user_id]["STREAMER"] = update.message.text

    info = dados_temp[user_id]
    resumo = (
        f"‚úÖ Canal configurado com sucesso!\n\n"
        f"TWITCH_CLIENT_ID: {info['TWITCH_CLIENT_ID']}\n"
        f"TWITCH_CLIENT_SECRET: {info['TWITCH_CLIENT_SECRET'][:4]}***\n"
        f"BOT_TOKEN: {info['TELEGRAM_BOT_TOKEN'][:4]}***\n"
        f"CHAT_ID: {info['TELEGRAM_CHAT_ID']}\n"
        f"STREAMER: {info['STREAMER']}"
    )

    await update.message.reply_text(resumo)
    del dados_temp[user_id]
    return ConversationHandler.END

async def cancelar_criacao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå Cria√ß√£o de canal cancelada.")
    return ConversationHandler.END

---
üìÑ chat_privado/menus/menu_configurar_canal.py
---
import os
import sqlite3
import requests
import asyncio
import logging
import httpx # Importar httpx para capturar erros espec√≠ficos
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, error as telegram_error
from telegram.ext import (
    CallbackContext, CommandHandler, MessageHandler,
    CallbackQueryHandler, ConversationHandler, filters, ContextTypes
)
from core.ambiente import MERCADO_PAGO_ACCESS_TOKEN
from core.database import (
    buscar_configuracao_canal,
    salvar_progresso_configuracao,
    limpar_progresso_configuracao,
    conectar,
    buscar_link_canal,
    marcar_configuracao_completa,
    salvar_configuracao_canal_completa,
    is_configuracao_completa,
    obter_plano_usuario,
    adicionar_usuario, verificar_aviso_enviado, marcar_aviso_enviado
)
from configuracoes import SUPPORT_USERNAME, CANAL_GRATUITO_ID, LINK_CANAL_GRATUITO
from chat_privado.usuarios import get_nivel_usuario
from core.telethon_criar_canal import criar_canal_telegram
from canal_gratuito.core.twitch import TwitchAPI # Importa a TwitchAPI para valida√ß√£o
from core.image_utils import gerar_imagem_canal_personalizada

logger = logging.getLogger(__name__)

async def limpar_e_enviar_nova_etapa(update: Update, context: ContextTypes.DEFAULT_TYPE, texto: str, botoes: list, parse_mode="Markdown", usar_force_reply=False):
    # Identify the message that triggered the current callback, if any
    current_message_id = None
    if hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
        current_message_id = update.callback_query.message.message_id

    # Apagar mensagens antigas armazenadas
    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        if msg_id != current_message_id: # Don't delete the current message if we intend to edit it
            try:
                await context.bot.delete_message(chat_id=update.effective_user.id, message_id=msg_id)
            except Exception: # Catch specific exceptions if possible, e.g., MessageCantBeDeleted
                pass
    context.user_data["mensagens_para_apagar"] = []

    # Tentar editar a mensagem se for callback, sen√£o enviar nova
    reply_markup = InlineKeyboardMarkup(botoes) if botoes else None
    if usar_force_reply:
        from telegram import ForceReply
        reply_markup = ForceReply(selective=True)

    try:
        if hasattr(update, 'callback_query') and update.callback_query:
            await update.callback_query.answer()
            nova_msg = await update.callback_query.edit_message_text(
                text=texto,
                reply_markup=reply_markup,
                parse_mode=parse_mode
            )
        else:
            nova_msg = await update.message.reply_text(
                text=texto,
                reply_markup=reply_markup,
                parse_mode=parse_mode
            )
        context.user_data["mensagens_para_apagar"] = [nova_msg.message_id]
    except Exception: # Catch specific exceptions if possible, e.g., BadRequest
        # Fallback para enviar uma nova mensagem se a edi√ß√£o falhar
        target_message = update.effective_message
        nova_msg = await target_message.reply_text(
            text=texto,
            reply_markup=reply_markup,
            parse_mode=parse_mode
        )
        context.user_data["mensagens_para_apagar"] = [nova_msg.message_id]

ESPERANDO_CREDENCIAIS, ESPERANDO_STREAMERS, ESCOLHENDO_MODO, CONFIG_MANUAL_CLIPS, CONFIG_MANUAL_INTERVALO = range(5)
CONFIGURANDO_PARCEIRO, ESPERANDO_USERNAME_CHEFE, ESCOLHENDO_MODO_PARCEIRO = range(5, 8)

def verificar_status_pagamento(pagamento_id: int) -> str:
    """
    Verifica o status de pagamento no Mercado Pago.
    Esta fun√ß√£o parece ser espec√≠fica para Mercado Pago e n√£o Kirvano.
    Se voc√™ est√° usando Kirvano, esta fun√ß√£o pode ser removida ou adaptada.
    """
    # Nota: Esta fun√ß√£o parece ser para Mercado Pago. Se voc√™ est√° usando Kirvano,
    # a l√≥gica de verifica√ß√£o de pagamento deve vir do banco de dados,
    # que √© atualizado pelo webhook da Kirvano.
    # Se voc√™ n√£o usa Mercado Pago, esta fun√ß√£o e suas chamadas podem ser removidas.
    # Mantendo por enquanto para compatibilidade com o c√≥digo existente.
    if not MERCADO_PAGO_ACCESS_TOKEN:
        logger.error("MERCADO_PAGO_ACCESS_TOKEN n√£o configurado. N√£o √© poss√≠vel verificar pagamento.")
        return "erro"
    url = f"https://api.mercadopago.com/v1/payments/{pagamento_id}"
    headers = {"Authorization": f"Bearer {MERCADO_PAGO_ACCESS_TOKEN}"}
    try:
        response = requests.get(url, headers=headers)
        return response.json().get("status", "erro")
    except Exception as e:
        logger.error(f"Erro ao verificar pagamento: {e}")
        return "erro"

async def verificar_pagamento(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        await update.callback_query.delete_message()
    except:
        pass
    query = update.callback_query
    await query.answer()
    pagamento_id = context.user_data.get("id_pagamento")

    if not pagamento_id:
        await query.edit_message_text("‚ùå N√£o foi poss√≠vel validar o pagamento. Tente novamente.")
        return

    status = verificar_status_pagamento(pagamento_id)
    if status == "approved":
        # Apagar todas as mensagens anteriores, inclusive o menu de planos
        for msg_id in context.user_data.get("mensagens_para_apagar", []):
            try:
                await context.bot.delete_message(chat_id=query.from_user.id, message_id=msg_id)
            except:
                pass
        context.user_data["mensagens_para_apagar"] = []
        # Armazene a mensagem anterior de plano selecionado para posterior exclus√£o
        context.user_data["mensagem_plano_selecionado"] = query.message.message_id
        # Apagar a mensagem de plano selecionado com bot√µes, se existir
        if "mensagem_plano_selecionado" in context.user_data:
            try:
                await context.bot.delete_message(chat_id=query.from_user.id, message_id=context.user_data["mensagem_plano_selecionado"])
            except:
                pass
            context.user_data.pop("mensagem_plano_selecionado", None)
        # Recuperar o email de pagamento
        email_pagamento = context.user_data.get("email_pagamento", "desconhecido")
        await iniciar_configuracao_pos_pagamento(update, context, email_pagamento)
    elif status == "pending":
        await query.edit_message_text(
            "‚è≥ Pagamento ainda *pendente*. Clique novamente no bot√£o abaixo ap√≥s aprova√ß√£o.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ J√° paguei", callback_data="verificar_pagamento")],
                [InlineKeyboardButton("üîô Voltar", callback_data="menu_0")]
            ]),
            parse_mode="Markdown"
        )
    else:
        await query.edit_message_text(
            "‚ùå Pagamento *n√£o aprovado* ou expirado. Tente novamente.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data="menu_3")]
            ]),
            parse_mode="Markdown"
        )

async def menu_configurar_canal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # This function is the entry point for the configuration funnel.
    # Esta fun√ß√£o foi refatorada para permitir a continua√ß√£o da configura√ß√£o.
    try:
        await update.callback_query.delete_message()
    except Exception:
        pass

    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        try:
            await context.bot.delete_message(chat_id=query.from_user.id, message_id=msg_id)
        except:
            pass
    context.user_data["mensagens_para_apagar"] = []

    # 1. Verifica se a configura√ß√£o j√° est√° totalmente completa
    telegram_id = update.effective_user.id # Ensure telegram_id is defined here
    if is_configuracao_completa(telegram_id):
        link_canal = buscar_link_canal(telegram_id)
        texto = "‚öôÔ∏è Seu canal j√° est√° configurado.\n\nO que deseja fazer?"
        botoes = [
            [InlineKeyboardButton("üëÅ Abrir canal", url=link_canal if link_canal else "https://t.me/")],
            [InlineKeyboardButton("üîß Gerenciar canal", callback_data="abrir_menu_gerenciar_canal")],
            [InlineKeyboardButton("‚ÑπÔ∏è Ver plano", callback_data="ver_plano_atual")], # This callback is in menu_gerenciamento.py
            [InlineKeyboardButton("üîô Voltar", callback_data="menu_0")]
        ]
        await limpar_e_enviar_nova_etapa(update, context, texto, botoes, parse_mode=None)
        return

    # 2. Se n√£o estiver completa, SEMPRE mostra o tutorial inicial.
    # A l√≥gica de "retomar de onde parou" ser√° tratada dentro das fun√ß√µes de cada etapa
    # (iniciar_envio_twitch, iniciar_envio_streamers, escolher_modo_monitoramento)
    # que ser√£o chamadas via bot√µes ou comandos.
    texto = (
        "üë£ *Passo 1* ‚Äî Crie um aplicativo na Twitch:\n"
        "Acesse o painel de desenvolvedor da Twitch e crie um novo aplicativo:\n"
        "https://dev.twitch.tv/console/apps\n\n"
        "Preencha os campos da seguinte forma:\n"
        "‚Ä¢ *Nome:* `Clipador`\n"
        "‚Ä¢ *URL de redirecionamento OAuth:* `https://clipador.com.br/redirect`\n"
        "‚Ä¢ *Categoria:* `Chat Bot`\n"
        "‚Ä¢ *Tipo de cliente:* **Confidencial**\n\n"
        "Ap√≥s criar, na tela de gerenciamento do aplicativo:\n"
        "1. Copie o *ID do cliente*.\n"
        "2. Clique no bot√£o **`[Novo segredo]`** para gerar o seu *Segredo do cliente*. Copie-o e guarde em um local seguro, pois ele s√≥ √© exibido uma vez!\n\n"
        "Quando estiver com os dois dados em m√£os, clique no bot√£o abaixo para envi√°-los."
    )
    botoes = [
        [InlineKeyboardButton("üì® Enviar dados da Twitch", callback_data="enviar_twitch")]
    ]

    # Check if there's partial data to inform the user they are resuming
    configuracao = buscar_configuracao_canal(telegram_id)
    if configuracao:
        # Carrega dados parciais para o contexto para continuidade
        context.user_data["twitch_id"] = configuracao.get("twitch_client_id")
        context.user_data["twitch_secret"] = configuracao.get("twitch_client_secret")
        db_streamers_str = configuracao.get("streamers_monitorados")
        context.user_data["streamers"] = [s.strip() for s in db_streamers_str.split(',') if s.strip()] if db_streamers_str else []
        context.user_data["modo_monitoramento"] = configuracao.get("modo_monitoramento")

        plano_assinado = obter_plano_usuario(telegram_id)
        limite_streamers = 1 # Padr√£o para Mensal Solo
        if plano_assinado == "Mensal Plus":
            limite_streamers = 3
        elif plano_assinado == "Anual Pro":
            limite_streamers = 4  # 3 do plano + 1 de b√¥nus
        elif plano_assinado == "PARCEIRO":
            limite_streamers = 1
        elif plano_assinado == "SUPER":
            limite_streamers = 999
        context.user_data["limite_streamers"] = limite_streamers

        # If any part of the configuration is already saved, add a "resume" message
        if configuracao.get("twitch_client_id") or configuracao.get("streamers_monitorados") or configuracao.get("modo_monitoramento"):
            texto = "‚úÖ Voc√™ est√° retomando a configura√ß√£o do seu canal.\n\n" + texto
            # Add a button to jump directly to the next incomplete step if they prefer
            # This makes the "resume" more explicit and user-friendly.
            if not configuracao.get("twitch_client_id") or not configuracao.get("twitch_client_secret"):
                # If credentials are missing, the "Enviar dados da Twitch" button is already there.
                # No need for a separate "Continuar Credenciais" button.
                pass
            elif not configuracao.get("streamers_monitorados"):
                botoes.insert(0, [InlineKeyboardButton("‚û°Ô∏è Continuar Streamers", callback_data="iniciar_envio_streamers_callback")]) # New callback for this
            elif not configuracao.get("modo_monitoramento"):
                botoes.insert(0, [InlineKeyboardButton("‚û°Ô∏è Continuar Modo", callback_data="escolher_modo_monitoramento_callback")]) # New callback for this

    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)

async def iniciar_configuracao_pos_pagamento(update: Update, context: ContextTypes.DEFAULT_TYPE, email_pagamento: str = ""):
    await update.callback_query.answer()
    # Apagar a mensagem de plano selecionado com bot√µes, se existir
    if "mensagem_plano_selecionado" in context.user_data:
        try:
            await context.bot.delete_message(chat_id=update.effective_user.id, message_id=context.user_data["mensagem_plano_selecionado"])
        except:
            pass
        context.user_data.pop("mensagem_plano_selecionado", None)
    # Limpar mensagens salvas e remover qualquer mensagem do tipo "Plano selecionado"
    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        try:
            await context.bot.delete_message(chat_id=update.effective_user.id, message_id=msg_id)
        except:
            pass
    context.user_data["mensagens_para_apagar"] = []
    await context.bot.send_message(
        chat_id=update.effective_user.id,
        text=f"üîì Produto gratuito ativado para admin.\nPlano: *{context.user_data.get('nome_plano', 'Indefinido')}*.\nüìß Ativado com: `{email_pagamento}`\n\nClique no bot√£o abaixo para configurar seu canal personalizado:",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚öôÔ∏è Continuar configura√ß√£o", callback_data="continuar_configuracao")]
        ]),
        parse_mode="Markdown"
    )
    await menu_configurar_canal(update, context)

async def iniciar_envio_twitch(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # N√£o apaga a mensagem anterior (o tutorial), apenas responde a ela.
    texto_instrucao = (
        "Envie suas credenciais da Twitch no formato abaixo, substituindo `SEU_ID_AQUI` e "
        "`SEU_SEGREDO_AQUI` pelos seus dados.\n\n"
        "`ID do cliente: SEU_ID_AQUI`\n`Segredo do cliente: SEU_SEGREDO_AQUI`"
    )
    from telegram import ForceReply
    # Usa reply_text na mensagem original do tutorial para criar um "fio" de conversa
    msg = await query.message.reply_text(
        text=texto_instrucao,
        reply_markup=ForceReply(selective=True),
        parse_mode="Markdown"
    )
    # Adiciona a nova mensagem √† lista de exclus√£o para a pr√≥xima etapa,
    # mas mant√©m a mensagem do tutorial.
    context.user_data.setdefault("mensagens_para_apagar", []).append(msg.message_id)
    return ESPERANDO_CREDENCIAIS

# New callback handlers to jump directly to a step from the main tutorial screen
async def iniciar_envio_streamers_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    # This will call the existing function that sends the streamer prompt with ForceReply
    return await iniciar_envio_streamers(update, context)

async def escolher_modo_monitoramento_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    # This will call the existing function that sends the mode selection buttons
    return await escolher_modo_monitoramento(update, context)

async def iniciar_envio_streamers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Fun√ß√£o para iniciar a etapa de envio de streamers.
    Pode ser chamada para iniciar ou retomar esta etapa.
    Usa ForceReply para indicar que o bot est√° aguardando uma resposta.
    """
    from telegram import ForceReply

    limite_streamers = context.user_data.get("limite_streamers", 1)
    streamers_atuais = context.user_data.get("streamers", [])

    if streamers_atuais:
        lista = "\n".join([f"{i+1}. {s}" for i, s in enumerate(streamers_atuais)])
        texto_etapa = (
            f"üì∫ *Streamers atuais:*\n{lista}\n\n"
            f"Envie o nome de outro streamer que deseja monitorar (ex: @gaules).\n"
            f"Voc√™ pode cadastrar at√© {limite_streamers} streamers.\n"
            f"Se preferir, digite `/continuar` para avan√ßar."
        )
    else:
        texto_etapa = (
            f"‚úÖ Credenciais recebidas!\n\n"
            f"Agora envie o nome do streamer que deseja monitorar (ex: @gaules). Voc√™ pode usar @ ou n√£o, como preferir.\n\n"
            f"üìå Voc√™ pode cadastrar at√© {limite_streamers} streamers.\n"
            f"Se preferir, voc√™ poder√° configurar os streamers depois. Digite `/continuar` para avan√ßar."
        )

    msg = await update.effective_message.reply_text(
        text=texto_etapa,
        reply_markup=ForceReply(selective=True),
        parse_mode="Markdown"
    )
    context.user_data.setdefault("mensagens_para_apagar", []).append(msg.message_id)
    return ESPERANDO_STREAMERS

async def receber_credenciais(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Apagar mensagens anteriores da etapa de credenciais
    context.user_data.setdefault("mensagens_para_apagar", []).append(update.message.message_id)
    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        try:
            await context.bot.delete_message(chat_id=update.effective_user.id, message_id=msg_id)
        except:
            pass
    context.user_data["mensagens_para_apagar"] = []

    texto = update.message.text
    twitch_id, twitch_secret = "", ""
    for linha in texto.splitlines():
        if linha.lower().strip().startswith("id do cliente:"):
            twitch_id = linha.split(":", 1)[1].strip()
        elif linha.lower().strip().startswith("segredo do cliente:"):
            twitch_secret = linha.split(":", 1)[1].strip()

    if not twitch_id or not twitch_secret or len(twitch_id) < 10 or len(twitch_secret) < 10:
        await limpar_e_enviar_nova_etapa(
            update,
            context,
            "‚ùå Formato inv√°lido. Envie no formato:\n\n`ID do cliente: SEU_ID_AQUI`\n`Segredo do cliente: SEU_SEGREDO_AQUI`",
            [],
        )
        return ESPERANDO_CREDENCIAIS

    context.user_data["twitch_id"] = twitch_id
    context.user_data["twitch_secret"] = twitch_secret

    telegram_id = update.message.from_user.id
    nome = update.message.from_user.full_name
    
    # Obter o plano assinado do usu√°rio do banco de dados
    plano_assinado = obter_plano_usuario(telegram_id)
    
    # Definir limite de streamers com base no plano assinado
    limite_streamers = 1  # Padr√£o para Mensal Solo
    if plano_assinado == "Mensal Plus":
        limite_streamers = 3
    elif plano_assinado == "Anual Pro":
        limite_streamers = 4  # 3 do plano + 1 de b√¥nus
    elif plano_assinado == "PARCEIRO":
        limite_streamers = 1
    elif plano_assinado == "SUPER":
        limite_streamers = 999
    
    logger.info(f"Usu√°rio {telegram_id} com plano '{plano_assinado}'. Limite de streamers: {limite_streamers}")

    context.user_data.update({
        "limite_streamers": limite_streamers,
        "streamers": []
    })
    # Persist√™ncia dos dados parciais
    context.user_data["canal_config"] = {
        "twitch_id": twitch_id,
        "twitch_secret": twitch_secret,
        "streamers": [],
        "modo": None
    }
    # Salvar progresso da configura√ß√£o (etapa credenciais)
    from core.database import salvar_progresso_configuracao
    salvar_progresso_configuracao(telegram_id, etapa="credenciais", dados_parciais={
        "twitch_client_id": twitch_id,
        "twitch_client_secret": twitch_secret
    })

    # Avan√ßa para a pr√≥xima etapa, que agora usa ForceReply para guiar o usu√°rio
    return await iniciar_envio_streamers(update, context)

async def receber_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # Envia uma a√ß√£o de "digitando" para dar feedback imediato ao usu√°rio
    await update.message.chat.send_action(action="typing")
    context.user_data.setdefault("mensagens_para_apagar", []).append(update.message.message_id)

    nome_raw = update.message.text.strip()
    nome = nome_raw.replace('@', '') # Remove @ se o usu√°rio enviar

    # --- Adicionar valida√ß√£o do streamer ---
    twitch_id = context.user_data.get("twitch_id")
    twitch_client_secret = context.user_data.get("twitch_secret")

    try: # Bloco try...except aprimorado para valida√ß√£o de credenciais
        twitch = TwitchAPI(twitch_id, twitch_client_secret)
        streamer_info = await twitch.get_user_info(nome)
        if not streamer_info:
            await update.message.reply_text(f"‚ùå Streamer '{nome_raw}' n√£o encontrado na Twitch. Verifique o nome e tente novamente.")
            return ESPERANDO_STREAMERS
    except httpx.HTTPStatusError as e:
        if e.response.status_code in [401, 403]:
            await update.message.reply_text("‚ùå Credenciais da Twitch inv√°lidas. Verifique o ID e o Segredo do Cliente e tente novamente. Para corrigir, envie as credenciais novamente ou reinicie a configura√ß√£o com /start.")
        else:
            await update.message.reply_text(f"‚ùå Erro de comunica√ß√£o com a Twitch (HTTP {e.response.status_code}). Tente novamente mais tarde.")
        return ESPERANDO_STREAMERS # Mant√©m o usu√°rio na mesma etapa
    except httpx.RequestError as e:
        logger.error(f"Erro de rede ao validar streamer '{nome}' na Twitch: {e}")
        await update.message.reply_text("‚ùå Ocorreu um erro de rede ao conectar com a Twitch. Verifique sua conex√£o e tente novamente.")
        return ESPERANDO_STREAMERS
    except Exception as e:
        logger.error(f"Erro ao validar streamer '{nome}' na Twitch: {e}")
        await update.message.reply_text("‚ùå Ocorreu um erro ao verificar o streamer na Twitch. Verifique suas credenciais ou tente novamente mais tarde.")
        return ESPERANDO_STREAMERS
    # --- Fim da valida√ß√£o ---
    streamers = context.user_data.get("streamers", [])
    limite = context.user_data.get("limite_streamers")

    if nome.isdigit():
        indice = int(nome) - 1
        if 0 <= indice < len(streamers):
            removido = streamers.pop(indice)
            await limpar_e_enviar_nova_etapa(update, context, f"‚ùå Removido: {removido}", [])
            context.user_data["streamers"] = streamers
            # Atualiza persist√™ncia
            if "canal_config" in context.user_data:
                context.user_data["canal_config"]["streamers"] = streamers
            # Salvar progresso da configura√ß√£o (etapa streamers)
            from core.database import salvar_progresso_configuracao
            salvar_progresso_configuracao(update.message.from_user.id, etapa="streamers", dados_parciais={
                "streamers": streamers
            })
            return ESPERANDO_STREAMERS

    if len(streamers) >= limite:
        await limpar_e_enviar_nova_etapa(update, context, "‚ùå Voc√™ j√° atingiu o limite de streamers.", [])
        # Salvar progresso da configura√ß√£o (etapa streamers)
        from core.database import salvar_progresso_configuracao
        salvar_progresso_configuracao(update.message.from_user.id, etapa="streamers", dados_parciais={
            "streamers": streamers
        })
        # Limpar mensagens antes de ir para a escolha de modo
        context.user_data["mensagens_para_apagar"] = []
        return await escolher_modo_monitoramento(update, context)

    streamers.append(nome)
    context.user_data["streamers"] = streamers
    # Atualiza persist√™ncia
    if "canal_config" in context.user_data:
        context.user_data["canal_config"]["streamers"] = streamers
    # Salvar progresso da configura√ß√£o (etapa streamers)
    from core.database import salvar_progresso_configuracao
    salvar_progresso_configuracao(update.message.from_user.id, etapa="streamers", dados_parciais={
        "streamers": streamers
    })

    if len(streamers) < limite:
        lista = "\n".join([f"{i+1}. {s}" for i, s in enumerate(streamers)])
        restante = limite - len(streamers)
        texto = (
            f"‚úÖ Adicionado: {nome}\n\nStreamers atuais:\n{lista}\n\n"
            f"Voc√™ pode enviar mais {restante}, digite /continuar ou envie o n√∫mero para remover."
        )
        # Usa ForceReply para manter o fluxo de conversa e indicar que o bot espera mais nomes
        from telegram import ForceReply
        msg = await update.message.reply_text(
            text=texto,
            reply_markup=ForceReply(selective=True),
            parse_mode="Markdown"
        )
        context.user_data.setdefault("mensagens_para_apagar", []).append(msg.message_id)
        return ESPERANDO_STREAMERS
    else:
        # Limpar mensagens antes de ir para a escolha de modo
        context.user_data["mensagens_para_apagar"] = []
        return await escolher_modo_monitoramento(update, context)

async def comando_continuar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    return await escolher_modo_monitoramento(update, context)

async def escolher_modo_monitoramento(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Limpeza das mensagens anteriores de configura√ß√£o de streamers
    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        try:
            await context.bot.delete_message(chat_id=update.effective_user.id, message_id=msg_id)
        except:
            pass
    context.user_data["mensagens_para_apagar"] = []
    texto = (
        "üß† *Modos de Monitoramento do Clipador:*\n\n"
        "ü§ñ *Autom√°tico:* O Clipador escolhe o melhor modo.\n"
        "üöÄ *Modo Louco:* Muitos clipes rapidamente.\n"
        "üéØ *Modo Padr√£o:* Equil√≠brio entre qualidade e quantidade.\n"
        "üî¨ *Modo Cir√∫rgico:* Apenas clipes virais.\n"
        "üõ† *Manual:* Voc√™ define as regras.\n\n"
        "üìå Voc√™ poder√° alterar o modo depois."
    )
    botoes = [
        [InlineKeyboardButton("ü§ñ Autom√°tico", callback_data="modo_AUTOMATICO")],
        [InlineKeyboardButton("üöÄ Modo Louco", callback_data="modo_MODO_LOUCO")],
        [InlineKeyboardButton("üéØ Modo Padr√£o", callback_data="modo_MODO_PADRAO")],
        [InlineKeyboardButton("üî¨ Modo Cir√∫rgico", callback_data="modo_MODO_CIRURGICO")],
        [InlineKeyboardButton("üõ† Manual", callback_data="iniciar_config_manual_setup")],
        [InlineKeyboardButton("üîô Voltar", callback_data="voltar_streamers")]
    ]
    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)
    return ESCOLHENDO_MODO

async def voltar_streamers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    streamers = context.user_data.get("streamers", [])
    limite = context.user_data.get("limite_streamers", 1)
    restante = limite - len(streamers)
    lista = "\n".join([f"{i+1}. {s}" for i, s in enumerate(streamers)])
    texto = f"üì∫ *Streamers atuais:*\n{lista}\n\nVoc√™ pode enviar mais {restante} ou digitar /continuar para avan√ßar."
    await query.edit_message_text(text=texto, parse_mode="Markdown")
    return ESPERANDO_STREAMERS

async def mostrar_botoes_modos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    texto = (
        "üß† *Modos de Monitoramento do Clipador:*\n\n"
        "ü§ñ *Autom√°tico:* O Clipador escolhe a melhor forma de monitorar.\n"
        "üöÄ *Modo Louco:* Todos os clipes, sem falta.\n"
        "üéØ *Modo Padr√£o:* Equil√≠brio entre qualidade e quantidade.\n"
        "üî¨ *Modo Cir√∫rgico:* Apenas clipes muito interessantes.\n"
        "üõ† *Manual:* Voc√™ define as regras de monitoramento.\n\n"
        "üìå Voc√™ poder√° alterar o modo depois."
    )
    botoes = [
        [InlineKeyboardButton("ü§ñ Autom√°tico", callback_data="modo_AUTOMATICO")],
        [InlineKeyboardButton("üöÄ Modo Louco", callback_data="modo_MODO_LOUCO")],
        [InlineKeyboardButton("üéØ Modo Padr√£o", callback_data="modo_MODO_PADRAO")],
        [InlineKeyboardButton("üî¨ Modo Cir√∫rgico", callback_data="modo_MODO_CIRURGICO")],
        [InlineKeyboardButton("üõ† Manual", callback_data="iniciar_config_manual_setup")],
        [InlineKeyboardButton("üîô Voltar para Streamers", callback_data="voltar_streamers")]
    ]
    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)
    return ESCOLHENDO_MODO

async def iniciar_configuracao_manual_setup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configura√ß√£o manual durante o setup inicial."""
    query = update.callback_query
    await query.answer()

    texto = (
        "üõ†Ô∏è *Configura√ß√£o Manual - Passo 1/2*\n\n"
        "Defina o *m√≠nimo de clipes* que precisam ser criados no mesmo momento para que o bot considere o evento como viral.\n\n"
        "üí° *Recomendado:* `2` ou mais.\n"
        "‚ö†Ô∏è *Limite:* M√≠nimo `1`.\n\n"
        "Por favor, envie o n√∫mero desejado."
    )
    botoes = [
        [InlineKeyboardButton("üîô Voltar para Modos", callback_data="escolher_modo")]
    ]

    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)
    return CONFIG_MANUAL_CLIPS

async def receber_min_clips_setup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe e valida o m√≠nimo de clipes durante o setup."""
    try:
        valor = int(update.message.text)
        if valor < 1:
            await update.message.reply_text("‚ùå Valor inv√°lido. O m√≠nimo de clipes deve ser 1 ou mais. Tente novamente.")
            return CONFIG_MANUAL_CLIPS
    except ValueError:
        await update.message.reply_text("‚ùå Por favor, envie apenas um n√∫mero. Tente novamente.")
        return CONFIG_MANUAL_CLIPS

    # Adiciona a mensagem do usu√°rio (que √© v√°lida) √† lista de exclus√£o para a pr√≥xima etapa
    context.user_data.setdefault("mensagens_para_apagar", []).append(update.message.message_id)
    context.user_data['manual_min_clips'] = valor

    texto = (
        f"‚úÖ M√≠nimo de clipes definido para: *{valor}*\n\n"
        "üõ†Ô∏è *Configura√ß√£o Manual - Passo 2/2*\n\n"
        "Agora, defina o *intervalo m√°ximo em segundos* entre um clipe e outro para que sejam agrupados no mesmo evento.\n\n"
        "üí° *Recomendado:* `60` segundos.\n"
        "‚ö†Ô∏è *Limite:* M√≠nimo `10` segundos.\n\n"
        "Por favor, envie o novo valor."
    )
    botoes = [[InlineKeyboardButton("üîô Voltar", callback_data="iniciar_config_manual_setup")]]

    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)
    return CONFIG_MANUAL_INTERVALO

async def receber_intervalo_setup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe o intervalo, salva as configs manuais e avan√ßa para a revis√£o."""
    try:
        valor = int(update.message.text)
        if valor < 10:
            await update.message.reply_text("‚ùå Valor inv√°lido. O intervalo deve ser de no m√≠nimo 10 segundos. Tente novamente.")
            return CONFIG_MANUAL_INTERVALO
    except ValueError:
        await update.message.reply_text("‚ùå Por favor, envie apenas um n√∫mero. Tente novamente.")
        return CONFIG_MANUAL_INTERVALO

    context.user_data.setdefault("mensagens_para_apagar", []).append(update.message.message_id)
    context.user_data['manual_interval_sec'] = valor
    context.user_data['modo_monitoramento'] = "MANUAL"

    # Salvar progresso da configura√ß√£o (etapa modo manual)
    salvar_progresso_configuracao(
        update.effective_user.id,
        etapa="modo",
        dados_parciais={
            "modo_monitoramento": "MANUAL",
            "manual_min_clips": context.user_data['manual_min_clips'],
            "manual_interval_sec": valor
        }
    )

    # Avan√ßa para a tela de revis√£o final
    return await mostrar_revisao_final(update, context)

async def salvar_modo_monitoramento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Salva o modo de monitoramento predefinido e avan√ßa para a revis√£o."""
    query = update.callback_query
    await query.answer()
    modo = query.data.replace("modo_", "")
    context.user_data["modo_monitoramento"] = modo

    telegram_id = query.from_user.id
    # Salvar progresso da configura√ß√£o (etapa modo)
    salvar_progresso_configuracao(telegram_id, etapa="modo", dados_parciais={
        "modo_monitoramento": modo
    })

    # Avan√ßa para a tela de revis√£o final
    return await mostrar_revisao_final(update, context)

async def mostrar_revisao_final(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Exibe a revis√£o final dos dados antes de salvar."""
    user = update.effective_user
    twitch_client_id = context.user_data.get("twitch_id")
    twitch_client_secret = context.user_data.get("twitch_secret")
    streamers = context.user_data.get("streamers", [])
    modo = context.user_data.get("modo_monitoramento")

    texto_revisao = [
        "üìã *Revis√£o final dos dados:*\n",
        f"üë§ Usu√°rio: @{user.username or user.first_name}",
        f"üß™ Client ID: `{twitch_client_id}`\n"
        f"üîê Client Secret: `{twitch_client_secret[:6]}...`\n"
        f"üì∫ Streamers: `{', '.join(streamers) if streamers else 'Nenhum'}`\n"
        f"üß† Modo: `{modo}`"
    ]

    if modo == "MANUAL":
        min_clips = context.user_data.get('manual_min_clips')
        intervalo = context.user_data.get('manual_interval_sec')
        texto_revisao.append(f"  - M√≠n. Clipes: `{min_clips}`")
        texto_revisao.append(f"  - Intervalo: `{intervalo}s`")

    texto_revisao.extend([
        "\n",
        "‚ö†Ô∏è Ap√≥s salvar, voc√™ ter√° at√© 1 hora para alterar os streamers preenchidos.",
        "Slots vazios poder√£o ser preenchidos depois, sem prazo."
    ])

    texto = "\n".join(texto_revisao)

    botoes = [
        [InlineKeyboardButton("‚úÖ Confirmar e salvar", callback_data="confirmar_salvar_canal")],
        [InlineKeyboardButton("üîô Voltar", callback_data="escolher_modo")]
    ]
    await limpar_e_enviar_nova_etapa(update, context, texto, botoes)
    return ESCOLHENDO_MODO

async def confirmar_salvar_canal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    telegram_id = query.from_user.id
    username = query.from_user.username or f"user{telegram_id}"

    canal_config = context.user_data.get("canal_config", {})
    twitch_client_id = context.user_data.get("twitch_id") or canal_config.get("twitch_id")
    twitch_client_secret = context.user_data.get("twitch_secret") or canal_config.get("twitch_secret")
    streamers = context.user_data.get("streamers") or canal_config.get("streamers", [])
    modo = context.user_data.get("modo_monitoramento") or canal_config.get("modo")

    # Get the ID of the message that triggered this callback
    current_message_id = query.message.message_id if query.message else None

    caminho_imagem_personalizada = None

    # Apagar mensagens antigas, exceto a mensagem atual que ser√° editada
    messages_to_delete_ids = []
    for msg_id in context.user_data.get("mensagens_para_apagar", []):
        if msg_id != current_message_id:
            messages_to_delete_ids.append(msg_id)

    for msg_id in messages_to_delete_ids:
        try:
            await context.bot.delete_message(chat_id=telegram_id, message_id=msg_id)
        except Exception as e:
            logger.warning(f"Could not delete message {msg_id}: {e}")
    context.user_data["mensagens_para_apagar"] = [current_message_id] if current_message_id else []

    try:
        # 1. Gerar a imagem personalizada ANTES de criar o canal
        await query.edit_message_text("‚è≥ Gerando imagem de perfil personalizada...", parse_mode="Markdown")
        caminho_imagem_personalizada = await gerar_imagem_canal_personalizada(telegram_id, context)

        # 2. Salvar configura√ß√£o e criar o canal
        await query.edit_message_text("‚è≥ Salvando configura√ß√µes e criando seu canal...")
        salvar_configuracao_canal_completa(telegram_id, twitch_client_id, twitch_client_secret, streamers, modo)
        id_canal, link_canal = await criar_canal_telegram(
            nome_exibicao=query.from_user.first_name,
            telegram_id=telegram_id,
            caminho_imagem=caminho_imagem_personalizada
        )
        # Salva o link do canal no banco de dados para uso futuro
        from core.database import salvar_link_canal
        salvar_link_canal(telegram_id, id_canal, link_canal)
        # Marca a configura√ß√£o como completa no banco de dados de usu√°rios
        marcar_configuracao_completa(telegram_id, True)

        # Adiciona uma pequena pausa para garantir que o bot seja processado como membro do canal
        import asyncio
        await asyncio.sleep(1)

        # Busca a configura√ß√£o salva para obter o n√∫mero de slots
        config_completa = buscar_configuracao_canal(telegram_id)
        slots_ativos = config_completa.get('slots_ativos', 1)
        num_streamers = len(streamers)

        # Constr√≥i a lista de streamers para a mensagem
        streamers_str = "\n".join([f"‚Ä¢ `{s}`" for s in streamers]) if streamers else "Nenhum streamer configurado."

        # Monta a mensagem de boas-vindas rica em detalhes
        welcome_message_parts = [
            f"üéâ Bem-vindo(a) ao seu canal Clipador, @{username}!\n",
            "Sua configura√ß√£o inicial est√° pronta para come√ßar a clipar os melhores momentos. üöÄ\n",
            "*" + ("-" * 25) + "*",
            "üìã *Resumo da sua Configura√ß√£o:*",
            f"üì∫ *Streamers Monitorados ({num_streamers}/{slots_ativos}):*",
            streamers_str,
            f"üß† *Modo de Monitoramento:* `{modo}`",
            "*" + ("-" * 25) + "*\n"
        ]

        # Adiciona um aviso se houver slots dispon√≠veis
        slots_disponiveis = slots_ativos - num_streamers
        if slots_disponiveis > 0:
            plural_s = "s" if slots_disponiveis > 1 else ""
            welcome_message_parts.append(
                f"‚ö†Ô∏è Voc√™ ainda tem *{slots_disponiveis} slot{plural_s}* dispon√≠vel{plural_s} para adicionar novos streamers! "
                "Voc√™ pode fazer isso a qualquer momento no menu de gerenciamento."
            )

        welcome_message_to_channel = "\n".join(welcome_message_parts)

        # --- Start of retry logic for sending welcome message ---
        max_retries_welcome_msg = 5
        for i in range(max_retries_welcome_msg):
            try:
                await context.bot.send_message(chat_id=id_canal, text=welcome_message_to_channel, parse_mode="Markdown")
                logger.info(f"‚úÖ Mensagem de boas-vindas enviada para o canal {id_canal} na tentativa {i+1}.")
                break # Message sent successfully, exit loop
            except Exception as e:
                error_message_str = str(e)
                if ("Chat not found" in error_message_str or "Bad Request: chat not found" in error_message_str) and i < max_retries_welcome_msg - 1:
                    logger.warning(f"Tentativa {i+1}/{max_retries_welcome_msg}: Chat not found para o canal {id_canal}. Retentando em 2 segundos...")
                    await asyncio.sleep(2) # Wait a bit longer
                else:
                    logger.error(f"Falha ao enviar mensagem de boas-vindas para o canal {id_canal} ap√≥s {i+1} tentativas.")
                    raise # Re-raise if it's not "Chat not found" or if max retries reached
        logger.info(f"‚úÖ Canal criado e configurado com sucesso para o usu√°rio {telegram_id}. Link: {link_canal}")

        await query.edit_message_text(
            f"‚úÖ Tudo pronto!\n\n"
            f"üì¢ Seu canal exclusivo foi criado com sucesso!\n\n"
            "Voc√™ come√ßar√° a receber clipes automaticamente com base nas suas configura√ß√µes üöÄ",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üöÄ Abrir canal", url=link_canal)],
                [InlineKeyboardButton("üè† Menu Principal", callback_data="menu_0")]
            ]),
            parse_mode="Markdown"
        )
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Erro cr√≠tico ao criar/configurar canal para o usu√°rio {telegram_id}: {e}", exc_info=True)
        await query.edit_message_text(
            f"‚ùå Ocorreu um erro ao criar seu canal. Por favor, tente novamente mais tarde ou contate o suporte.\n\nDetalhes: {e}",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data="abrir_configurar_canal")],
                [InlineKeyboardButton("üí¨ Contatar Suporte", url=f"https://t.me/{SUPPORT_USERNAME}")]
            ]),
            parse_mode="Markdown"
        )
        # Garante que o status de configura√ß√£o n√£o seja marcado como completo em caso de falha
        marcar_configuracao_completa(telegram_id, False)
        return ConversationHandler.END
    finally:
        # Garante que a imagem tempor√°ria seja apagada, mesmo se houver uma falha
        # no meio do processo, ap√≥s a imagem ter sido criada.
        if caminho_imagem_personalizada and os.path.exists(caminho_imagem_personalizada):
            try:
                os.remove(caminho_imagem_personalizada)
                logger.info(f"üóëÔ∏è Imagem tempor√°ria '{caminho_imagem_personalizada}' apagada na limpeza final.")
            except OSError as err:
                logger.error(f"‚ùå Erro ao apagar imagem tempor√°ria na limpeza final: {err}")

def atualizar_telegram_id_usuario(telegram_id):
    from core.database import conectar
    conn = conectar()
    cursor = conn.cursor()
    cursor.execute("UPDATE usuarios SET telegram_id = ? WHERE id = ?", (telegram_id, telegram_id))
    conn.commit()
    conn.close()

# ConversationHandler do processo
def configurar_canal_conversa():
    return ConversationHandler(
        entry_points=[
            CallbackQueryHandler(iniciar_envio_twitch, pattern="^enviar_twitch$"),
            CallbackQueryHandler(menu_configurar_canal, pattern="^menu_configurar_canal$|^abrir_configurar_canal$"),
            CallbackQueryHandler(iniciar_envio_streamers_callback, pattern="^iniciar_envio_streamers_callback$"), # New entry point for resuming streamers
            CallbackQueryHandler(escolher_modo_monitoramento_callback, pattern="^escolher_modo_monitoramento_callback$"), # New entry point for resuming mode
            CallbackQueryHandler(responder_menu_7_configurar, pattern="^continuar_configuracao$")
        ],
        states={
            ESPERANDO_CREDENCIAIS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_credenciais)],
            ESPERANDO_STREAMERS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receber_streamer),
                CommandHandler("continuar", comando_continuar)
            ],
            ESCOLHENDO_MODO: [
                CallbackQueryHandler(mostrar_botoes_modos, pattern="^escolher_modo$"),
                CallbackQueryHandler(iniciar_configuracao_manual_setup, pattern="^iniciar_config_manual_setup$"),
                CallbackQueryHandler(salvar_modo_monitoramento, pattern="^modo_"),
                CallbackQueryHandler(voltar_streamers, pattern="^voltar_streamers$"),
                CallbackQueryHandler(confirmar_salvar_canal, pattern="^confirmar_salvar_canal$")
            ],
            CONFIG_MANUAL_CLIPS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receber_min_clips_setup),
                CallbackQueryHandler(mostrar_botoes_modos, pattern="^escolher_modo$") # Bot√£o Voltar
            ],
            CONFIG_MANUAL_INTERVALO: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receber_intervalo_setup),
                CallbackQueryHandler(iniciar_configuracao_manual_setup, pattern="^iniciar_config_manual_setup$") # Bot√£o Voltar
            ],
        },
        fallbacks=[CommandHandler("start", cancelar_e_iniciar)],
        allow_reentry=True
    )

async def exibir_menu_principal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu principal com base no status do usu√°rio."""
    telegram_id = update.effective_user.id
    nome = update.effective_user.first_name or "Clipado"
    # A fun√ß√£o get_nivel_usuario j√° adiciona o usu√°rio se ele n√£o existir,
    # mas a chamada expl√≠cita em responder_inicio garante que ele exista antes da verifica√ß√£o do canal.
    nivel = get_nivel_usuario(telegram_id, nome)

    texto = ""
    botoes = []

    botao_suporte = [InlineKeyboardButton("üí¨ Suporte", url=f"https://t.me/{SUPPORT_USERNAME}")]

    texto_padrao_novo_usuario = (
        f"üëã Aoba Clipad√¥! Seja bem-vindo {nome}, que nome lindo üòç\n\n"
        "Aqui voc√™ recebe os *melhores momentos das lives* direto no seu Telegram, sem esfor√ßo üéØ\n\n"
        "Notei que voc√™ *ainda n√£o tem uma assinatura ativa* üò±\n"
        "Mas relaxa... ainda d√° tempo de mudar isso üí∏"
    )
    texto_expirado = (
        f"üòï Sua assinatura expirou, {nome}.\n\n"
        "Que tal renovar agora e voltar a receber os melhores momentos automaticamente?"
    )
    botoes_padrao = [
        [InlineKeyboardButton("üìö Como funciona", callback_data="menu_1")],
        [InlineKeyboardButton("üí∏ Ver planos", callback_data="menu_2")],
    ]
    botoes_padrao.append(botao_suporte)

    handlers = {
        1: (texto_padrao_novo_usuario, botoes_padrao),
        4: (texto_expirado, botoes_padrao),
    }

    if nivel in handlers:
        texto, botoes = handlers[nivel]
    elif nivel == 2:
        config_completa = is_configuracao_completa(telegram_id)
        config = buscar_configuracao_canal(telegram_id)
        link_do_canal = config.get("link_canal_telegram") if config else "#"

        texto = f"üòé E a√≠ {nome}, o que vamos fazer hoje meu assinante favorito?\n\nSeu Clipador t√° no pique pra ca√ßar os melhores momentos das lives üéØüî•"
        if config_completa:
            botoes = [
                [InlineKeyboardButton("‚öôÔ∏è Gerenciar Canal", callback_data="abrir_menu_gerenciar_canal")],
                [InlineKeyboardButton("üìã Ver plano atual", callback_data="ver_plano_atual")],
                [InlineKeyboardButton("üì£ Abrir meu canal", url=link_do_canal)],
            ]
            botoes.append(botao_suporte)
        else:
            botoes = [
                [InlineKeyboardButton("üö® Finalizar Configura√ß√£o do Canal", callback_data="abrir_configurar_canal")],
                [InlineKeyboardButton("üìã Ver plano atual", callback_data="ver_plano_atual")],
            ]
            botoes.append(botao_suporte)
    else:
        texto, botoes = handlers[1]

    # Determina se envia uma nova mensagem ou edita uma existente
    if update.message:
        await update.message.reply_text(
            text=texto,
            reply_markup=InlineKeyboardMarkup(botoes),
            parse_mode="Markdown"
        )
    elif update.callback_query:
        # Evita editar a mensagem do aviso do canal gratuito
        if context.user_data.get('aviso_enviado_agora'):
            await update.callback_query.message.reply_text(
                text=texto,
                reply_markup=InlineKeyboardMarkup(botoes),
                parse_mode="Markdown"
            )
            context.user_data['aviso_enviado_agora'] = False
        else:
            await update.callback_query.answer()
            await update.callback_query.edit_message_text(
                text=texto,
                reply_markup=InlineKeyboardMarkup(botoes),
                parse_mode="Markdown"
            )

async def responder_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para o comando /start. Mostra o menu principal e um aviso para entrar no canal gratuito."""
    user = update.effective_user
    telegram_id = user.id
    
    adicionar_usuario(telegram_id, user.full_name)

    if not verificar_aviso_enviado(telegram_id):
        try:
            await context.bot.get_chat_member(chat_id=CANAL_GRATUITO_ID, user_id=telegram_id)
            marcar_aviso_enviado(telegram_id)
        except telegram_error.BadRequest as e:
            if "user not found" in e.message.lower():
                texto_aviso = "üëã Ol√°! Antes de come√ßarmos, que tal entrar no nosso canal gratuito?\n\nL√° voc√™ fica por dentro de todas as novidades, atualiza√ß√µes e ainda v√™ o bot em a√ß√£o com os clipes mais quentes do momento! üî•"
                botoes_aviso = [[InlineKeyboardButton("üöÄ Entrar no Canal Gratuito", url=LINK_CANAL_GRATUITO)]]
                await context.bot.send_message(chat_id=telegram_id, text=texto_aviso, reply_markup=InlineKeyboardMarkup(botoes_aviso))
                marcar_aviso_enviado(telegram_id)
                context.user_data['aviso_enviado_agora'] = True
                await asyncio.sleep(1)
            else:
                marcar_aviso_enviado(telegram_id)
                logger.warning(f"Erro de BadRequest n√£o esperado ao verificar membro do canal gratuito para {telegram_id}: {e}")
        except Exception as e:
            marcar_aviso_enviado(telegram_id)
            logger.error(f"Erro inesperado ao verificar membro do canal gratuito para {telegram_id}: {e}")

    await exibir_menu_principal(update, context)

async def cancelar_e_iniciar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a conversa atual e exibe o menu principal."""
    logger.info(f"Comando /start acionado como fallback. Encerrando conversa ativa para o usu√°rio {update.effective_user.id}.")
    await responder_inicio(update, context)
    return ConversationHandler.END

# Redirecionador manual para o menu
async def verificar_callback_configurar_canal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await menu_configurar_canal(update, context)

# Resposta ao bot√£o "continuar_configuracao"
async def responder_menu_7_configurar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("üöÄ Continuando configura√ß√£o do canal...")
    await menu_configurar_canal(update, context)
---
üìÑ chat_privado/menus/menu_gerenciamento.py
---
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, error as telegram_error
from telegram.ext import ContextTypes, ConversationHandler, CallbackQueryHandler, MessageHandler, filters, CommandHandler
from configuracoes import KIRVANO_LINKS, PLANOS_PRECOS
from core.database import (
    buscar_configuracao_canal,
    obter_plano_usuario,
    buscar_usuario_por_id,
    atualizar_modo_monitoramento,
    atualizar_streamers_monitorados,
    atualizar_configuracao_manual,
    obter_slots_base_plano
)
from datetime import datetime, timedelta, timezone
import asyncio
import re
import logging
from chat_privado.menus.menu_configurar_canal import cancelar_e_iniciar
from canal_gratuito.core.twitch import TwitchAPI # Reutilizando a TwitchAPI

logger = logging.getLogger(__name__)

# Estados para as conversas
(
    GERENCIANDO_STREAMERS, AGUARDANDO_ADICAO, AGUARDANDO_REMOCAO, # Gerenciamento de Streamers
    CONFIG_MIN_CLIPS, CONFIG_INTERVALO, CONFIG_MIN_CLIPS_VOD # Configura√ß√£o Manual
) = range(6)

async def ver_plano_atual(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe os detalhes do plano atual do usu√°rio."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    plano = obter_plano_usuario(telegram_id)
    usuario = buscar_usuario_por_id(telegram_id)
    config = buscar_configuracao_canal(telegram_id)

    if not plano or not usuario or not config:
        await query.edit_message_text(
            "‚ùå N√£o foi poss√≠vel encontrar os dados da sua assinatura ou canal.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="menu_0")]])
        )
        return

    data_expiracao_str = usuario.get('data_expiracao', 'N/A')
    try:
        data_expiracao = datetime.fromisoformat(data_expiracao_str).strftime('%d/%m/%Y')
    except (ValueError, TypeError):
        data_expiracao = "N/A"

    # L√≥gica para calcular slots
    slots_ativos = config.get('slots_ativos', 1)
    slots_base = obter_slots_base_plano(plano)
    slots_extras = max(0, slots_ativos - slots_base)

    texto = (
        f"üìã *Detalhes da sua Assinatura*\n\n"
        f"üì¶ *Plano:* {plano}\n"
        f"üóìÔ∏è *Expira em:* {data_expiracao}\n\n"
        f"üé∞ *Slots Contratados:*\n"
        f"  - Slots do plano: `{slots_base}`\n"
        f"  - Slots extras: `{slots_extras}`\n"
        f"  - *Total:* `{slots_ativos}`\n\n"
        "Obrigado por fazer parte do Clipador! üî•"
    )

    botoes = [
        [InlineKeyboardButton("‚öôÔ∏è Gerenciar Canal", callback_data="abrir_menu_gerenciar_canal")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]

    await query.edit_message_text(
        text=texto,
        reply_markup=InlineKeyboardMarkup(botoes),
        parse_mode="Markdown"
    )
async def abrir_menu_gerenciar_canal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de gerenciamento para um canal j√° configurado."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    config = buscar_configuracao_canal(telegram_id)
    if not config:
        await query.edit_message_text(
            "‚ùå Voc√™ n√£o tem um canal configurado para gerenciar.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="menu_0")]])
        )
        return

    client_id = config.get('twitch_client_id', 'N√£o configurado')
    client_secret = config.get('twitch_client_secret', 'N√£o configurado')
    secret_masked = f"{client_secret[:4]}...{client_secret[-4:]}" if client_secret and len(client_secret) > 8 else client_secret
    modo_atual = config.get('modo_monitoramento', 'N√£o definido')

    texto = (
        f"‚öôÔ∏è *Gerenciamento do Canal*\n\n"
        f"Aqui voc√™ pode ajustar as configura√ß√µes do seu canal.\n\n"
        f"üß† *Modo de Monitoramento Atual:* `{modo_atual}`\n\n"
        f"üîë *Credenciais Twitch (somente visualiza√ß√£o):*\n"
        f"  - Client ID: `{client_id}`\n"
        f"  - Client Secret: `{secret_masked}`\n"
    )

    botoes = [
        [InlineKeyboardButton("üß† Alterar Modo de Monitoramento", callback_data="gerenciar_modo")],
        [InlineKeyboardButton("üì∫ Gerenciar Streamers", callback_data="gerenciar_streamers")],
        [InlineKeyboardButton("üîî Gerenciar Notifica√ß√µes", callback_data="abrir_menu_notificacoes")],
        [InlineKeyboardButton("‚ûï Comprar Slot de Streamer", callback_data="comprar_slot_extra")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]

    await query.edit_message_text(
        text=texto,
        reply_markup=InlineKeyboardMarkup(botoes),
        parse_mode="Markdown"
    )

async def comprar_slot_extra(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu para comprar um slot extra."""
    query = update.callback_query
    await query.answer()
    context.user_data["plano_esperado"] = "Slot Extra"

    preco_slot = PLANOS_PRECOS.get("Slot Extra", 0.0)
    texto = (
        "‚ûï *Comprar Slot Extra*\n\n"
        "Adicione um novo streamer para monitorar em seu canal!\n\n"
        f"üí∞ *Valor:* R${preco_slot:.2f}\n"
        "üí≥ *Pagamento:* √önico (n√£o √© uma assinatura)\n\n"
        "Clique no link de pagamento e, ap√≥s concluir, clique em *'J√° Paguei'* abaixo."
    )

    link_pagamento = KIRVANO_LINKS.get("Slot Extra")
    if not link_pagamento or "COLE_SEU_LINK" in link_pagamento:
        await query.edit_message_text(
            "‚ùå A op√ß√£o de compra de slot extra est√° indispon√≠vel no momento.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]])
        )
        return

    botoes = [
        [InlineKeyboardButton(f"üí≥ Pagar R${preco_slot:.2f}", url=link_pagamento)],
        [InlineKeyboardButton("‚úÖ J√° Paguei", callback_data="verificar_compra_slot")],
        [InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]
    ]

    await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")

async def placeholder_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Callback de placeholder para funcionalidades em desenvolvimento."""
    query = update.callback_query
    await query.answer("Esta funcionalidade ser√° implementada em breve.", show_alert=True)

async def abrir_menu_alterar_modo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe os bot√µes para o usu√°rio escolher um novo modo de monitoramento."""
    query = update.callback_query
    await query.answer()

    texto = (
        "üß† *Escolha o novo Modo de Monitoramento:*\n\n"
        "ü§ñ *Autom√°tico:* O Clipador escolhe o melhor modo.\n"
        "üöÄ *Modo Louco:* Muitos clipes rapidamente.\n"
        "üéØ *Modo Padr√£o:* Equil√≠brio entre qualidade e quantidade.\n"
        "üî¨ *Modo Cir√∫rgico:* Apenas clipes virais.\n"
        "üõ† *Manual:* Voc√™ define as regras de monitoramento."
    )
    botoes = [
        [InlineKeyboardButton("ü§ñ Autom√°tico", callback_data="novo_modo_AUTOMATICO")],
        [InlineKeyboardButton("üöÄ Modo Louco", callback_data="novo_modo_MODO_LOUCO")],
        [InlineKeyboardButton("üéØ Modo Padr√£o", callback_data="novo_modo_MODO_PADRAO")],
        [InlineKeyboardButton("üî¨ Modo Cir√∫rgico", callback_data="novo_modo_MODO_CIRURGICO")],
        [InlineKeyboardButton("üõ† Manual", callback_data="configurar_manual_iniciar")],
        [InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]
    ]

    await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")

async def salvar_novo_modo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva o novo modo de monitoramento e notifica o usu√°rio."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id
    novo_modo = query.data.replace("novo_modo_", "")

    try:
        atualizar_modo_monitoramento(telegram_id, novo_modo)
        config = buscar_configuracao_canal(telegram_id)
        id_canal_telegram = config.get('id_canal_telegram')

        if id_canal_telegram:
            await context.bot.send_message(
                chat_id=id_canal_telegram,
                text=f"<b>üß† O modo de monitoramento foi alterado para: {novo_modo}.</b>",
                parse_mode="HTML"
            )

        await query.edit_message_text(
            text=f"‚úÖ Modo de monitoramento alterado com sucesso para `{novo_modo}`!",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]]),
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.error(f"Erro ao alterar modo para {telegram_id}: {e}")
        await query.edit_message_text(
            text="‚ùå Ocorreu um erro ao tentar alterar o modo. Por favor, tente novamente.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]])
        )

async def _construir_menu_streamers(telegram_id: int, mensagem_feedback: str = None) -> tuple[str, InlineKeyboardMarkup]:
    """Helper para construir a mensagem e os bot√µes do menu de gerenciamento de streamers."""
    config = buscar_configuracao_canal(telegram_id)
    streamers = [s for s in config.get('streamers_monitorados', '').split(',') if s] if config and config.get('streamers_monitorados') else []
    num_streamers = len(streamers)

    # Mensagem informativa padr√£o sobre a regra de remo√ß√£o.
    modification_info_message = "\n\n_A remo√ß√£o de streamers s√≥ √© permitida na primeira hora ap√≥s a configura√ß√£o ou na renova√ß√£o da assinatura._"

    limite_streamers = config.get('slots_ativos', 1)

    texto_lista = "\n".join([f"{i+1}. `{s}`" for i, s in enumerate(streamers)]) if num_streamers > 0 else "Nenhum streamer configurado."

    # Adiciona a mensagem de feedback se ela existir, com uma linha divis√≥ria
    feedback_str = f"{mensagem_feedback}\n{'-'*25}\n\n" if mensagem_feedback else ""

    texto = (
        f"{feedback_str}"
        f"üì∫ *Gerenciar Streamers*\n\n"
        f"Voc√™ est√° usando *{num_streamers}/{limite_streamers}* slots.\n\n"
        f"*Sua lista atual:*\n{texto_lista}"
        f"{modification_info_message}" # A mensagem agora √© sempre a mesma
    )

    botoes_linha_1 = []
    # Bot√£o de adicionar aparece se houver slots vagos.
    if num_streamers < limite_streamers:
        botoes_linha_1.append(InlineKeyboardButton("‚ûï Adicionar", callback_data="add_streamer"))
    
    # Bot√£o de remover aparece se houver streamers na lista. A verifica√ß√£o de tempo ser√° na a√ß√£o.
    if num_streamers > 0:
        botoes_linha_1.append(InlineKeyboardButton("‚ûñ Remover", callback_data="remove_streamer"))
    
    keyboard_list = []
    if botoes_linha_1:
        keyboard_list.append(botoes_linha_1)
    
    # Bot√£o de comprar slot extra.
    if num_streamers >= limite_streamers:
        keyboard_list.append([InlineKeyboardButton("‚ûï Comprar Slot Extra", callback_data="comprar_slot_extra")])

    keyboard_list.append([InlineKeyboardButton("üîô Voltar", callback_data="voltar_gerenciamento")])
    
    return texto, InlineKeyboardMarkup(keyboard_list)

async def _limpar_feedback_menu(context: ContextTypes.DEFAULT_TYPE):
    """Callback do JobQueue para limpar a mensagem de feedback do menu."""
    job = context.job
    chat_id = job.data['chat_id']
    message_id = job.data['message_id']
    
    try:
        texto_limpo, keyboard_limpo = await _construir_menu_streamers(chat_id)
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=texto_limpo,
            reply_markup=keyboard_limpo,
            parse_mode="Markdown"
        )
        logger.info(f"Feedback do menu de streamers limpo para o chat {chat_id}.")
    except telegram_error.BadRequest as e:
        if "Message is not modified" in str(e) or "Query is too old" in str(e):
            logger.debug(f"Menu para {chat_id} j√° estava atualizado ou o query expirou. Nenhuma limpeza de feedback necess√°ria.")
        else:
            logger.warning(f"N√£o foi poss√≠vel limpar o feedback do menu para {chat_id}: {e}")
    except Exception as e:
        logger.error(f"Erro inesperado ao limpar feedback do menu para {chat_id}: {e}", exc_info=True)

async def iniciar_gerenciamento_streamers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Ponto de entrada para o gerenciamento de streamers."""
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    # Salva o ID da mensagem do menu para poder edit√°-la depois
    context.user_data['gerenciamento_streamer_menu_id'] = query.message.message_id
    
    texto, keyboard = await _construir_menu_streamers(telegram_id) # A primeira chamada n√£o tem feedback
    
    await query.edit_message_text(text=texto, reply_markup=keyboard, parse_mode="Markdown")
    
    return GERENCIANDO_STREAMERS

async def pedir_novo_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    # Envia uma nova mensagem para n√£o apagar a lista
    prompt_msg = await query.message.reply_text("Qual o nome do streamer que voc√™ deseja adicionar? (ex: @gaules)")
    # Salva o ID da mensagem de prompt para apagar depois
    context.user_data['prompt_msg_id'] = prompt_msg.message_id

    return AGUARDANDO_ADICAO

async def adicionar_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_id = update.effective_user.id

    # Apaga a mensagem do usu√°rio e o prompt do bot
    await update.message.delete()
    prompt_msg_id = context.user_data.pop('prompt_msg_id', None)
    if prompt_msg_id:
        try:
            await context.bot.delete_message(chat_id=telegram_id, message_id=prompt_msg_id)
        except Exception:
            pass

    # Etapa 4.1: Preparar a fun√ß√£o para m√∫ltiplos streamers
    nomes_input = update.message.text.strip().replace('@', '')
    # Usa regex para separar por v√≠rgula ou espa√ßo e filtra itens vazios
    nomes_para_adicionar = [nome for nome in re.split(r'[,\s]+', nomes_input) if nome]

    if not nomes_para_adicionar:
        return GERENCIANDO_STREAMERS # N√£o faz nada se a entrada for vazia

    config = buscar_configuracao_canal(telegram_id)
    twitch_id = config.get("twitch_client_id")
    twitch_secret = config.get("twitch_client_secret")
    streamers_atuais = [s for s in (config.get('streamers_monitorados', '') or '').split(',') if s]
    limite_slots = config.get('slots_ativos', 1)

    adicionados_sucesso = []
    falhas_validacao = []
    falhas_limite = []
    ja_existentes = []

    # Etapa 4.2: Implementar o loop de valida√ß√£o
    try:
        twitch = TwitchAPI(twitch_id, twitch_secret)
        for nome_streamer in nomes_para_adicionar:
            # Verifica se o usu√°rio j√° atingiu o limite de slots
            if len(streamers_atuais) + len(adicionados_sucesso) >= limite_slots:
                falhas_limite.append(nome_streamer)
                continue

            # Verifica se o streamer j√° est√° na lista (ignorando mai√∫sculas/min√∫sculas)
            if nome_streamer.lower() in [s.lower() for s in streamers_atuais] or nome_streamer.lower() in [s.lower() for s in adicionados_sucesso]:
                ja_existentes.append(nome_streamer)
                continue

            user_info = await twitch.get_user_info(nome_streamer)
            if user_info:
                adicionados_sucesso.append(nome_streamer)
            else:
                falhas_validacao.append(nome_streamer)
    except Exception as e:
        logger.error(f"Erro ao validar streamers para {telegram_id}: {e}")
        await update.message.reply_text("‚ùå Erro ao validar streamers. Verifique suas credenciais e tente novamente.")
        return GERENCIANDO_STREAMERS

    # Etapa 4.3: Salvar, notificar e atualizar a interface
    if adicionados_sucesso:
        streamers_atuais.extend(adicionados_sucesso)
        atualizar_streamers_monitorados(telegram_id, streamers_atuais)
        if config.get('id_canal_telegram'):
            await context.bot.send_message(
                chat_id=config['id_canal_telegram'],
                text=f"<b>‚ûï Streamer(s) adicionado(s): {', '.join(adicionados_sucesso)}.</b>",
                parse_mode="HTML"
            )

    # Constr√≥i a mensagem de feedback
    feedback_parts = []
    if adicionados_sucesso: feedback_parts.append(f"‚úÖ Adicionados: `{', '.join(adicionados_sucesso)}`")
    if ja_existentes: feedback_parts.append(f"‚ÑπÔ∏è J√° na lista: `{', '.join(ja_existentes)}`")
    if falhas_validacao: feedback_parts.append(f"‚ùå N√£o encontrados: `{', '.join(falhas_validacao)}`")
    if falhas_limite: feedback_parts.append(f"üö´ Limite de slots atingido. N√£o foi poss√≠vel adicionar: `{', '.join(falhas_limite)}`")

    feedback_final_str = "\n".join(feedback_parts) if feedback_parts else None

    menu_msg_id = context.user_data.get('gerenciamento_streamer_menu_id')
    if not menu_msg_id:
        logger.warning(f"N√£o foi poss√≠vel encontrar o ID do menu para o usu√°rio {telegram_id}. O menu n√£o ser√° atualizado.")
        return GERENCIANDO_STREAMERS

    # Atualiza o menu com a mensagem de feedback (mesmo que seja None, a fun√ß√£o lida com isso)
    texto, keyboard = await _construir_menu_streamers(telegram_id, mensagem_feedback=feedback_final_str)
    try:
        await context.bot.edit_message_text(chat_id=telegram_id, message_id=menu_msg_id, text=texto, reply_markup=keyboard, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Erro ao editar menu com feedback para {telegram_id}: {e}")
        return GERENCIANDO_STREAMERS

    # Se houve uma mensagem de feedback, agenda um job para remov√™-la ap√≥s 10 segundos.
    if feedback_final_str and context.job_queue:
        context.job_queue.run_once(
            _limpar_feedback_menu,
            10,
            data={'chat_id': telegram_id, 'message_id': menu_msg_id},
            name=f"limpar_feedback_add_{telegram_id}_{menu_msg_id}"
        )
    
    return GERENCIANDO_STREAMERS

async def pedir_remocao_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    # Envia uma nova mensagem para n√£o apagar a lista
    prompt_msg = await query.message.reply_text("Digite o n√∫mero do streamer que voc√™ deseja remover da lista.")
    # Salva o ID da mensagem de prompt para apagar depois
    context.user_data['prompt_msg_id'] = prompt_msg.message_id
    
    return AGUARDANDO_REMOCAO

async def remover_streamer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_id = update.effective_user.id
    menu_msg_id = context.user_data.get('gerenciamento_streamer_menu_id')

    # Apaga a mensagem do usu√°rio e o prompt do bot
    await update.message.delete()
    prompt_msg_id = context.user_data.pop('prompt_msg_id', None)
    if prompt_msg_id:
        try:
            await context.bot.delete_message(chat_id=telegram_id, message_id=prompt_msg_id)
        except Exception:
            pass
            
    # --- VERIFICA√á√ÉO DE TEMPO LIMITE ANTES DE PROCESSAR A REMO√á√ÉO ---
    config = buscar_configuracao_canal(telegram_id)
    last_mod_str = config.get('streamers_ultima_modificacao')
    
    feedback_str = None
    proximo_estado = GERENCIANDO_STREAMERS

    if last_mod_str:
        try:
            last_mod_datetime = datetime.fromisoformat(last_mod_str).replace(tzinfo=timezone.utc)
            if datetime.now(timezone.utc) - last_mod_datetime > timedelta(hours=1):
                feedback_str = "‚ùå A remo√ß√£o s√≥ √© permitida na primeira hora."
        except ValueError:
            logger.warning(f"Could not parse streamers_ultima_modificacao: {last_mod_str} for user {telegram_id}")

    if not feedback_str: # S√≥ processa a remo√ß√£o se n√£o houver erro de tempo
        try:
            indice = int(update.message.text.strip()) - 1
            streamers = [s for s in config.get('streamers_monitorados', '').split(',') if s]

            if 0 <= indice < len(streamers):
                removido = streamers.pop(indice)
                atualizar_streamers_monitorados(telegram_id, streamers)
                
                if config.get('id_canal_telegram'):
                    await context.bot.send_message(
                        chat_id=config['id_canal_telegram'],
                        text=f"<b>‚ûñ Streamer {removido} removido da lista de monitoramento.</b>",
                        parse_mode="HTML"
                    )
                feedback_str = f"‚ûñ Removido: `{removido}`"
            else:
                feedback_str = "‚ùå N√∫mero inv√°lido. Tente novamente."
                proximo_estado = AGUARDANDO_REMOCAO
        except (ValueError, IndexError):
            feedback_str = "‚ùå Entrada inv√°lida. Por favor, envie apenas o n√∫mero."
            proximo_estado = AGUARDANDO_REMOCAO

    # --- L√≥gica de atualiza√ß√£o do menu ---
    if menu_msg_id:
        texto, keyboard = await _construir_menu_streamers(telegram_id, mensagem_feedback=feedback_str)
        try:
            await context.bot.edit_message_text(chat_id=telegram_id, message_id=menu_msg_id, text=texto, reply_markup=keyboard, parse_mode="Markdown")
        except Exception as e:
            logger.error(f"Erro ao editar menu de remo√ß√£o com feedback para {telegram_id}: {e}")
            return proximo_estado

        # Se houve uma mensagem de feedback, agenda um job para remov√™-la ap√≥s 10 segundos.
        if feedback_str and context.job_queue:
            context.job_queue.run_once(
                _limpar_feedback_menu,
                10,
                data={'chat_id': telegram_id, 'message_id': menu_msg_id},
                name=f"limpar_feedback_remove_{telegram_id}_{menu_msg_id}"
            )

    return proximo_estado

async def encerrar_gerenciamento_streamers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Volta para o menu de gerenciamento principal e limpa mensagens pendentes."""
    query = update.callback_query
    
    # Limpa o prompt se existir
    prompt_msg_id = context.user_data.pop('prompt_msg_id', None)
    if prompt_msg_id:
        try:
            await context.bot.delete_message(chat_id=query.message.chat_id, message_id=prompt_msg_id)
        except Exception:
            pass
            
    await abrir_menu_gerenciar_canal(update, context)
    return ConversationHandler.END

def gerenciar_streamers_conversa():
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(iniciar_gerenciamento_streamers, pattern="^gerenciar_streamers$")],
        states={
            GERENCIANDO_STREAMERS: [
                CallbackQueryHandler(pedir_novo_streamer, pattern="^add_streamer$"),
                CallbackQueryHandler(pedir_remocao_streamer, pattern="^remove_streamer$"),
                CallbackQueryHandler(encerrar_gerenciamento_streamers, pattern="^voltar_gerenciamento$")
            ],
            AGUARDANDO_ADICAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, adicionar_streamer)],
            AGUARDANDO_REMOCAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, remover_streamer)],
        },
        fallbacks=[
            CallbackQueryHandler(encerrar_gerenciamento_streamers, pattern="^voltar_gerenciamento$"),
            CommandHandler("start", cancelar_e_iniciar)
        ],
        map_to_parent={
            ConversationHandler.END: -1
        }
    )

# --- CONVERSA DE CONFIGURA√á√ÉO MANUAL ---

async def iniciar_configuracao_manual(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia a conversa para configurar o modo manual."""
    query = update.callback_query
    await query.answer()
    
    config = buscar_configuracao_canal(update.effective_user.id)
    min_clips = config.get('manual_min_clips', 'N√£o definido') if config else 'N√£o definido'
    
    texto = (
        f"‚öôÔ∏è *Configura√ß√£o Manual: M√≠nimo de Clipes*\n\n"
        f"Defina quantos clipes precisam ser criados no mesmo momento para que o bot considere o evento como viral.\n\n"
        f"üîπ *Valor atual:* `{min_clips}`\n"
        f"üí° *Recomendado:* 2 ou mais clipes.\n"
        f"‚ö†Ô∏è *Limite:* M√≠nimo 1 clipe.\n\n"
        "Por favor, envie o novo valor."
    )
    botoes = [[InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_config_manual")]]
    
    await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")
    return CONFIG_MIN_CLIPS

async def receber_min_clips(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe e valida o m√≠nimo de clipes."""
    try:
        valor = int(update.message.text)
        if valor < 1:
            await update.message.reply_text("‚ùå Valor inv√°lido. O m√≠nimo de clipes deve ser 1 ou mais. Tente novamente.")
            return CONFIG_MIN_CLIPS
    except ValueError:
        await update.message.reply_text("‚ùå Por favor, envie apenas um n√∫mero. Tente novamente.")
        return CONFIG_MIN_CLIPS
        
    context.user_data['manual_min_clips'] = valor
    
    config = buscar_configuracao_canal(update.effective_user.id)
    intervalo = config.get('manual_interval_sec', 'N√£o definido') if config else 'N√£o definido'

    texto = (
        f"‚úÖ M√≠nimo de clipes definido para: *{valor}*\n\n"
        f"‚öôÔ∏è *Configura√ß√£o Manual: Intervalo entre Clipes*\n\n"
        f"Defina qual a diferen√ßa de tempo os clipes precisam ter para se considerar um grupo viral.\n\n"
        f"_Explica√ß√£o: Imagine a 'janela de tempo' de um evento viral. Se v√°rios clipes s√£o criados dentro desta janela (ex: 60 segundos), o bot entende que todos fazem parte do mesmo grande momento._\n\n"
        f"üîπ *Valor atual:* `{intervalo}`\n"
        f"üí° *Recomendado:* 60 segundos.\n"
        f"‚ö†Ô∏è *Limite:* M√≠nimo 10 segundos.\n\n"
        "Por favor, envie o novo valor."
    )
    botoes = [[InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_config_manual")]]
    
    await update.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")
    return CONFIG_INTERVALO

async def receber_intervalo_e_pedir_vod(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe o intervalo para clipes ao vivo e pede a configura√ß√£o para VODs."""
    try:
        valor = int(update.message.text)
        if valor < 10:
            await update.message.reply_text("‚ùå Valor inv√°lido. O intervalo deve ser de no m√≠nimo 10 segundos. Tente novamente.")
            return CONFIG_INTERVALO
    except ValueError:
        await update.message.reply_text("‚ùå Por favor, envie apenas um n√∫mero. Tente novamente.")
        return CONFIG_INTERVALO
        
    context.user_data['manual_interval_sec'] = valor
    
    config = buscar_configuracao_canal(update.effective_user.id)
    min_clips_vod = config.get('manual_min_clips_vod', 'N√£o definido') if config else 'N√£o definido'

    texto = (
        f"‚úÖ Intervalo para clipes ao vivo definido para: *{valor} segundos*\n\n"
        f"‚öôÔ∏è *Configura√ß√£o Manual: Clipes de VOD (Offline)*\n\n"
        "Agora, defina quantos clipes precisam ser criados em um VOD (quando o streamer est√° offline) para o bot enviar.\n\n"
        "Isso evita o envio de clipes menos relevantes que n√£o aconteceram durante a live.\n\n"
        "‚ö†Ô∏è *Importante:* Esta configura√ß√£o s√≥ tem efeito quando o *Modo Manual* est√° ativo.\n\n"
        f"üîπ *Valor atual:* `{min_clips_vod}`\n"
        f"üí° *Recomendado:* 3 ou mais clipes.\n"
        f"‚ö†Ô∏è *Limite:* M√≠nimo 1 clipe.\n\n"
        "Por favor, envie o novo valor."
    )
    botoes = [[InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_config_manual")]]
    
    await update.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")
    return CONFIG_MIN_CLIPS_VOD

async def receber_min_clips_vod_e_salvar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe o m√≠nimo de clipes para VOD, salva todas as configura√ß√µes e encerra."""
    telegram_id = update.effective_user.id
    try:
        valor = int(update.message.text)
        if valor < 1:
            await update.message.reply_text("‚ùå Valor inv√°lido. O m√≠nimo de clipes para VOD deve ser 1 ou mais. Tente novamente.")
            return CONFIG_MIN_CLIPS_VOD
    except ValueError:
        await update.message.reply_text("‚ùå Por favor, envie apenas um n√∫mero. Tente novamente.")
        return CONFIG_MIN_CLIPS_VOD
        
    min_clips_live = context.user_data.pop('manual_min_clips')
    interval_sec_live = context.user_data.pop('manual_interval_sec')
    min_clips_vod = valor
    
    atualizar_configuracao_manual(
        telegram_id=telegram_id,
        min_clips=min_clips_live,
        interval_sec=interval_sec_live,
        min_clips_vod=min_clips_vod
    )
    atualizar_modo_monitoramento(telegram_id, "MANUAL")
    
    texto_sucesso = (
        f"‚úÖ *Configura√ß√£o Manual Salva!*\n\n"
        f"Seu modo de monitoramento foi alterado para `MANUAL` com os seguintes par√¢metros:\n\n"
        f"*AO VIVO (ONLINE):*\n"
        f"- M√≠nimo de Clipes: `{min_clips_live}`\n"
        f"- Intervalo entre Clipes: `{interval_sec_live}` segundos\n\n"
        f"*VOD (OFFLINE):*\n"
        f"- M√≠nimo de Clipes: `{min_clips_vod}`\n\n"
        "Lembre-se que estas regras s√≥ se aplicam enquanto o modo `MANUAL` estiver ativo."
    )
    botoes = [[InlineKeyboardButton("üîô Voltar ao Gerenciamento", callback_data="abrir_menu_gerenciar_canal")]]
    
    await update.message.reply_text(text=texto_sucesso, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")
    return ConversationHandler.END

async def cancelar_config_manual(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a conversa de configura√ß√£o manual e volta para o menu de modos."""
    context.user_data.pop('manual_min_clips', None)
    context.user_data.pop('manual_interval_sec', None) # Limpa ambos os dados parciais

    # Re-exibe o menu de sele√ß√£o de modo, sem mensagem de cancelamento.
    # A fun√ß√£o abrir_menu_alterar_modo j√° lida com a edi√ß√£o da mensagem.
    await abrir_menu_alterar_modo(update, context)

    return ConversationHandler.END

def configurar_manual_conversa():
    """Cria o ConversationHandler para a configura√ß√£o do modo manual."""
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(iniciar_configuracao_manual, pattern="^configurar_manual_iniciar$")],
        states={
            CONFIG_MIN_CLIPS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_min_clips)],
            CONFIG_INTERVALO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_intervalo_e_pedir_vod)],
            CONFIG_MIN_CLIPS_VOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_min_clips_vod_e_salvar)],
        },
        fallbacks=[
            CallbackQueryHandler(cancelar_config_manual, pattern="^cancelar_config_manual$"),
            CommandHandler("start", cancelar_e_iniciar)
        ],
        map_to_parent={
            ConversationHandler.END: -1
        }
    )
---
üìÑ chat_privado/menus/menu_comandos.py
---
from telegram import Update
from telegram.ext import ContextTypes
from chat_privado.usuarios import get_nivel_usuario
from core.database import (
    is_usuario_admin,
    buscar_configuracao_canal, # J√° importado
    is_configuracao_completa, # Nova importa√ß√£o
    assinatura_em_configuracao
)

async def skip_configuracao_admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Permite que um admin pule a configura√ß√£o do canal se estiver pendente."""
    telegram_id = update.effective_user.id

    if not is_usuario_admin(telegram_id):
        await update.message.reply_text("‚ùå Este comando √© exclusivo para administradores.")
        return

    # Verifica se o usu√°rio √© um assinante ativo (n√≠vel 2) e a configura√ß√£o n√£o est√° completa
    if get_nivel_usuario(telegram_id) == 2 and not is_configuracao_completa(telegram_id):
        from core.database import marcar_configuracao_completa # Nova importa√ß√£o
        marcar_configuracao_completa(telegram_id, False) # Marca como n√£o finalizada
        await update.message.reply_text(
            "‚úÖ Ok, configura√ß√£o pulada por enquanto.\n\n"
            "Voc√™ pode retomar a qualquer momento usando o menu do comando /start."
        )
    else:
        await update.message.reply_text("Voc√™ n√£o possui nenhuma configura√ß√£o de canal pendente para pular.")

---
üìÑ chat_privado/menus/menu_pagamento.py
---
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ForceReply
from telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CommandHandler

# --- FUN√á√ÉO MOVIDA PARA C√Å ---
async def avancar_para_nova_etapa(update: Update, context: ContextTypes.DEFAULT_TYPE, texto: str, botoes: list, parse_mode="Markdown", usar_force_reply=False):
    mensagens_para_apagar = context.user_data.get("mensagens_para_apagar", [])
    for msg_id in mensagens_para_apagar:
        try: # Tenta apagar mensagens anteriores
            await context.bot.delete_message(chat_id=update.effective_user.id, message_id=msg_id) 
        except Exception:
            pass
    context.user_data["mensagens_para_apagar"] = []

    if update.message:
        target = update.message
    elif update.callback_query:
        target = update.callback_query.message
    else:
        return

    if usar_force_reply:
        nova_msg = await target.reply_text(
            texto,
            reply_markup=ForceReply(selective=True),
            parse_mode=parse_mode
        )
    else:
        nova_msg = await target.reply_text(
            texto,
            reply_markup=InlineKeyboardMarkup(botoes) if botoes else None,
            parse_mode=parse_mode
        )

    context.user_data.setdefault("mensagens_para_apagar", []).append(nova_msg.message_id)
from core.database import (
    adicionar_usuario,
    salvar_plano_usuario,
    is_usuario_admin,
    email_ja_utilizado_por_outro_usuario, # Adicionado importa√ß√£o
    buscar_pagamento_por_email, # Usado para buscar detalhes da compra
    registrar_log_pagamento, # Adicionado importa√ß√£o
    vincular_email_usuario,
    vincular_compra_e_ativar_usuario, # Nova fun√ß√£o para ativar usu√°rio e vincular compra
    adicionar_slot_extra,
    buscar_usuario_por_id, # Adicionado para buscar e-mail do usu√°rio
) 
from io import BytesIO
from chat_privado.menus.menu_configurar_canal import cancelar_e_iniciar # Importa a nova fun√ß√£o de fallback
import logging
from core.pagamento import criar_pagamento_pix, criar_pagamento_cartao # Usado apenas se o gateway for Mercado Pago
from configuracoes import GATEWAY_PAGAMENTO, KIRVANO_LINKS, PLANOS_PRECOS
import base64

logger = logging.getLogger(__name__)

PEDIR_EMAIL = 1

def obter_valor_plano(plano: str) -> float:
    """Busca o valor do plano no arquivo de configura√ß√µes."""
    return PLANOS_PRECOS.get(plano, 0.0)

# MENU 5: Mostrar op√ß√µes de pagamento por plano
async def responder_menu_5_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["plano_esperado"] = "Mensal Solo"
    await exibir_opcoes_pagamento(update, context, "Mensal Solo")

async def responder_menu_5_plus(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["plano_esperado"] = "Mensal Plus"
    await exibir_opcoes_pagamento(update, context, "Mensal Plus")

async def responder_menu_5_anual(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["plano_esperado"] = "Anual Pro"
    await exibir_opcoes_pagamento(update, context, "Anual Pro")

async def responder_menu_5_teste(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["plano_esperado"] = "Teste Gratuito"
    await exibir_opcoes_pagamento(update, context, "Teste Gratuito")

# Exibe bot√µes com base no gateway
async def exibir_opcoes_pagamento(update: Update, context: ContextTypes.DEFAULT_TYPE, plano_nome: str):
    query = update.callback_query
    await query.answer()

    valor = obter_valor_plano(plano_nome)

    texto = (
        f"üì¶ *Plano selecionado: {plano_nome}*\n"
        f"üí∞ Valor: R${valor:.2f}\n\n"
    )

    if GATEWAY_PAGAMENTO == "KIRVANO":
        texto += "Clique abaixo para acessar o link de pagamento:"
        botoes = [
            [InlineKeyboardButton("üìé Acessar link de pagamento", url=KIRVANO_LINKS[plano_nome])],
            [InlineKeyboardButton("‚úÖ J√° paguei", callback_data="menu_6")],
            [InlineKeyboardButton("üîô Voltar aos planos", callback_data="menu_2")]
        ]
    elif GATEWAY_PAGAMENTO == "MERCADOPAGO":
        texto += "Escolha a forma de pagamento:"
        botoes = [
            [InlineKeyboardButton("üí∏ Pagar com Pix", callback_data=f"pagar_pix_{plano_nome.replace(' ', '_')}")],
            [InlineKeyboardButton("üí≥ Pagar com Cart√£o", callback_data=f"pagar_cartao_{plano_nome.replace(' ', '_')}")],
            [InlineKeyboardButton("üîô Voltar aos planos", callback_data="menu_2")]
        ]
    else:
        texto += "‚ùå Gateway de pagamento inv√°lido."
        botoes = [[InlineKeyboardButton("üîô Voltar aos planos", callback_data="menu_2")]]
    
    # A mensagem com os bot√µes de pagamento ser√° editada ou substitu√≠da.
    # A fun√ß√£o `avancar_para_nova_etapa` (ou similar) na pr√≥xima etapa cuidar√° da limpeza.
    try:
        msg = await query.edit_message_text(
            text=texto,
            reply_markup=InlineKeyboardMarkup(botoes),
            parse_mode="Markdown"
        )
        context.user_data.setdefault("mensagens_para_apagar", []).append(query.message.message_id)
    except BadRequest:
        msg = await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")
        context.user_data.setdefault("mensagens_para_apagar", []).append(msg.message_id)

# GERA√á√ÉO DE PIX (somente Mercado Pago)
async def gerar_pagamento_pix(update: Update, context: ContextTypes.DEFAULT_TYPE, plano_nome: str):
    query = update.callback_query
    await query.answer()

    try:
        dados = criar_pagamento_pix(
            valor=obter_valor_plano(plano_nome),
            descricao=f"Assinatura Clipador - {plano_nome}"
        )

        imagem_bytes = base64.b64decode(dados["imagem"])
        imagem_io = BytesIO(imagem_bytes)
        imagem_io.name = "qrcode.png"

        texto = (
            f"üí∏ *Pagamento via Pix gerado com sucesso!*\n\n"
            f"üì¶ Plano: *{plano_nome}*\n"
            f"üí∞ Valor: *R${dados['valor']:.2f}*\n\n"
            "Copie o c√≥digo abaixo ou escaneie o QR Code:"
        )

        botoes = [
            [InlineKeyboardButton("‚úÖ J√° paguei", callback_data="menu_6")],
            [InlineKeyboardButton("üîÅ Tentar novamente", callback_data=f"pagar_pix_{plano_nome.replace(' ', '_')}")],
            [InlineKeyboardButton("üîô Voltar", callback_data="menu_2")]
        ]

        await query.message.reply_photo(
            photo=imagem_io,
            caption=texto + f"\n\n`{dados['qrcode']}`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(botoes)
        )

    except Exception as e:
        await query.message.reply_text(
            text=f"‚ùå Erro ao gerar o pagamento via Pix.\n\n{str(e)}",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data=f"pagar_pix_{plano_nome.replace(' ', '_')}")],
                [InlineKeyboardButton("üîô Voltar", callback_data="menu_2")]
            ]),
            parse_mode="Markdown"
        )

# GERA√á√ÉO DE CART√ÉO (somente Mercado Pago)
async def gerar_pagamento_cartao(update: Update, context: ContextTypes.DEFAULT_TYPE, plano_nome: str):
    query = update.callback_query
    await query.answer()

    try:
        link_checkout = criar_pagamento_cartao(
            valor=obter_valor_plano(plano_nome),
            descricao=f"Assinatura Clipador - {plano_nome}"
        )

        texto = (
            f"üí≥ *Pagamento via Cart√£o de Cr√©dito*\n\n"
            f"üì¶ Plano: *{plano_nome}*\n"
            f"üí∞ Valor: *R${obter_valor_plano(plano_nome):.2f}*\n\n"
            "Clique abaixo para finalizar a compra:"
        )

        botoes = [
            [InlineKeyboardButton("üí≥ Pagar com Cart√£o", url=link_checkout)],
            [InlineKeyboardButton("‚úÖ J√° paguei", callback_data="menu_6")],
            [InlineKeyboardButton("üîô Voltar", callback_data="menu_2")]
        ]

        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode="Markdown")

    except Exception as e:
        await query.edit_message_text(
            text="‚ùå Erro ao gerar pagamento com cart√£o. Deseja tentar novamente?",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data=f"pagar_cartao_{plano_nome.replace(' ', '_')}")],
                [InlineKeyboardButton("üîô Voltar", callback_data="menu_2")]
            ])
        )

# MENU 6: J√° paguei (pede e-mail)
async def responder_menu_6(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if query:
        await query.answer()
        # Salva o ID da mensagem de bot√µes para poder editar depois
        context.user_data["mensagem_pagamento_id"] = query.message.message_id

    # Envia uma nova mensagem pedindo o e-mail, respondendo √† mensagem do menu
    # para que o menu original n√£o seja apagado.
    nova_msg = await query.message.reply_text(
        "üòé Beleza! Agora me diga qual e-mail voc√™ usou para fazer o pagamento:",
        reply_markup=ForceReply(selective=True)
    )
    # Salva o ID da mensagem de "qual seu e-mail" para apagar depois
    context.user_data["mensagem_pedindo_email_id"] = nova_msg.message_id

    return PEDIR_EMAIL

async def pular_pagamento_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int: # Adiciona 'plano_simulado' como argumento opcional
    """
    Comando de admin para simular um pagamento aprovado e avan√ßar o funil.
    Exclusivo para administradores.
    """
    telegram_id = update.effective_user.id
    if not is_usuario_admin(telegram_id):
        # Encerra o funil para n√£o-administradores, sem enviar mensagem.
        # Se for um comando, responde para o usu√°rio.
        if update.message:
            await update.message.reply_text("‚ùå Voc√™ n√£o tem permiss√£o para usar este comando.")
        return ConversationHandler.END

    plano_simulado = context.args[0] if context.args else "Mensal Plus" # Pega o primeiro argumento ou define um padr√£o

    # Simula um pagamento aprovado
    email = f"admin_skip_{telegram_id}@clipador.com" # Email dummy para admin skips
    
    # Garante que o usu√°rio exista no DB e tenha um email vinculado para vincular_compra_e_ativar_usuario
    adicionar_usuario(telegram_id, update.effective_user.first_name)
    vincular_email_usuario(telegram_id, email)

    try:
        vincular_compra_e_ativar_usuario(telegram_id, email, plano_simulado, "approved")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro ao simular ativa√ß√£o da assinatura para admin: {e}")
        return ConversationHandler.END # Encerra o funil em caso de erro para o admin

    await avancar_para_nova_etapa(
        update, context,
        f"‚úÖ Pagamento simulado com sucesso para admin!\n\nPlano assinado: *{plano_simulado}*.\nSeu acesso foi liberado. Agora vamos configurar seu canal privado.",
        [[InlineKeyboardButton("‚öôÔ∏è Continuar configura√ß√£o", callback_data="abrir_configurar_canal")]]
    )
    return ConversationHandler.END

async def verificar_compra_slot_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Callback para o bot√£o 'J√° Paguei' de um slot extra.
    Busca o e-mail cadastrado do usu√°rio e inicia a verifica√ß√£o do pagamento.
    """
    query = update.callback_query
    await query.answer("Verificando sua compra...")
    telegram_id = update.effective_user.id

    usuario = buscar_usuario_por_id(telegram_id)
    email_cadastrado = usuario.get('email') if usuario else None

    if not email_cadastrado:
        await query.edit_message_text(
            "‚ùå N√£o encontramos um e-mail cadastrado na sua conta. "
            "Para comprar um slot extra, voc√™ precisa primeiro ter uma assinatura ativa.\n\n"
            "Se acredita que isso √© um erro, entre em contato com o suporte.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]])
        )
        return

    # Passa o e-mail para a fun√ß√£o `receber_email` atrav√©s do context.args
    # e chama a fun√ß√£o diretamente.
    context.args = [email_cadastrado]
    # Como a fun√ß√£o `receber_email` espera uma mensagem, vamos simular uma
    # para que ela possa responder. Usamos a mensagem do query.
    update.message = query.message
    # A fun√ß√£o `receber_email` n√£o est√° em uma ConversationHandler aqui,
    # ent√£o o `return ConversationHandler.END` ser√° ignorado, o que √© o comportamento desejado.
    await receber_email(update, context)

async def receber_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recebe e-mail do usu√°rio ou usa o e-mail j√° registrado (compra de slot extra)."""
    from core.gateway.kirvano import verificar_status_compra_para_ativacao # Fun√ß√£o correta

    # Se o email j√° foi passado, usa ele. Sen√£o, tenta obter da mensagem do usu√°rio.
    email = context.args[0] if context.args else None
    if not email and update.message:
        # Apaga a mensagem de prompt e a resposta do usu√°rio
        mensagem_pedindo_email_id = context.user_data.pop("mensagem_pedindo_email_id", None)
        if mensagem_pedindo_email_id:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=mensagem_pedindo_email_id)
            except Exception: pass
        try:
            await update.message.delete() # Apaga o e-mail enviado pelo usu√°rio
        except Exception: pass
        email = update.message.text.strip()

    vincular_email_usuario(update.effective_user.id, email) # Mantido, pois associa o email ao usu√°rio no DB

    if not email or "@" not in email or "." not in email:
        await update.message.reply_text(
            f"üìß E-mail informado: {email}\n\n"
            "‚ùå E-mail inv√°lido ou n√£o informado. Por favor, digite um e-mail v√°lido para continuar.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Corrigir e-mail", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]
            ])
        )
        return PEDIR_EMAIL

    await update.message.chat.send_action(action="typing")

    telegram_id = update.effective_user.id
    
    if email_ja_utilizado_por_outro_usuario(email, telegram_id):
        await update.message.reply_text(
            "‚ùå Este e-mail j√° est√° vinculado a outro usu√°rio.\nVerifique se digitou corretamente ou use outro e-mail.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Corrigir e-mail", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]
            ])
        )
        return PEDIR_EMAIL

    try:
        # Busca a compra mais recente para o e-mail
        compra_db = buscar_pagamento_por_email(email)
        status_compra = compra_db["status"].lower() if compra_db else "not_found"
        plano_real = compra_db["plano"] if compra_db else None
        metodo_pagamento = compra_db["metodo_pagamento"] if compra_db else None
        registrar_log_pagamento(telegram_id, email, plano_real, status_compra)
    except Exception as e:
        print(f"[ERRO] Exce√ß√£o ao buscar pagamento no DB: {str(e)}")
        await update.message.reply_text(
            "‚ùå Ocorreu um erro inesperado durante a verifica√ß√£o do pagamento.\nTente novamente mais tarde.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]
            ])
        )
        return PEDIR_EMAIL

    # Se o status for final (aprovado, n√£o encontrado, etc.), apaga o menu de pagamento.
    # Se for pendente, o menu ser√° editado, n√£o apagado.
    if status_compra != "pending":
        mensagem_pagamento_id = context.user_data.pop("mensagem_pagamento_id", None)
        if mensagem_pagamento_id:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=mensagem_pagamento_id)
            except Exception: pass

    # L√≥gica centralizada de tratamento de status
    if status_compra == "approved":
        plano_esperado = context.user_data.get("plano_esperado")

        # Se a compra for de um Slot Extra
        if plano_real == "Slot Extra":
            try:
                adicionar_slot_extra(telegram_id)
                await avancar_para_nova_etapa(
                    update,
                    context,
                    "‚úÖ Slot extra adicionado com sucesso!\n\nVoc√™ j√° pode configurar um novo streamer.",
                    [[InlineKeyboardButton("üîß Gerenciar canal", callback_data="abrir_menu_gerenciar_canal")]]
                )
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Erro ao adicionar slot extra para {telegram_id}: {e}")
                await update.message.reply_text(
                    "‚ùå Ocorreu um erro ao adicionar seu slot extra. Por favor, contate o suporte.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar", callback_data="abrir_menu_gerenciar_canal")]])
                )
                return ConversationHandler.END
        else: # Se a compra for de um plano de assinatura
            # Se o m√©todo de pagamento √© FREE, verifica se o usu√°rio √© admin
            if metodo_pagamento and metodo_pagamento.upper() == "FREE": # Verifica se √© um plano "FREE"
                if not is_usuario_admin(telegram_id):
                    await update.message.reply_text(
                        "‚ùå Produtos gratuitos s√≥ podem ser usados por administradores.",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("üîô Voltar", callback_data="menu_2")]
                        ])
                    )
                    return PEDIR_EMAIL
                print(f"[DEBUG] Admin {telegram_id} ativando acesso gratuito com e-mail {email}.") # Log para admin

            if plano_real and plano_esperado and plano_real != plano_esperado:
                await update.message.reply_text(
                    f"‚ö†Ô∏è Voc√™ selecionou o plano *{plano_esperado}*, mas seu pagamento foi para o plano *{plano_real}*.\n"
                    f"Sua assinatura foi ativada para o plano *{plano_real}*.",
                    parse_mode="Markdown"
                )

            # Ativa o usu√°rio
            print(f"[DEBUG] Pagamento aprovado para {email}, ativando usu√°rio {telegram_id}...")
            try: # Sempre ativa com o plano_real
                vincular_compra_e_ativar_usuario(telegram_id, email, plano_real, "approved")
            except ValueError as e: # NOVO: Captura o erro de teste j√° utilizado
                await update.message.reply_text(
                    f"‚ùå {e}", # Exibe a mensagem de erro ("Voc√™ j√° utilizou...")
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô Voltar aos planos", callback_data="menu_2")]])
                )
                return PEDIR_EMAIL
            except Exception as e:
                await update.message.reply_text(
                    f"‚ùå Erro ao ativar sua assinatura: {e}\nPor favor, tente novamente ou contate o suporte.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîÅ Corrigir e-mail", callback_data="menu_6")], [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]])
                )
                return PEDIR_EMAIL
            
            # Mensagem de sucesso e continua√ß√£o
            await avancar_para_nova_etapa(
                update,
                context,
                f"‚úÖ Pagamento confirmado com sucesso!\n\n"
                f"Plano assinado: *{plano_real}*.\n"
                f"Seu acesso foi liberado. Agora vamos configurar seu canal privado.",
                [[InlineKeyboardButton("‚öôÔ∏è Continuar configura√ß√£o", callback_data="abrir_configurar_canal")]]
            )
            return ConversationHandler.END

    elif status_compra == "pending":
        # L√≥gica para pagamento pendente
        print("[DEBUG] Pagamento pendente.")
        mensagem_id = context.user_data.get("mensagem_pagamento_id") # Usa .get() para n√£o remover a chave
        chat_id = update.effective_chat.id
        plano_esperado = context.user_data.get("plano_esperado")
        
        botoes = [
            [InlineKeyboardButton("üìé Acessar link de pagamento", url=KIRVANO_LINKS.get(plano_esperado, ""))],
            [InlineKeyboardButton("‚úÖ J√° paguei", callback_data="menu_6")],
            [InlineKeyboardButton("üîô Voltar aos planos", callback_data="menu_2")]
        ]
        texto_pendente = (
            f"üìß E-mail informado: {email}\n\n"
            "üïê Pagamento ainda pendente.\n"
            "Aguarde a confirma√ß√£o e clique novamente em 'J√° paguei'."
        )
        if mensagem_id:
            try:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=mensagem_id,
                    text=texto_pendente,
                    reply_markup=InlineKeyboardMarkup(botoes)
                )
            except Exception as e:
                print(f"[DEBUG] Falha ao editar mensagem pendente: {e}")
                await update.message.reply_text(texto_pendente, reply_markup=InlineKeyboardMarkup(botoes))
        else:
            await update.message.reply_text(texto_pendente, reply_markup=InlineKeyboardMarkup(botoes))
        return PEDIR_EMAIL

    elif status_compra == "not_found":
        print("[DEBUG] Pagamento n√£o encontrado.")
        await update.message.reply_text(
            "‚ùå Pagamento n√£o encontrado para este e-mail.\nVerifique se digitou corretamente.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Corrigir e-mail", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]
            ])
        )
        return PEDIR_EMAIL

    else: # Status como REFUNDED, EXPIRED, CHARGEBACK, ou qualquer outro n√£o tratado
        print(f"[DEBUG] Pagamento com status n√£o aprovado: {status_compra}")
        await update.message.reply_text(
            f"‚ùå O pagamento para o e-mail *{email}* n√£o est√° aprovado ou est√° em um status inv√°lido ({status_compra}).\n"
            "Por favor, verifique o status da sua compra ou contate o suporte.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_2")]
            ])
        )
    return PEDIR_EMAIL

async def pular_configuracao_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Encerra a conversa de configura√ß√£o para o admin configurar depois."""
    query = update.callback_query
    telegram_id = update.effective_user.id
    await query.answer()

    await query.edit_message_text(
        "‚úÖ Ok, entendido!\n\n"
        "Voc√™ pode iniciar a configura√ß√£o do seu canal a qualquer momento usando o comando /start."
    )
    return ConversationHandler.END

from telegram.ext import CallbackQueryHandler
# HANDLER PARA MENU DE CONFIGURA√á√ÉO DO CANAL

pagamento_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(responder_menu_6, pattern="^menu_6$")],
    states={
        PEDIR_EMAIL: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_email),
            CallbackQueryHandler(responder_menu_6, pattern="^menu_6$"), # Adicionado para o bot√£o "Corrigir e-mail"
            CommandHandler("pular", pular_pagamento_admin), # Adiciona o comando /pular para admins
            CallbackQueryHandler(pular_configuracao_callback, pattern="^pular_configuracao$")
        ],
    },
    fallbacks=[CommandHandler("start", cancelar_e_iniciar)], # Usa a nova fun√ß√£o que encerra a conversa
    per_message=False
)


# ROTEADOR
async def roteador_pagamento(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    if data.startswith("pagar_pix_"):
        plano = data.replace("pagar_pix_", "").replace("_", " ")
        await gerar_pagamento_pix(update, context, plano)

    elif data.startswith("pagar_cartao_"):
        plano = data.replace("pagar_cartao_", "").replace("_", " ")
        await gerar_pagamento_cartao(update, context, plano)

    elif data == "abrir_configurar_canal":
        from chat_privado.menus.menu_configurar_canal import menu_configurar_canal # Importa√ß√£o local para quebrar o ciclo
        print("[DEBUG] Callback abrir_configurar_canal acionado. Roteando...")
        await update.callback_query.answer()
        await menu_configurar_canal(update, context)
---
üìÑ chat_privado/menus/menu_callback.py
---
from telegram.ext import CallbackQueryHandler
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode
from core.pagamento import consultar_pagamento
from chat_privado.menus.menu_configurar_canal import menu_configurar_canal, responder_menu_7_configurar
from core.database import atualizar_telegram_id_simples, usuario_ja_usou_teste
from chat_privado.usuarios import get_nivel_usuario # Importar get_nivel_usuario
from configuracoes import PLANOS_PRECOS, TESTE_GRATUITO_ATIVO
from core.database import buscar_configuracao_canal

from telegram.error import BadRequest

def atualizar_usuario_contexto(update, context):
    telegram_user_id = update.effective_user.id
    context.user_data["telegram_id"] = telegram_user_id
    atualizar_telegram_id_simples(telegram_user_id, telegram_user_id)

# menu_0 ‚Üí Menu inicial (roteador)
async def responder_menu_0(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Sempre obter o n√≠vel mais atualizado do banco de dados
    nivel = get_nivel_usuario(update.effective_user.id)
    tipo_plano = context.user_data.get("tipo_plano", "indefinido")
    atualizar_usuario_contexto(update, context)
    if nivel == 2:
        await responder_menu_assinante(update, context)
    elif nivel == 3:
        await responder_menu_ex_assinante(update, context)
    elif nivel == 999:
        await responder_menu_admin(update, context)
    else:
        await responder_menu_novo_usuario(update, context)

# menu_padrao ‚Üí Menu inicial (callback renomeado)
async def responder_menu_padrao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    atualizar_usuario_contexto(update, context)
    await responder_menu_0(update, context)


# Menus por n√≠vel de usu√°rio
async def responder_menu_novo_usuario(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()
    texto = (
        "üëã *Bem-vindo ao Clipador!*\n\n"
        "Eu sou o bot que vai transformar seus clipes em ouro (ou pelo menos em muitos views)!\n\n"
        "Escolha uma op√ß√£o abaixo para descobrir mais:"
    )
    botoes = [
        [InlineKeyboardButton("üìö Como funciona", callback_data="menu_1")],
        [InlineKeyboardButton("üí∞ Ver planos", callback_data="menu_3")],
        [InlineKeyboardButton("üöÄ Assinar", callback_data="menu_3")],
    ]
    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


async def responder_menu_assinante(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()
    texto = (
        "üéâ *Menu do Assinante Clipador!*\n\n"
        "Voc√™ j√° faz parte do clube dos clippers profissionais!\n"
        "O que deseja fazer agora? (Al√©m de ficar famoso, claro üòé)"
    )
    botoes = [
        [InlineKeyboardButton("üì° Ver canal", callback_data="abrir_canal")],
        [InlineKeyboardButton("üîß Configurar canal", callback_data="menu_7_configurar")],
        [InlineKeyboardButton("üìù Plano atual", callback_data="menu_3")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]
    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


async def responder_menu_ex_assinante(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()
    texto = (
        "üò¢ *Sua assinatura expirou!*\n\n"
        "Mas n√£o se preocupe, ainda d√° tempo de voltar para o lado dos clippers felizes.\n"
        "Veja como funciona ou confira nossos planos para voltar com tudo!"
    )
    botoes = [
        [InlineKeyboardButton("üìö Como funciona", callback_data="menu_1")],
        [InlineKeyboardButton("üí∞ Ver planos", callback_data="menu_3")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]
    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


async def responder_menu_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()
    texto = (
        "üõ†Ô∏è *Painel Administrativo Clipador*\n\n"
        "Bem-vindo, mestre dos clipes! Aqui est√£o suas ferramentas secretas:"
    )
    botoes = [
        [InlineKeyboardButton("üë• Ver usu√°rios", callback_data="admin_ver_usuarios")],
        [InlineKeyboardButton("üìà Gerar relat√≥rio", callback_data="admin_gerar_relatorio")],
        [InlineKeyboardButton("üí≥ Pagamentos", callback_data="admin_pagamentos")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]
    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_1 ‚Üí Como funciona
async def responder_menu_1(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        "üìö *COMO FUNCIONA O CLIPADOR*\n\n"
        "üé• O Clipador monitora automaticamente os streamers que voc√™ escolher e envia *os melhores momentos das lives* direto no seu canal no Telegram.\n\n"
        "üîÑ *Monitoramento 24h/dia*, sem precisar fazer nada.\n"
        "üß† O bot identifica grupos de clipes virais e filtra o que realmente importa.\n"
        "üì• Voc√™ pode ver o preview do clipe e fazer o download para subir na sua plataforma de prefer√™ncia.\n\n"
        "üí° *O que s√£o slots?*\n"
        "Cada slot representa 1 streamer monitorado.\n"
        "Voc√™ pode contratar mais slots extras para monitorar m√∫ltiplos streamers no mesmo canal.\n\n"
        "üìä *Modos de monitoramento:*\n"
        "- Modo Louco üî• (envia tudo que viraliza)\n"
        "- Modo Padr√£o üéØ (equil√≠brio entre qualidade e frequ√™ncia)\n"
        "- Modo Cir√∫rgico üß¨ (s√≥ clipes realmente bomb√°sticos)"
    )

    botoes = [
        [InlineKeyboardButton("üí∏ Ver planos", callback_data="menu_2")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")],
    ]

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)

# menu_2 ‚Üí Planos dispon√≠veis
async def responder_menu_2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        f"üí∏ *PLANOS DO CLIPADOR*\n\n"
        f"‚úÖ *Mensal Solo* ‚Äî R${PLANOS_PRECOS.get('Mensal Solo', 0.0):.2f}/m√™s\n"
        "‚Ä¢ 1 streamer monitorado\n"
        "‚Ä¢ Troca de streamer 1x/m√™s\n"
        "‚Ä¢ M√°ximo 1 slot extra\n\n"
        f"üèÜ *Mensal Plus* ‚Äî R${PLANOS_PRECOS.get('Mensal Plus', 0.0):.2f}/m√™s\n"
        "‚Ä¢ At√© 3 canais monitorados\n"
        "‚Ä¢ Ideal pra clippers/ag√™ncias\n"
        "‚Ä¢ At√© 3 slots extras\n\n"
        f"üëë *Anual Pro* ‚Äî R${PLANOS_PRECOS.get('Anual Pro', 0.0):.2f}/ano\n"
        "‚Ä¢ 3 canais + 1 slot b√¥nus\n"
        "‚Ä¢ Economia de 2 meses\n"
        "‚Ä¢ At√© 5 slots extras\n\n"
        f"‚ûï *Slot Extra:* R${PLANOS_PRECOS.get('Slot Extra', 0.0):.2f} (pagamento √∫nico para qualquer plano)"
    )

    botoes = [
        [InlineKeyboardButton("üìù Quero assinar", callback_data="menu_3")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")],
    ]
    await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_3 ‚Üí Lista de Planos
async def responder_menu_3(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        f"üßæ *PLANOS DO CLIPADOR*\n\n"
        f"‚úÖ *Mensal Solo* ‚Äî R${PLANOS_PRECOS.get('Mensal Solo', 0.0):.2f}/m√™s\n"
        "‚Ä¢ 1 streamer monitorado\n"
        "‚Ä¢ Troca de streamer 1x/m√™s\n"
        "‚Ä¢ M√°ximo 1 slot extra\n\n"
        f"üèÜ *Mensal Plus* ‚Äî R${PLANOS_PRECOS.get('Mensal Plus', 0.0):.2f}/m√™s\n"
        "‚Ä¢ At√© 3 canais monitorados\n"
        "‚Ä¢ Ideal pra clippers/ag√™ncias\n"
        "‚Ä¢ At√© 3 slots extras\n\n"
        f"üëë *Anual Pro* ‚Äî R${PLANOS_PRECOS.get('Anual Pro', 0.0):.2f}/ano\n"
        "‚Ä¢ 3 canais + 1 slot b√¥nus\n"
        "‚Ä¢ Economia de 2 meses\n"
        "‚Ä¢ At√© 5 slots extras\n\n"
        f"‚ûï *Slot Extra:* R${PLANOS_PRECOS.get('Slot Extra', 0.0):.2f} (pagamento √∫nico para qualquer plano)"
    )

    botoes = [
        [InlineKeyboardButton("üí≥ Mensal Solo", callback_data="menu_4_mensal")],
        [InlineKeyboardButton("üèÜ Mensal Plus", callback_data="menu_4_plus")],
        [InlineKeyboardButton("üëë Anual Pro", callback_data="menu_4_anual")],
        [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
    ]

    # NOVO: Adiciona o bot√£o de teste gratuito se as condi√ß√µes forem atendidas
    telegram_id = update.effective_user.id
    if TESTE_GRATUITO_ATIVO and not usuario_ja_usou_teste(telegram_id):
        # Insere o bot√£o de teste antes dos planos pagos
        botoes.insert(0, [InlineKeyboardButton("‚≠ê Teste Gratuito (3 dias)", callback_data="menu_5_teste")])

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_4 ‚Üí Resumo plano Mensal Solo
async def responder_menu_4_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        f"*üìù RESUMO DO PLANO MENSAL SOLO*\n\n"
        f"üí∞ R$ {PLANOS_PRECOS.get('Mensal Solo', 0.0):.2f}/m√™s\n"
        "üîπ 1 streamer monitorado\n"
        "üîÑ Troca de streamer 1x por m√™s\n"
        f"‚ûï M√°ximo 1 slot extra (R${PLANOS_PRECOS.get('Slot Extra', 0.0):.2f} - pagamento √∫nico)\n"
        "üìÖ Renova√ß√£o mensal\n\n"
        "Deseja continuar com esse plano?"
    )

    botoes = [
        [InlineKeyboardButton("‚úÖ Escolher este plano", callback_data="menu_5_mensal")],
        [InlineKeyboardButton("üîô Voltar", callback_data="menu_3")]
    ]

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_4 ‚Üí Resumo plano Mensal Plus
async def responder_menu_4_plus(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        f"*üìù RESUMO DO PLANO MENSAL PLUS*\n\n"
        f"üí∞ R$ {PLANOS_PRECOS.get('Mensal Plus', 0.0):.2f}/m√™s\n"
        "üîπ At√© 3 streamers monitorados\n"
        "üì¶ Ideal para ag√™ncias/clippers\n"
        f"‚ûï At√© 3 slots adicionais (R${PLANOS_PRECOS.get('Slot Extra', 0.0):.2f} cada - pagamento √∫nico)\n"
        "üìÖ Renova√ß√£o mensal\n\n"
        "Deseja continuar com esse plano?"
    )

    botoes = [
        [InlineKeyboardButton("‚úÖ Escolher este plano", callback_data="menu_5_plus")],
        [InlineKeyboardButton("üîô Voltar", callback_data="menu_3")]
    ]

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_4 ‚Üí Resumo plano Anual Pro
async def responder_menu_4_anual(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    texto = (
        f"*üìù RESUMO DO PLANO ANUAL PRO*\n\n"
        f"üí∞ R$ {PLANOS_PRECOS.get('Anual Pro', 0.0):.2f}/ano\n"
        "üîπ 3 streamers monitorados + 1 slot b√¥nus\n"
        "üéÅ Economia de 2 meses\n"
        f"‚ûï At√© 5 slots adicionais (R${PLANOS_PRECOS.get('Slot Extra', 0.0):.2f} cada - pagamento √∫nico)\n"
        "üìÖ Renova√ß√£o anual\n\n"
        "Deseja continuar com esse plano?"
    )

    botoes = [
        [InlineKeyboardButton("‚úÖ Escolher este plano", callback_data="menu_5_anual")],
        [InlineKeyboardButton("üîô Voltar", callback_data="menu_3")]
    ]

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes), parse_mode=ParseMode.MARKDOWN)


# menu_6 ‚Üí Confirma√ß√£o de pagamento
from core.pagamento import consultar_pagamento
from chat_privado.menus.menu_configurar_canal import menu_configurar_canal


async def responder_menu_6_confirmar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    pagamento_id = context.user_data.get("id_pagamento")

    if not pagamento_id:
        await query.edit_message_text(
            "‚ùå Nenhum pagamento encontrado.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Voltar ao in√≠cio", callback_data="menu_0")]
            ]),
            parse_mode=ParseMode.MARKDOWN
        )
        return

    status = consultar_pagamento(pagamento_id)

    if status == "approved":
        await query.edit_message_text("‚úÖ Pagamento confirmado! Vamos configurar seu canal...")
        await menu_configurar_canal(update, context)

    elif status == "pending":
        await query.edit_message_text(
            "‚è≥ O pagamento ainda n√£o foi identificado.\n"
            "Isso pode levar alguns minutos, tente novamente em instantes.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Verificar novamente", callback_data="menu_6")],
                [InlineKeyboardButton("üîô Voltar ao in√≠cio", callback_data="menu_0")]
            ]),
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        await query.edit_message_text(
            f"‚ùå Ocorreu um erro ao consultar o pagamento (status: {status})",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÅ Tentar novamente", callback_data="menu_0")]
            ]),
            parse_mode=ParseMode.MARKDOWN
        )

async def responder_menu_7_configurar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    atualizar_usuario_contexto(update, context)
    await query.answer()

    telegram_id = context.user_data.get("telegram_id")
    configurado = buscar_configuracao_canal(telegram_id)

    if configurado and configurado.get("streamers_monitorados"):
        texto = f"‚öôÔ∏è E a√≠, meu assinante favorito?\n\nSeu canal j√° est√° configurado com sucesso!\nO que deseja fazer agora?"
        botoes = [
            [InlineKeyboardButton("üéØ Streamers", callback_data="alterar_streamer")],
            [InlineKeyboardButton("‚öôÔ∏è Modo de monitoramento", callback_data="alterar_modo_monitoramento")],
            [InlineKeyboardButton("‚ûï Adicionar slot", callback_data="adicionar_slot")],
            [InlineKeyboardButton("üîë Reconfigurar chaves da Twitch", callback_data="iniciar_envio_twitch")],
            [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
        ]
    else:
        texto = "üîß Vamos come√ßar a configura√ß√£o do seu canal personalizado."
        botoes = [
            [InlineKeyboardButton("‚û°Ô∏è Continuar", callback_data="iniciar_envio_twitch")],
            [InlineKeyboardButton("üîô Voltar ao menu", callback_data="menu_0")]
        ]

    try:
        await query.edit_message_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes))
    except BadRequest:
        await query.message.reply_text(text=texto, reply_markup=InlineKeyboardMarkup(botoes))


# Registrar handler para menu_7_configurar
def registrar_menu_configurar(application):
    application.add_handler(CallbackQueryHandler(responder_menu_7_configurar, pattern="^menu_7_configurar$"))

# Handlers para os submenus do bot√£o "Configurar canal"
def registrar_submenus_configuracao(application):
    application.add_handler(CallbackQueryHandler(lambda u, c: u.callback_query.answer("üöß Em breve: Alterar streamer!"), pattern="^alterar_streamer$"))
    application.add_handler(CallbackQueryHandler(lambda u, c: u.callback_query.answer("üöß Em breve: Alterar modo de monitoramento!"), pattern="^alterar_modo_monitoramento$"))
    application.add_handler(CallbackQueryHandler(lambda u, c: u.callback_query.answer("üöß Em breve: Adicionar slot!"), pattern="^adicionar_slot$"))
    application.add_handler(CallbackQueryHandler(responder_menu_7_configurar, pattern="^configurar_chaves_twitch$"))


# Handler para iniciar envio twitch
async def responder_menu_iniciar_envio_twitch(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    texto = (
        "üß© Vamos configurar seu Clipador!\n\n"
        "Para funcionar, voc√™ precisa criar um app na Twitch com as seguintes credenciais:\n\n"
        "1Ô∏è‚É£ V√° em https://dev.twitch.tv/console/apps\n"
        "2Ô∏è‚É£ Clique em *Register Your Application*\n"
        "3Ô∏è‚É£ Nomeie como quiser\n"
        "4Ô∏è‚É£ Redirecione para: `https://localhost`\n"
        "5Ô∏è‚É£ Selecione 'Chat Bot'\n\n"
        "Depois de criar, me envie:\n"
        "- `Client ID`\n"
        "- `Client Secret`\n\n"
        "Pode colar aqui mesmo, eu vou te guiando! üòé"
    )

    try:
        await query.edit_message_text(text=texto, parse_mode=ParseMode.MARKDOWN)
    except BadRequest:
        await query.message.reply_text(text=texto, parse_mode=ParseMode.MARKDOWN)


def registrar_menu_iniciar_envio_twitch(application):
    application.add_handler(CallbackQueryHandler(responder_menu_iniciar_envio_twitch, pattern="^iniciar_envio_twitch$"))
---
üìÑ chat_privado/menus/menu_compra.py
---
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from configuracoes import SUPPORT_USERNAME

# üí¨ Menu principal quando o usu√°rio acessa o bot no privado
async def mostrar_menu_principal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üì¶ Ver planos dispon√≠veis", callback_data="ver_planos")],
        [InlineKeyboardButton("üí≥ Comprar assinatura", callback_data="comprar_assinatura")],
        [InlineKeyboardButton("üõü Falar com o suporte", url=f"https://t.me/{SUPPORT_USERNAME}")]
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "üëã Bem-vindo ao Clipador!\n\n"
        "Escolha uma op√ß√£o abaixo para continuar:",
        reply_markup=reply_markup
    )

# üìã Mostra os planos dispon√≠veis
async def ver_planos_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    mensagem = (
        "üí≥ <b>Planos dispon√≠veis:</b>\n\n"
        "üîπ <b>Mensal</b> - R$49,90\n"
        "‚Ä¢ 1 streamer fixo\n"
        "‚Ä¢ Canal exclusivo no Telegram\n\n"
        "üî∏ <b>Anual</b> - R$499,90\n"
        "‚Ä¢ At√© 3 streamers fixos\n"
        "‚Ä¢ Canal exclusivo\n"
        "‚Ä¢ Suporte priorit√°rio\n\n"
        "Para contratar, clique em <b>Comprar assinatura</b>!"
    )

    await query.edit_message_text(
        mensagem,
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Voltar", callback_data="voltar_menu")]
        ])
    )

# üí≥ In√≠cio do processo de compra
async def comprar_assinatura_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Aqui voc√™ poderia gerar QR Code, registrar status de pagamento etc.
    mensagem = (
        "üí∏ Para comprar sua assinatura, envie um Pix para:\n\n"
        "<b>chavepix@email.com</b>\n"
        "Valor: <b>R$49,90</b> (Plano Mensal)\n\n"
        f"Depois do pagamento, envie o comprovante para @{SUPPORT_USERNAME}\n\n"
        "Assim que confirmado, criaremos seu canal autom√°tico!"
    )

    await query.edit_message_text(
        mensagem,
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Voltar", callback_data="voltar_menu")]
        ])
    )

# üîô Volta ao menu principal
async def voltar_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await mostrar_menu_principal(query, context)

---
üìÑ canal_gratuito/main.py
---
import os
import time
from datetime import datetime, timezone
import asyncio
from typing import TYPE_CHECKING

from memoria.estado import carregar_estado, salvar_estado
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

from core.ambiente import TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET # Importar as credenciais globais
from .core.twitch import TwitchAPI
from .core.monitor import ( # Importando as fun√ß√µes e constantes necess√°rias
    agrupar_clipes_por_proximidade,
    get_time_minutes_ago,
    minimo_clipes_por_viewers,
    eh_clipe_ao_vivo_real,
    INTERVALO_SEGUNDOS, # Usado no modo MANUAL
    INTERVALO_MONITORAMENTO,
    MINIMO_CLIPES, # Usado no modo MANUAL
    MODOS_MONITORAMENTO, # Usado para o modo AUTOMATICO
)
from configuracoes import (
    CANAL_GRATUITO_ID,
    INTERVALO_MENSAGEM_PROMOCIONAL,
    INTERVALO_MENSAGEM_HEADER,
    INTERVALO_ATUALIZACAO_STREAMERS,
    TIPO_LOG,
    ATUALIZAR_DESCRICAO,
    ENVIAR_CLIPES,
    USAR_VERIFICACAO_AO_VIVO,
    MODO_MONITORAMENTO_GRATUITO,
    QUANTIDADE_STREAMERS_TOP_BR,
    STREAMERS_ADICIONAIS_GRATUITO,
    INTERVALO_ANALISE_MINUTOS_GRATUITO,
)

TIMEOUT_REQUESTS = 20 # Segundos para timeout das requisi√ß√µes √† Twitch

def limpar_terminal():
    os.system("cls" if os.name == "nt" else "clear")

if TYPE_CHECKING:
    from telegram.ext import Application

async def main(application: "Application"):
    if TIPO_LOG == "DESENVOLVEDOR":
        print("üîå Conectando √† Twitch API...")

    twitch = TwitchAPI(TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET)

    if TIPO_LOG == "DESENVOLVEDOR":
        print("üìÇ Carregando estado do bot...")

    estado = carregar_estado()
    estado.setdefault("ultima_execucao", None)
    estado.setdefault("ultimo_envio_promocional", 0)
    estado.setdefault("ultimo_envio_header", 0)
    estado.setdefault("ultimo_envio_atualizacao_streamers", 0)
    estado.setdefault("grupos_enviados", [])
    estado.setdefault("ultima_descricao", "")

    try:
        while True:
            agora = time.time()
            total_ao_vivo = 0
            total_vod = 0
            grupo_enviado = False
            total_clipes = 0
            minimo_clipes_global = 0
            requests_count = 0

            # üÜï ATUALIZAR A LISTA DE STREAMERS A CADA CICLO
            try:
                top_logins = await asyncio.wait_for(
                    twitch.get_top_streamers_brasil(quantidade=QUANTIDADE_STREAMERS_TOP_BR),
                    timeout=TIMEOUT_REQUESTS
                )
            except asyncio.TimeoutError:
                print(f"‚ö†Ô∏è Timeout ao buscar top streamers do Brasil. Pulando ciclo de atualiza√ß√£o.")
                top_logins = []
            requests_count += 1

            # Combina a lista de top streamers com a lista de streamers adicionais, sem duplicatas
            # Mant√©m a ordem: adicionais primeiro, depois os tops.
            combined_logins = []
            seen_logins = set()

            for login in STREAMERS_ADICIONAIS_GRATUITO:
                login_lower = login.lower()
                if login_lower not in seen_logins:
                    combined_logins.append(login)
                    seen_logins.add(login_lower)

            for login in top_logins:
                login_lower = login.lower()
                if login_lower not in seen_logins:
                    combined_logins.append(login)
                    seen_logins.add(login_lower)

            async def get_user_info_with_timeout(login):
                try:
                    return await asyncio.wait_for(twitch.get_user_info(login), timeout=TIMEOUT_REQUESTS)
                except asyncio.TimeoutError:
                    print(f"‚ö†Ô∏è Timeout ao buscar informa√ß√µes de @{login}. Pulando.")
                    return None

            # Busca as informa√ß√µes dos usu√°rios para a lista combinada
            # Otimiza a busca de informa√ß√µes dos usu√°rios em paralelo
            tasks = [get_user_info_with_timeout(login) for login in combined_logins]
            user_infos = await asyncio.gather(*tasks)
            streamers_a_monitorar = [info for info in user_infos if info] # Filtra os resultados nulos
            requests_count += len(combined_logins) # Conta as chamadas de get_user_info

            # Salva os streamers monitorados para o comando de stats
            application.bot_data['free_channel_streamers'] = [s['display_name'] for s in streamers_a_monitorar]
            if not streamers_a_monitorar:
                print("‚ùå Nenhum streamer encontrado no momento.")
                time.sleep(INTERVALO_MONITORAMENTO)
                continue

            if TIPO_LOG == "DESENVOLVEDOR":
                print("üîÑ Lista de streamers atualizada:", ", ".join([s["display_name"] for s in streamers_a_monitorar]))

            # Corre√ß√£o: buscar clipes retroativos de 5 minutos
            tempo_inicio = get_time_minutes_ago(minutes=INTERVALO_ANALISE_MINUTOS_GRATUITO)

            for streamer in streamers_a_monitorar:
                user_id = streamer["id"]
                display_name = streamer["display_name"]

                if TIPO_LOG == "DESENVOLVEDOR":
                    print(f"üé• Buscando clipes de @{display_name}...")

                try:
                    clipes = await asyncio.wait_for(
                        twitch.get_recent_clips(user_id, started_at=tempo_inicio),
                        timeout=TIMEOUT_REQUESTS
                    )
                except asyncio.TimeoutError:
                    print(f"‚ö†Ô∏è Timeout ao buscar clipes de @{display_name}. Pulando este streamer no ciclo.")
                    clipes = []
                requests_count += 1
                total_clipes += len(clipes)
                clipes_novos = []
                for c in clipes:
                    c_time = datetime.fromisoformat(c["created_at"].replace("Z", "+00:00"))
                    repetido = any(
                        datetime.fromisoformat(grupo["inicio"]) <= c_time <= datetime.fromisoformat(grupo["fim"])
                        for grupo in estado["grupos_enviados"]
                    )
                    if not repetido:
                        clipes_novos.append(c)

                if TIPO_LOG == "DESENVOLVEDOR":
                    print(f"üîé {len(clipes_novos)} clipes novos encontrados.")

                if MODO_MONITORAMENTO_GRATUITO == 'AUTOMATICO':
                    stream = None
                    try:
                        stream = await asyncio.wait_for(
                            twitch.get_stream_info(user_id),
                            timeout=TIMEOUT_REQUESTS
                        )
                    except asyncio.TimeoutError:
                        print(f"‚ö†Ô∏è Timeout ao buscar status da stream de @{display_name}. Assumindo offline.")
                    requests_count += 1
                    viewers = stream["viewer_count"] if stream else 0
                    minimo_clipes = minimo_clipes_por_viewers(viewers)
                    intervalo_agrupamento = MODOS_MONITORAMENTO["AUTOMATICO"]["intervalo_segundos"]
                else:  # MODO_MONITORAMENTO_GRATUITO == 'MANUAL'
                    minimo_clipes = MINIMO_CLIPES
                    intervalo_agrupamento = INTERVALO_SEGUNDOS

                minimo_clipes_global = max(minimo_clipes_global, minimo_clipes)

                virais = agrupar_clipes_por_proximidade(clipes_novos, intervalo_agrupamento, minimo_clipes)

                for grupo in virais:
                    # Se este for o primeiro clipe do ciclo, envia as mensagens de status/promo√ß√£o ANTES.
                    if not grupo_enviado:
                        if INTERVALO_MENSAGEM_PROMOCIONAL > 0 and agora - estado["ultimo_envio_promocional"] >= INTERVALO_MENSAGEM_PROMOCIONAL:
                            mensagem_promo = "<b>ü§ë Transforme clipes em dinheiro!</b>\nCom o Clipador, voc√™ tem acesso aos melhores clipes em tempo real, prontos para voc√™ monetizar.\n\nGaranta agora üëâ @ClipadorBot"
                            await application.bot.send_message(chat_id=CANAL_GRATUITO_ID, text=mensagem_promo, parse_mode="HTML")
                            estado["ultimo_envio_promocional"] = agora

                        if INTERVALO_ATUALIZACAO_STREAMERS > 0 and agora - estado["ultimo_envio_atualizacao_streamers"] >= INTERVALO_ATUALIZACAO_STREAMERS:
                            mensagem_update = f"Estamos acompanhando em tempo real os <b>{len(streamers_a_monitorar)} streamers mais assistidos do Brasil</b> no momento.\n\nüì∫ Fique ligado e aproveite os melhores clipes! üéØ"
                            await application.bot.send_message(chat_id=CANAL_GRATUITO_ID, text=mensagem_update, parse_mode="HTML")
                            estado["ultimo_envio_atualizacao_streamers"] = agora

                    inicio = grupo["inicio"]
                    fim = datetime.fromisoformat(grupo["fim"].replace("Z", "+00:00"))
                    quantidade = len(grupo["clipes"])
                    primeiro_clipe = grupo["clipes"][0]
                    clipe_url = primeiro_clipe["url"]

                    is_live = False
                    if USAR_VERIFICACAO_AO_VIVO:
                        try:
                            is_live = await asyncio.wait_for(
                                eh_clipe_ao_vivo_real(primeiro_clipe, twitch, user_id),
                                timeout=TIMEOUT_REQUESTS
                            )
                        except asyncio.TimeoutError:
                            print(f"‚ö†Ô∏è Timeout ao verificar se o clipe de @{display_name} √© ao vivo. Assumindo VOD.")
                            is_live = False
                    tipo_raw = "CLIPE AO VIVO" if is_live else "CLIPE DO VOD"
                    tipo_formatado = f"\nüî¥ <b>{tipo_raw}</b>" if tipo_raw == "CLIPE AO VIVO" else f"\n‚è≥ <b>{tipo_raw}</b>"

                    mensagem = (
                        f"{tipo_formatado}\n"
                        f"üì∫ @{display_name}\n"
                        f"üïí {inicio.strftime('%H:%M:%S')} - {fim.strftime('%H:%M:%S')}\n"
                        f"üî• {quantidade} PESSOAS CLIPARAM\n\n"
                        f"{clipe_url}"
                    )

                    try:
                        slug = clipe_url.split("/")[-1]
                        download_url = f"https://clipr.xyz/{slug}"
                    except Exception:
                        download_url = clipe_url

                    if ENVIAR_CLIPES:
                        botoes = [[InlineKeyboardButton("üì• BAIXAR CLIPE", url=download_url)]]
                        await application.bot.send_message(
                            chat_id=CANAL_GRATUITO_ID,
                            text=mensagem,
                            reply_markup=InlineKeyboardMarkup(botoes),
                            parse_mode="HTML"
                        )

                    estado["grupos_enviados"].append({
                        "inicio": inicio.isoformat(),
                        "fim": fim.isoformat()
                    })

                    if tipo_raw == "CLIPE AO VIVO":
                        total_ao_vivo += 1
                    else:
                        total_vod += 1

                    grupo_enviado = True

            # ATUALIZA√á√ÉO DA DESCRI√á√ÉO (MOVIDO PARA FORA DO LOOP DE STREAMERS)
            if ATUALIZAR_DESCRICAO:
                try:
                    logins_monitorados = [s["login"] for s in streamers_a_monitorar]
                    cabecalho = (
                        f"O CLIPADOR EST√Å ONLINE üòé\n"
                        f"üëÄ Monitorando {len(streamers_a_monitorar)} streamers agora üëá"
                    )
                    lista = "\n" + "\n".join([f"‚Ä¢ @{login}" for login in logins_monitorados]) if logins_monitorados else ""

                    if MODO_MONITORAMENTO_GRATUITO == 'MANUAL':
                        criterio = f"\nüî• Crit√©rio: Grupo de {MINIMO_CLIPES} clipes em {INTERVALO_SEGUNDOS}s"
                    else: # AUTOMATICO
                        criterio = f"\nüî• Crit√©rio: Autom√°tico (sensibilidade atual: {minimo_clipes_global} clipes)"

                    descricao_nova = f"{cabecalho}{lista}{criterio}"

                    if len(descricao_nova) > 255:
                        descricao_nova = descricao_nova[:252] + "..."

                    if descricao_nova != estado.get("ultima_descricao"):
                        await application.bot.set_chat_description(chat_id=CANAL_GRATUITO_ID, description=descricao_nova)
                        estado["ultima_descricao"] = descricao_nova
                        print("‚úÖ Descri√ß√£o do canal atualizada com sucesso.")
                except Exception as e:
                    if "Chat description is not modified" not in str(e):
                        print(f"‚ö†Ô∏è Erro ao atualizar descri√ß√£o: {e}")
            total_enviados = total_ao_vivo + total_vod

            if TIPO_LOG == "PADRAO":
                limpar_terminal()
                print(f"üéØ Monitorando {len(streamers_a_monitorar)} streamers")
                print("-" * 50)
                print(f"üé• {total_clipes} clipe(s) encontrados nos √∫ltimos {INTERVALO_ANALISE_MINUTOS_GRATUITO} minutos.")
                if total_enviados == 0:
                    print("‚ùå Nenhum grupo viral identificado.")
                else:
                    print(f"‚úÖ {total_enviados} grupo(s) enviado(s): {total_ao_vivo} AO VIVO / {total_vod} VOD")
                print("-" * 50)
                print(f"üß† MODO DE MONITORAMENTO: {MODO_MONITORAMENTO_GRATUITO}")
                if MODO_MONITORAMENTO_GRATUITO == 'MANUAL':
                    print(f"üî• CRIT√âRIO: Grupo de {MINIMO_CLIPES} clipes em {INTERVALO_SEGUNDOS}s")
                else:
                    # No modo autom√°tico, o crit√©rio muda a cada streamer, ent√£o mostramos o mais exigente do ciclo
                    print(f"üî• CRIT√âRIO: Autom√°tico (sensibilidade atual: {minimo_clipes_global} clipes)")
                print(f"‚è∞ √öLTIMA VERIFICA√á√ÉO: {datetime.now().strftime('%H:%M:%S')}")
            elif TIPO_LOG == "DESENVOLVEDOR":
                print(f"üìº Grupos enviados: {total_enviados}")

            estado["ultima_execucao"] = datetime.now(timezone.utc).isoformat()
            salvar_estado(estado)
            # Salva o total de requisi√ß√µes do ciclo
            application.bot_data['free_channel_requests'] = requests_count
            await asyncio.sleep(INTERVALO_MONITORAMENTO)

    except asyncio.CancelledError:
        try:
            descricao_offline = "O CLIPADOR EST√Å OFFLINE üò≠"
            await application.bot.set_chat_description(chat_id=CANAL_GRATUITO_ID, description=descricao_offline)
            print("\nüõë Monitor do canal gratuito encerrado.")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao atualizar descri√ß√£o OFFLINE no monitor gratuito: {e}")
        salvar_estado(estado)
        raise # Re-raise CancelledError para que a tarefa seja finalizada corretamente
    except Exception as e:
        print(f"‚ùå Erro inesperado no monitor do canal gratuito: {e}")
        salvar_estado(estado)

---
üìÑ canal_gratuito/core/monitor.py
---
from datetime import datetime, timedelta, timezone
from typing import Callable, Union

# Modos antigos (mantidos apenas para uso futuro nos canais privados)
MODOS_MONITORAMENTO = {
    "MODO_LOUCO": {"min_clipes": 2, "intervalo_segundos": 150},
    "MODO_PADRAO": {"min_clipes": 3, "intervalo_segundos": 90},
    "MODO_CIRURGICO": {"min_clipes": 5, "intervalo_segundos": 60},
    # MODO_AUTOMATICO usar√° o padr√£o
    "AUTOMATICO": {"min_clipes": 3, "intervalo_segundos": 90},
}

# Crit√©rio fixo para o canal gratuito
INTERVALO_SEGUNDOS = 120
INTERVALO_MONITORAMENTO = 30
MINIMO_CLIPES = 3

def agrupar_clipes_por_proximidade(
    clipes,
    intervalo_segundos: int,
    criterio_min_clipes: Union[int, Callable[[int], int]]
):
    clipes_ordenados = sorted(
        clipes,
        key=lambda c: datetime.fromisoformat(c["created_at"].replace("Z", "+00:00"))
    )

    grupos = []
    usados = set()

    for i, clipe_base in enumerate(clipes_ordenados):
        if clipe_base["id"] in usados:
            continue

        base_time = datetime.fromisoformat(clipe_base["created_at"].replace("Z", "+00:00"))
        grupo = [clipe_base]
        usados_temp = {clipe_base["id"]}

        for j in range(i + 1, len(clipes_ordenados)):
            outro_clipe = clipes_ordenados[j]
            outro_time = datetime.fromisoformat(outro_clipe["created_at"].replace("Z", "+00:00"))
            delta = (outro_time - base_time).total_seconds()

            if delta <= intervalo_segundos and outro_clipe["id"] not in usados:
                grupo.append(outro_clipe)
                usados_temp.add(outro_clipe["id"])
            else:
                break

        # Obt√©m o valor m√≠nimo de clipes para este grupo
        # Se o crit√©rio for uma fun√ß√£o, chama a fun√ß√£o passando os viewers e usa o resultado.
        # Se for um inteiro, usa o valor diretamente.
        minimo_para_este_grupo = criterio_min_clipes(clipe_base.get('viewer_count', 0)) if callable(criterio_min_clipes) else criterio_min_clipes


        if len(grupo) >= minimo_para_este_grupo:
            grupos.append({
                "inicio": base_time,
                "fim": grupo[-1]["created_at"],
                "clipes": grupo
            })
            usados.update(usados_temp)

    return grupos

def get_time_minutes_ago(minutes: int = 5) -> str:
    """
    Calcula o tempo X minutos atr√°s a partir do tempo UTC atual.
    Retorna uma string no formato ISO 8601 com 'Z' (Zulu time) e precis√£o de milissegundos,
    compat√≠vel com a API da Twitch.
    """
    dt = datetime.now(timezone.utc) - timedelta(minutes=minutes)
    return dt.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'

def minimo_clipes_por_viewers(viewers: int) -> int:
    """
    Define a quantidade m√≠nima de clipes necess√°rios com base na contagem de espectadores.
    Quanto maior a audi√™ncia, mais exigente o crit√©rio se torna.
    """
    if viewers < 1000:
        return 2  # Para streamers menores, 2 clipes j√° √© um bom sinal
    elif viewers < 5000:
        return 3  # Para streamers m√©dios, o padr√£o
    elif viewers < 15000:
        return 4  # Para streamers grandes, precisa de mais gente clipando
    else: # 15k+ viewers
        return 5  # Para gigantes, o evento precisa ser muito forte

async def eh_clipe_ao_vivo_real(clip, twitch, user_id):
    stream = await twitch.get_stream_info(user_id)
    if not stream:
        return False

    vod = await twitch.get_latest_vod(user_id)
    if not vod:
        return False

    if str(clip.get("video_id")) != str(vod["id"]):
        return False

    vod_start = datetime.fromisoformat(vod["created_at"].replace("Z", "+00:00"))
    agora = datetime.now(timezone.utc)
    clip_created = datetime.fromisoformat(clip["created_at"].replace("Z", "+00:00"))

    return vod_start <= clip_created <= agora
---
üìÑ canal_gratuito/core/telegram.py
---
import requests
from core.ambiente import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID

ultima_descricao = None

def enviar_mensagem(texto, botao_url=None, botao_texto=None, chat_id=TELEGRAM_CHAT_ID):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": texto,
        "parse_mode": "HTML",
        "disable_web_page_preview": False,
    }

    if botao_url and botao_texto:
        payload["reply_markup"] = {
            "inline_keyboard": [[{"text": botao_texto, "url": botao_url}]]
        }

    r = requests.post(url, json=payload)
    r.raise_for_status()


def atualizar_descricao_telegram(minimo_clipes, intervalo_segundos, quantidade_streamers, logins=None, chat_id=TELEGRAM_CHAT_ID):
    global ultima_descricao

    cabecalho = (
        f"O CLIPADOR EST√Å ONLINE üòé\n"
        f"üëÄ Monitorando os {quantidade_streamers} streamers üáßüá∑ mais assistidos agora üëá"
    )

    lista = "\n" + "\n".join([f"‚Ä¢ @{login}" for login in logins]) if logins else ""
    criterio = f"\nüî• Crit√©rio: Grupo de {minimo_clipes} clipes em {intervalo_segundos}s"

    descricao_nova = f"{cabecalho}{lista}{criterio}"

    if descricao_nova == ultima_descricao:
        # ‚úÖ Descri√ß√£o j√° est√° atualizada, n√£o loga nada
        return

    if len(descricao_nova) > 255:
        descricao_nova = descricao_nova[:252] + "..."

    try:
        response = requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setChatDescription",
            json={"chat_id": chat_id, "description": descricao_nova}
        )

        if response.status_code == 400 and "Bad Request" in response.text:
            # ‚ö†Ô∏è Provavelmente descri√ß√£o id√™ntica ou erro de permiss√£o, ignora sem logar
            return

        response.raise_for_status()
        ultima_descricao = descricao_nova
        print("‚úÖ Descri√ß√£o do canal atualizada com sucesso.")

    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è Erro ao atualizar descri√ß√£o do canal: {e}")



def enviar_mensagem_promocional(chat_id=TELEGRAM_CHAT_ID):
    mensagem = (
        "<b>ü§ë Transforme clipes em dinheiro!</b>\n"
        "Com o Clipador, voc√™ tem acesso aos melhores clipes em tempo real, prontos para voc√™ monetizar.\n\n"
        "Garanta agora üëâ @ClipadorBot"
    )
    enviar_mensagem(mensagem, chat_id=chat_id)

def enviar_header_streamers(lista_streamers, chat_id=TELEGRAM_CHAT_ID):
    if not lista_streamers:
        return

    # 1. Desfixar mensagem anterior (se houver)
    try:
        url_unpin = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/unpinChatMessage"
        requests.post(url_unpin, json={"chat_id": chat_id})
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao desfixar mensagem anterior: {e}")

    # 2. Criar nova mensagem
    nomes = "\n".join([f"‚Ä¢ @{s}" for s in lista_streamers])
    mensagem = (
        "üì¢ <b>STREAMERS MONITORADOS AGORA:</b>\n"
        f"{nomes}\n\n"
        "üöÄ <b>Quer monitorar outros?</b> Assine o Clipador üëâ @ClipadorBot"
    )

    url_send = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": mensagem,
        "parse_mode": "HTML"
    }

    r = requests.post(url_send, json=payload)
    r.raise_for_status()
    message_id = r.json().get("result", {}).get("message_id")

    # 3. Fixar a nova
    if message_id:
        url_pin = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/pinChatMessage"
        requests.post(url_pin, json={"chat_id": chat_id, "message_id": message_id, "disable_notification": True})

def enviar_mensagem_atualizacao_streamers(qtd=5, chat_id=TELEGRAM_CHAT_ID):
    mensagem = (
        f"Estamos acompanhando em tempo real os <b>{qtd} streamers mais assistidos do Brasil</b> no momento.\n\n"
        "üì∫ Fique ligado e aproveite os melhores clipes! üéØ"
    )
    enviar_mensagem(mensagem, chat_id=chat_id)

def atualizar_descricao_telegram_offline(chat_id=TELEGRAM_CHAT_ID):
    descricao = "O CLIPADOR EST√Å OFFLINE üò≠"

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setChatDescription"
    data = {
        "chat_id": chat_id,
        "description": descricao
    }

    try:
        r = requests.post(url, json=data)
        r.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è Erro ao atualizar descri√ß√£o do canal para OFFLINE: {e}")

---
üìÑ canal_gratuito/core/estado.py
---
import json
import os
import logging
from datetime import datetime, timedelta, timezone

logger = logging.getLogger(__name__)

CAMINHO_ESTADO = os.path.join("memoria", "estado.json")

def carregar_estado():
    """Carrega o estado do arquivo JSON."""
    os.makedirs(os.path.dirname(CAMINHO_ESTADO), exist_ok=True)
    if not os.path.exists(CAMINHO_ESTADO):
        return {"clipes_enviados": [], "streamers_monitorados": []}
    try:
        with open(CAMINHO_ESTADO, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        logger.warning("Arquivo estado.json n√£o encontrado ou corrompido. Criando um novo.")
        return {"clipes_enviados": [], "streamers_monitorados": []}

def salvar_estado(estado: dict):
    """Salva o estado atual no arquivo JSON e remove clipes enviados h√° mais de 2 horas."""
    agora = datetime.now(timezone.utc)
    limite_tempo = agora - timedelta(hours=2)

    if "clipes_enviados" in estado and isinstance(estado["clipes_enviados"], list):
        clipes_recentes = []
        total_antes = len(estado["clipes_enviados"])

        for clipe in estado["clipes_enviados"]:
            try:
                if isinstance(clipe, dict) and "enviado_em" in clipe:
                    timestamp_clipe = datetime.fromisoformat(clipe["enviado_em"])
                    if timestamp_clipe >= limite_tempo:
                        clipes_recentes.append(clipe)
                else:
                    clipes_recentes.append(clipe)
            except (ValueError, TypeError):
                logger.warning(f"Timestamp inv√°lido encontrado no estado.json: {clipe.get('enviado_em')}")
                clipes_recentes.append(clipe)
        
        removidos = total_antes - len(clipes_recentes)
        if removidos > 0:
            logger.info(f"Limpeza de estado.json: {removidos} clipes com mais de 2 horas foram removidos.")

        estado["clipes_enviados"] = clipes_recentes

    try:
        with open(CAMINHO_ESTADO, "w", encoding="utf-8") as f:
            json.dump(estado, f, indent=4)
    except Exception as e:
        logger.error(f"Erro ao salvar o arquivo de estado: {e}", exc_info=True)

def registrar_clipe_enviado(clipe_id: str, streamer: str):
    """Registra um novo clipe como enviado e salva o estado (com limpeza)."""
    estado = carregar_estado()
    agora_iso = datetime.now(timezone.utc).isoformat()
    estado["clipes_enviados"].append({"id": clipe_id, "streamer": streamer, "enviado_em": agora_iso})
    salvar_estado(estado)

def verificar_clipe_ja_enviado(clipe_id: str) -> bool:
    """Verifica se um clipe j√° foi enviado lendo o estado atual."""
    estado = carregar_estado()
    return any(clipe.get("id") == clipe_id for clipe in estado.get("clipes_enviados", []))
---
üìÑ canal_gratuito/core/twitch.py
---
import sys
import os
import httpx

from core.ambiente import TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET
class TwitchAPI:
    def __init__(self, client_id: str, client_secret: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.token = None
        # Configura o transporte com retentativas para erros de conex√£o
        transport = httpx.AsyncHTTPTransport(retries=3)
        # Configura o cliente com o transporte e um timeout mais generoso
        self._client = httpx.AsyncClient(transport=transport, timeout=httpx.Timeout(15.0, connect=5.0))

    async def get_access_token(self):
        url = "https://id.twitch.tv/oauth2/token"
        params = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "client_credentials"
        }
        response = await self._client.post(url, params=params)
        response.raise_for_status()
        self.token = response.json()["access_token"]

    async def get_headers(self):
        if not self.token:
            await self.get_access_token()
        return {
            "Client-ID": self.client_id,
            "Authorization": f"Bearer {self.token}"
        }

    async def get_user_info(self, username):
        url = f"https://api.twitch.tv/helix/users?login={username}"
        r = await self._client.get(url, headers=await self.get_headers())
        r.raise_for_status()
        data = r.json()["data"]
        return data[0] if data else None

    async def get_stream_info(self, user_id):
        url = f"https://api.twitch.tv/helix/streams?user_id={user_id}"
        r = await self._client.get(url, headers=await self.get_headers())
        r.raise_for_status()
        data = r.json()["data"]
        return data[0] if data else None

    async def get_recent_clips(self, user_id, started_at):
        url = f"https://api.twitch.tv/helix/clips?broadcaster_id={user_id}&started_at={started_at}"
        r = await self._client.get(url, headers=await self.get_headers())
        r.raise_for_status()
        return r.json().get("data", [])

    async def get_latest_vod(self, user_id):
        url = f"https://api.twitch.tv/helix/videos?user_id={user_id}&first=1&type=archive"
        r = await self._client.get(url, headers=await self.get_headers())
        r.raise_for_status()
        data = r.json().get("data", [])
        return data[0] if data else None

    async def get_top_streamers_brasil(self, quantidade=5):
        url = f"https://api.twitch.tv/helix/streams?first=100&language=pt"
        r = await self._client.get(url, headers=await self.get_headers())
        r.raise_for_status()
        data = r.json().get("data", [])
        return [stream["user_login"] for stream in data[:quantidade]]

---
üìÑ memoria/estado.py
---
import json
import os
from datetime import datetime, timezone

ESTADO_PATH = "memoria/estado_bot.json"

def carregar_estado():
    if not os.path.exists(ESTADO_PATH):
        estado_inicial = {
            "ultima_execucao": None,
            "ultimo_envio_promocional": 0,
            "ultimo_envio_header": 0,
            "ultimo_envio_atualizacao_streamers": 0,
            "grupos_enviados": []
        }
        salvar_estado(estado_inicial)
        return estado_inicial

    with open(ESTADO_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

def salvar_estado(estado):
    with open(ESTADO_PATH, "w", encoding="utf-8") as f:
        json.dump(estado, f, ensure_ascii=False, indent=2)

def atualizar_execucao(estado):
    estado["ultima_execucao"] = datetime.now(timezone.utc).isoformat()
    salvar_estado(estado)

def grupo_ja_enviado(grupo, grupos_enviados):
    inicio = grupo["inicio"].isoformat()
    fim = grupo["fim"].isoformat()
    return any(g["inicio"] == inicio and g["fim"] == fim for g in grupos_enviados)

def adicionar_grupo_enviado(grupo, estado):
    estado["grupos_enviados"].append({
        "inicio": grupo["inicio"].isoformat(),
        "fim": grupo["fim"].isoformat()
    })
    salvar_estado(estado)

---
